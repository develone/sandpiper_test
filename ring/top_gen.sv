// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"


genvar ring_stop;


//
// Signals declared top-level.
//

// For $reset.
logic L0_reset_a0,
      L0_reset_a1;

// For /ring_stop|bp0/trans$cyc_cnt.
logic RingStop_BP0_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|bp1/trans$cyc_cnt.
logic RingStop_BP1_Trans_cyc_cnt_a0 [3:0],
      RingStop_BP1_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|bp2/trans$cyc_cnt.
logic RingStop_BP2_Trans_cyc_cnt_a0 [3:0],
      RingStop_BP2_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|rg$dest.
logic [1:0] RingStop_RG_dest_a1 [3:0],
            RingStop_RG_dest_a2 [3:0];

// For /ring_stop|rg$pass_on.
logic RingStop_RG_pass_on_a1 [3:0],
      RingStop_RG_pass_on_a2 [3:0];

// For /ring_stop|rg/trans$cyc_cnt.
logic RingStop_RG_Trans_cyc_cnt_a1 [3:0] /* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */,
      RingStop_RG_Trans_cyc_cnt_a2 [3:0] /* verilator lint_restore */;

// For /ring_stop|rg/trans$sender.
logic [1:0] RingStop_RG_Trans_sender_a1 [3:0] /* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */,
            RingStop_RG_Trans_sender_a2 [3:0] /* verilator lint_restore */;

// For /ring_stop|stall0/trans$cyc_cnt.
logic RingStop_STALL0_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL0_Trans_cyc_cnt_a2 [3:0];

// For /ring_stop|stall1/trans$cyc_cnt.
logic RingStop_STALL1_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL1_Trans_cyc_cnt_a2 [3:0];

// For /ring_stop|stall2/trans$cyc_cnt.
logic RingStop_STALL2_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL2_Trans_cyc_cnt_a2 [3:0];

// For /tb/ring_stop|passed$passed.
logic [3:0] Tb_RingStop_PASSED_passed_a1;

// For /tb|count$CycCount.
logic [15:0] Tb_COUNT_CycCount_a0,
             Tb_COUNT_CycCount_a1;


//
// Scope: /ring_stop[3:0]
//

//
// Scope: /ring_stop|bp1
//

// Clock signals.
logic clkP_RingStop_BP1_avail_a1 [3:0];

//
// Scope: /ring_stop|bp2
//

// Clock signals.
logic clkP_RingStop_BP2_avail_a1 [3:0];

//
// Scope: /ring_stop|rg
//

// Clock signals.
logic clkP_RingStop_RG_valid_a2 [3:0];

//
// Scope: /ring_stop|ring_out
//

// Clock signals.
logic clkP_RingStop_RING_OUT_trans_valid_a2 [3:0];
logic clkP_RingStop_RING_OUT_trans_valid_a3 [3:0];
logic clkP_RingStop_RING_OUT_trans_valid_a4 [3:0];

//
// Scope: /ring_stop|stall0
//

// Clock signals.
logic clkP_RingStop_STALL0_avail_a2 [3:0];

//
// Scope: /ring_stop|stall1
//

// Clock signals.
logic clkP_RingStop_STALL1_avail_a2 [3:0];

//
// Scope: /ring_stop|stall2
//

// Clock signals.
logic clkP_RingStop_STALL2_avail_a2 [3:0];

//
// Scope: /tb
//

//
// Scope: /tb/ring_stop[3:0]
//

//
// Scope: /tb/ring_stop|receive2
//

// Clock signals.
logic clkP_Tb_RingStop_RECEIVE2_avail_a1 [3:0];


generate

   // For $reset.
   always_ff @(posedge clk) L0_reset_a1 <= L0_reset_a0;


   //
   // Scope: /ring_stop[3:0]
   //
   for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1gen_RingStop

      //
      // Scope: |bp1
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP1_avail_a1 <= L1_RingStop[ring_stop].L1_BP1_avail_a0;

         // For $reset.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP1_reset_a1 <= L1_RingStop[ring_stop].L1_BP1_reset_a0;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_BP1_Trans_cyc_cnt_a1[ring_stop] <= RingStop_BP1_Trans_cyc_cnt_a0[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_BP1_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP1_Trans_dest_a1[1:0] <= L1_RingStop[ring_stop].L1_BP1_Trans_dest_a0[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_BP1_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP1_Trans_sender_a1[1:0] <= L1_RingStop[ring_stop].L1_BP1_Trans_sender_a0[1:0];




      //
      // Scope: |bp2
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP2_avail_a1 <= L1_RingStop[ring_stop].L1_BP2_avail_a0;

         // For $reset.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP2_reset_a1 <= L1_RingStop[ring_stop].L1_BP2_reset_a0;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_BP2_Trans_cyc_cnt_a1[ring_stop] <= RingStop_BP2_Trans_cyc_cnt_a0[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_BP2_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP2_Trans_dest_a1[1:0] <= L1_RingStop[ring_stop].L1_BP2_Trans_dest_a0[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_BP2_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP2_Trans_sender_a1[1:0] <= L1_RingStop[ring_stop].L1_BP2_Trans_sender_a0[1:0];




      //
      // Scope: |rg
      //

         // For $dest.
         always_ff @(posedge clk) RingStop_RG_dest_a2[ring_stop][1:0] <= RingStop_RG_dest_a1[ring_stop][1:0];

         // For $pass_on.
         always_ff @(posedge clk) RingStop_RG_pass_on_a2[ring_stop] <= RingStop_RG_pass_on_a1[ring_stop];


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clkP_RingStop_RG_valid_a2[ring_stop]) RingStop_RG_Trans_cyc_cnt_a2[ring_stop] <= RingStop_RG_Trans_cyc_cnt_a1[ring_stop];

            // For $sender.
            always_ff @(posedge clkP_RingStop_RG_valid_a2[ring_stop]) RingStop_RG_Trans_sender_a2[ring_stop][1:0] <= RingStop_RG_Trans_sender_a1[ring_stop][1:0];




      //
      // Scope: |ring_out
      //

         // For $avail.
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a2 <= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a3 <= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a2;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 <= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a3;

         // For $reset.
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a2 <= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a3 <= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a2;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a4 <= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a3;

         // For $trans_valid.
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2 <= L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a3 <= L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a2 <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a1;
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a3 <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a2;
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a4 <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a3;

            // For $sender.
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a2[1:0] <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a1[1:0];
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a3[1:0] <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a2[1:0];
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a4[1:0] <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a3[1:0];




      //
      // Scope: |stall0
      //

         // For $avail.
         always_ff @(posedge clk) L1e_RingStop[ring_stop].L1_STALL0_avail_a2 <= L1e_RingStop[ring_stop].L1_STALL0_avail_a1;

         // For $reset.
         always_ff @(posedge clk) L1e_RingStop[ring_stop].L1_STALL0_reset_a2 <= L1e_RingStop[ring_stop].L1_STALL0_reset_a1;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_STALL0_Trans_cyc_cnt_a2[ring_stop] <= RingStop_STALL0_Trans_cyc_cnt_a1[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_STALL0_avail_a2[ring_stop]) L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a2[1:0] <= L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a1[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_STALL0_avail_a2[ring_stop]) L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a2[1:0] <= L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a1[1:0];




      //
      // Scope: |stall1
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL1_avail_a2 <= L1_RingStop[ring_stop].L1_STALL1_avail_a1;

         // For $blocked.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL1_blocked_a2 <= L1_RingStop[ring_stop].L1_STALL1_blocked_a1;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_STALL1_Trans_cyc_cnt_a2[ring_stop] <= RingStop_STALL1_Trans_cyc_cnt_a1[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_STALL1_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL1_Trans_dest_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL1_Trans_dest_a1[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_STALL1_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL1_Trans_sender_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL1_Trans_sender_a1[1:0];




      //
      // Scope: |stall2
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL2_avail_a2 <= L1_RingStop[ring_stop].L1_STALL2_avail_a1;

         // For $blocked.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL2_blocked_a2 <= L1_RingStop[ring_stop].L1_STALL2_blocked_a1;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_STALL2_Trans_cyc_cnt_a2[ring_stop] <= RingStop_STALL2_Trans_cyc_cnt_a1[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_STALL2_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL2_Trans_dest_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL2_Trans_dest_a1[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_STALL2_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL2_Trans_sender_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL2_Trans_sender_a1[1:0];



   end

   //
   // Scope: /tb
   //


      //
      // Scope: /ring_stop[3:0]
      //
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1gen_Tb_RingStop

         //
         // Scope: |receive2
         //

            // For $OutstandingPackets.
            always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_OutstandingPackets_a1[16-1:0] <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_OutstandingPackets_a0[16-1:0];

            // For $avail.
            always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a0;

            // For $reset.
            always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a0;


            //
            // Scope: /trans
            //

               // For $cyc_cnt.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_cyc_cnt_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_cyc_cnt_a0;

               // For $dest.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_dest_a1[1:0] <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_dest_a0[1:0];

               // For $request.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_request_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_request_a0;

               // For $response.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_a0;

               // For $response_debug.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_debug_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_debug_a0;

               // For $sender.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_sender_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_sender_a0;



      end

      //
      // Scope: |count
      //

         // For $CycCount.
         always_ff @(posedge clk) Tb_COUNT_CycCount_a1[15:0] <= Tb_COUNT_CycCount_a0[15:0];





endgenerate



//
// Gated clocks.
//

generate



   //
   // Scope: /ring_stop[3:0]
   //
   for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1clk_RingStop

      //
      // Scope: |bp1
      //

         clk_gate gen_clkP_RingStop_BP1_avail_a1(clkP_RingStop_BP1_avail_a1[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_BP1_avail_a0, 1'b0);


      //
      // Scope: |bp2
      //

         clk_gate gen_clkP_RingStop_BP2_avail_a1(clkP_RingStop_BP2_avail_a1[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_BP2_avail_a0, 1'b0);


      //
      // Scope: |rg
      //

         clk_gate gen_clkP_RingStop_RG_valid_a2(clkP_RingStop_RG_valid_a2[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RG_valid_a1, 1'b0);


      //
      // Scope: |ring_out
      //

         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a2(clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a1, 1'b0);
         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a3(clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2, 1'b0);
         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a4(clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a3, 1'b0);


      //
      // Scope: |stall0
      //

         clk_gate gen_clkP_RingStop_STALL0_avail_a2(clkP_RingStop_STALL0_avail_a2[ring_stop], clk, 1'b1, L1e_RingStop[ring_stop].L1_STALL0_avail_a1, 1'b0);


      //
      // Scope: |stall1
      //

         clk_gate gen_clkP_RingStop_STALL1_avail_a2(clkP_RingStop_STALL1_avail_a2[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_STALL1_avail_a1, 1'b0);


      //
      // Scope: |stall2
      //

         clk_gate gen_clkP_RingStop_STALL2_avail_a2(clkP_RingStop_STALL2_avail_a2[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_STALL2_avail_a1, 1'b0);

   end

   //
   // Scope: /tb
   //


      //
      // Scope: /ring_stop[3:0]
      //
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1clk_Tb_RingStop

         //
         // Scope: |receive2
         //

            clk_gate gen_clkP_Tb_RingStop_RECEIVE2_avail_a1(clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop], clk, 1'b1, L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a0, 1'b0);

      end



endgenerate



generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.

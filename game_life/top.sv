`line 2 "top.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
`include "sp_default.vh" //_\SV

// --------------------------------------------------------------------
//
// This example implements Conway's Game of Life.
// In this "game", a grid of cells (10x10) are born and die based on the
// number of live neighbors they have in each step (clock cycle).
// A cell's neighbors are the surrounding 8 cells, which includes the
// diagonals.
//   - A cell is born if exactly 3 neighbors are alive.
//   - A cell dies from overcrowding or starvation if it have >3 or <2
//     neighbors.
//
// Output shows the grid in each step of simulation.
//
// This example shows:
//   - Use of SystemVerilog constants.
//   - Use of TL-Verilog "behavioral hierarchy".  (Eg, >xx[X_SIZE-1:0])
//   - That TL-Verilog is not just for pipelines!
//
// --------------------------------------------------------------------


module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */

// -------------------------
// Parameters

// Board size
localparam X_SIZE = 10;  // Note: There's a hardcoded X_SIZE in $display statement.
localparam Y_SIZE = 10;

/* verilator lint_off UNOPTFLAT */  // To silence Verilator warnings.

`include "top_gen.sv" //_\TLV



   // -------------------------
   // Design

   //_|default
      //_@1
         assign DEFAULT_reset_a1 = reset;
      for (yy = 0; yy <= Y_SIZE-1; yy++) begin : L1_DEFAULT_Yy //_/yy
         for (xx = 0; xx <= X_SIZE-1; xx++) begin : L2_Xx logic [3:0] L2_cnt_a1; logic [0:0] L2_init_alive_a1; //_/xx
            //_@1
               // Cell logic

               // ===========
               // Population count ($cnt) of 3x3 square (with edge logic).
               
               // Sum left + me + right.
               assign DEFAULT_Yy_Xx_row_cnt_a1[yy][xx][1:0] = {1'b0, (DEFAULT_Yy_Xx_alive_a2[yy][(xx + X_SIZE-1) % X_SIZE] & (xx > 0))} +
                               {1'b0, DEFAULT_Yy_Xx_alive_a2[yy][xx]} +
                               {1'b0, (DEFAULT_Yy_Xx_alive_a2[yy][(xx + 1) % X_SIZE] & (xx < X_SIZE-1))};
               // Sum three $row_cnt's: above + mine + below.
               assign L2_cnt_a1[3:0] = {2'b00, (DEFAULT_Yy_Xx_row_cnt_a1[(yy + Y_SIZE-1) % Y_SIZE][xx] & {2{(yy > 0)}})} +
                           {2'b00, DEFAULT_Yy_Xx_row_cnt_a1[yy][xx][1:0]} +
                           {2'b00, (DEFAULT_Yy_Xx_row_cnt_a1[(yy + 1) % Y_SIZE][xx] & {2{(yy < Y_SIZE-1)}})};


               // ===========
               // Init state.
               
               assign L2_init_alive_a1[0:0] = RW_rand_vect[(0 + ((yy * xx) ^ ((3 * xx) + yy))) % 257 +: 1];


               // ===========
               // Am I alive?
               
               assign DEFAULT_Yy_Xx_alive_a1[yy][xx] = DEFAULT_reset_a1 ? L2_init_alive_a1 :           // init
                        DEFAULT_Yy_Xx_alive_a2[yy][xx] ? (L2_cnt_a1 >= 3 && L2_cnt_a1 <= 4) :   // stay alive
                                    (L2_cnt_a1 == 3); end end                 // born






   // -------------------------
   // Embedded testbench
   //
   // Declare success when total live cells was above 25% and remains below 6.25% for 20 cycles.

   // Count live cells through accumulation, into $alive_cnt.
   // Accumulate right-to-left, then bottom-to-top through >yy[0].
   //_|default
      //_/tb
         //_@2
            for (yy = 0; yy <= Y_SIZE-1; yy++) begin : L1_DEFAULT_Tb_Yy logic [21:0] L1_below_alive_accum_a2; logic [10:0] L1_Xx_horiz_alive_accum_a2 [X_SIZE-1:0]; //_/yy
               for (xx = 0; xx <= X_SIZE-1; xx++) begin : L2_Xx logic [10:0] L2_right_alive_accum_a2; //_/xx
                  /*SV_plus*/
                     if (xx < X_SIZE - 1)
                        assign L2_right_alive_accum_a2[10:0] = L1_Xx_horiz_alive_accum_a2[xx + 1];
                     else
                        assign L2_right_alive_accum_a2[10:0] = 11'b0;
                  assign L1_Xx_horiz_alive_accum_a2[xx][10:0] = L2_right_alive_accum_a2 + {10'b0, DEFAULT_Yy_Xx_alive_a2[yy][xx]}; end
               /*SV_plus*/
                  if (yy < Y_SIZE -1)
                     assign L1_below_alive_accum_a2[21:0] = DEFAULT_Tb_Yy_vert_alive_accum_a2[yy + 1];
                  else
                     assign L1_below_alive_accum_a2[21:0] = 22'b0;
               assign DEFAULT_Tb_Yy_vert_alive_accum_a2[yy][21:0] = L1_below_alive_accum_a2 + {11'b0, L1_Xx_horiz_alive_accum_a2[0]}; end
            assign DEFAULT_Tb_alive_cnt_a2[21:0] = DEFAULT_Tb_Yy_vert_alive_accum_a2[0];
            assign DEFAULT_Tb_above_min_start_a2 = DEFAULT_Tb_alive_cnt_a2 > (X_SIZE * Y_SIZE) >> 2;  // 1/4
            assign DEFAULT_Tb_below_max_stop_a2  = DEFAULT_Tb_alive_cnt_a2 < (X_SIZE * Y_SIZE) >> 4;  // 1/16
            assign DEFAULT_Tb_start_ok_a2 = DEFAULT_reset_a2 ? 1'b0 : (DEFAULT_Tb_start_ok_a3 || DEFAULT_Tb_above_min_start_a2);
            assign DEFAULT_Tb_stop_cnt_a2[7:0] = DEFAULT_reset_a2  ? 8'b0 :
                             DEFAULT_Tb_below_max_stop_a2 ? DEFAULT_Tb_stop_cnt_a3 + 8'b1 :
                                               8'b0;
            assign passed = DEFAULT_Tb_start_ok_a3 && ((DEFAULT_Tb_alive_cnt_a2 == '0) || (DEFAULT_Tb_stop_cnt_a3 > 8'd20));

      //_/print
         // Print
         //_@2
            /*SV_plus*/
               always_ff @(posedge clk) begin
                  $display("---------------");
                  for (int y = 0; y < Y_SIZE; y++) begin
                     if (! DEFAULT_reset_a2) begin
                        $display("    %10b", DEFAULT_Yy_Xx_alive_a2[y]);
                     end
                  end
               end endgenerate
//_\SV
endmodule

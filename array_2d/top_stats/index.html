<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 286, 856, 0, 22, 647, 63, 0, 0, 'opacity: 0.1', 2496, 'opacity: 0.1', 1693, 'opacity: 0.1'],
      ['top.sv', 0, 286, 2544, 234, 0, 471, 0, 0, 0, 'opacity: 0.1', 3010, 'opacity: 0.1', 1851, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 889, 523, 167, 0, 0, 2391, 'opacity: 0.1', 1565, 'opacity: 0.1', 2777, 'opacity: 0.1'],
      ['SV Total', 0, 286, 2544, 1123, 523, 638, 0, 0, 2391, 'opacity: 0.1', 4575, 'opacity: 0.1', 4628, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar bank, entry;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For /bank|rd/trans4$data1.
</span><span class="tlx_declarations">logic [7:0] Bank_RD_Trans4_data1_a1 [1:0];

</span><span class="tlx_comments">// For /bank|rd/trans4$data2.
</span><span class="tlx_declarations">logic [3:0] Bank_RD_Trans4_data2_a1 [1:0];

</span><span class="tlx_comments">// For |rd$bank.
</span><span class="tlx_declarations">logic [0:0] RD_bank_a1;

</span><span class="tlx_comments">// For |rd$entry.
</span><span class="tlx_declarations">logic [1:0] RD_entry_a1;

</span><span class="tlx_comments">// For |rd$error.
</span><span class="tlx_declarations">logic RD_error_a1,
      RD_error_a2;

</span><span class="tlx_comments">// For |rd$rd_en.
</span><span class="tlx_declarations">logic [0:0] RD_rd_en_a1;

</span><span class="tlx_comments">// For |rd/mismatch$data1.
</span><span class="tlx_declarations">logic [7:0] RD_Mismatch_data1_a1;

</span><span class="tlx_comments">// For |rd/mismatch$data2.
</span><span class="tlx_declarations">logic [3:0] RD_Mismatch_data2_a1;

</span><span class="tlx_comments">// For |rd/trans2$data1.
</span><span class="tlx_declarations">logic [7:0] RD_Trans2_data1_a1;

</span><span class="tlx_comments">// For |rd/trans2$data2.
</span><span class="tlx_declarations">logic [3:0] RD_Trans2_data2_a1;

</span><span class="tlx_comments">// For |rd/trans3$data1.
</span><span class="tlx_declarations">logic [7:0] RD_Trans3_data1_a1;

</span><span class="tlx_comments">// For |rd/trans3$data2.
</span><span class="tlx_declarations">logic [3:0] RD_Trans3_data2_a1;

</span><span class="tlx_comments">// For |rd/trans4$data1.
</span><span class="tlx_declarations">logic [7:0] RD_Trans4_data1_a1;

</span><span class="tlx_comments">// For |rd/trans4$data2.
</span><span class="tlx_declarations">logic [3:0] RD_Trans4_data2_a1;

</span><span class="tlx_comments">// For |wr$bank.
</span><span class="tlx_declarations">logic [0:0] WR_bank_a0;

</span><span class="tlx_comments">// For |wr$entry.
</span><span class="tlx_declarations">logic [1:0] WR_entry_a0;

</span><span class="tlx_comments">// For |wr$wr_en.
</span><span class="tlx_declarations">logic [0:0] WR_wr_en_a0;

</span><span class="tlx_comments">// For |wr/bank/entry/trans2$data1.
</span><span class="tlx_declarations">logic [7:0] WR_Bank_Entry_Trans2_data1_a0 [1:0][3:0],
            WR_Bank_Entry_Trans2_data1_a1 [1:0][3:0];

</span><span class="tlx_comments">// For |wr/bank/entry/trans2$data2.
</span><span class="tlx_declarations">logic [3:0] WR_Bank_Entry_Trans2_data2_a0 [1:0][3:0],
            WR_Bank_Entry_Trans2_data2_a1 [1:0][3:0];

</span><span class="tlx_comments">// For |wr/bank/entry/trans3$data1.
</span><span class="tlx_declarations">logic [7:0] WR_Bank_Entry_Trans3_data1_a0 [1:0][3:0],
            WR_Bank_Entry_Trans3_data1_a1 [1:0][3:0];

</span><span class="tlx_comments">// For |wr/bank/entry/trans3$data2.
</span><span class="tlx_declarations">logic [3:0] WR_Bank_Entry_Trans3_data2_a0 [1:0][3:0],
            WR_Bank_Entry_Trans3_data2_a1 [1:0][3:0];

</span><span class="tlx_comments">// For |wr/trans$data1.
</span><span class="tlx_declarations">logic [7:0] WR_Trans_data1_a0;

</span><span class="tlx_comments">// For |wr/trans$data2.
</span><span class="tlx_declarations">logic [3:0] WR_Trans_data2_a0;


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">

   //
   // Scope: |rd
   //

      // For $error.
      </span><span class="tlx_staging">always_ff @(posedge clk) RD_error_a2 &lt;= RD_error_a1;



   </span><span class="tlx_comments">//
   // Scope: |wr
   //


      //
      // Scope: /bank[1:0]
      //
      </span><span class="tlx_structure">for (bank = 0; bank &lt;= 1; bank++) begin : L1gen_WR_Bank
</span><span class="tlx_comments">
         //
         // Scope: /entry[3:0]
         //
         </span><span class="tlx_structure">for (entry = 0; entry &lt;= 3; entry++) begin : L2gen_Entry
</span><span class="tlx_comments">
            //
            // Scope: /trans2
            //

               // For $data1.
               </span><span class="tlx_staging">always_ff @(posedge clk) WR_Bank_Entry_Trans2_data1_a1[bank][entry][7:0] &lt;= WR_Bank_Entry_Trans2_data1_a0[bank][entry][7:0];

               </span><span class="tlx_comments">// For $data2.
               </span><span class="tlx_staging">always_ff @(posedge clk) WR_Bank_Entry_Trans2_data2_a1[bank][entry][3:0] &lt;= WR_Bank_Entry_Trans2_data2_a0[bank][entry][3:0];



            </span><span class="tlx_comments">//
            // Scope: /trans3
            //

               // For $data1.
               </span><span class="tlx_staging">always_ff @(posedge clk) WR_Bank_Entry_Trans3_data1_a1[bank][entry][7:0] &lt;= WR_Bank_Entry_Trans3_data1_a0[bank][entry][7:0];

               </span><span class="tlx_comments">// For $data2.
               </span><span class="tlx_staging">always_ff @(posedge clk) WR_Bank_Entry_Trans3_data2_a1[bank][entry][3:0] &lt;= WR_Bank_Entry_Trans3_data2_a0[bank][entry][3:0];


         </span><span class="tlx_structure">end
      end



endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS
</span><span class="tlx_comments">

      //
      // Scope: /bank[1:0]
      //
      </span><span class="tlx_instrumentation">for (bank = 0; bank &lt;= 1; bank++) begin : \/bank 
</span><span class="tlx_comments">
         //
         // Scope: /entry[3:0]
         //
         </span><span class="tlx_instrumentation">for (entry = 0; entry &lt;= 3; entry++) begin : \/entry 
</span><span class="tlx_comments">
            //
            // Scope: /trans4
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans4 
               logic [7:0] \@0$data1 ;
               assign \@0$data1 = L1_Bank[bank].L1_Entry_Trans4_data1_a0[entry];
               logic [3:0] \@0$data2 ;
               assign \@0$data2 = L1_Bank[bank].L1_Entry_Trans4_data2_a0[entry];
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |rd
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|rd 
            logic [3:0] \@1$entry ;
            assign \@1$entry = L1_Bank[bank].L1_RD_entry_a1;
            logic  \@1$rd_en ;
            assign \@1$rd_en = L1_Bank[bank].L1_RD_rd_en_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans4
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans4 
               logic [7:0] \@1$data1 ;
               assign \@1$data1 = Bank_RD_Trans4_data1_a1[bank];
               logic [3:0] \@1$data2 ;
               assign \@1$data2 = Bank_RD_Trans4_data2_a1[bank];
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |wr
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|wr 
            logic [3:0] \@0$entry ;
            assign \@0$entry = L1_Bank[bank].L1_WR_entry_a0;
            logic  \@0$wr_en ;
            assign \@0$wr_en = L1_Bank[bank].L1_WR_wr_en_a0;

            </span><span class="tlx_comments">//
            // Scope: /trans4
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans4 
               logic [7:0] \@0$data1 ;
               assign \@0$data1 = L1_Bank[bank].L1_WR_Trans4_data1_a0;
               logic [3:0] \@0$data2 ;
               assign \@0$data2 = L1_Bank[bank].L1_WR_Trans4_data2_a0;
            end
         end
      end

      </span><span class="tlx_comments">//
      // Scope: |rd
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|rd 
         logic [0:0] \@1$bank ;
         assign \@1$bank = RD_bank_a1;
         logic [1:0] \@1$entry ;
         assign \@1$entry = RD_entry_a1;
         logic  \@1$error ;
         assign \@1$error = RD_error_a1;
         logic [0:0] \@1$rd_en ;
         assign \@1$rd_en = RD_rd_en_a1;

         </span><span class="tlx_comments">//
         // Scope: /mismatch
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/mismatch 
            logic [7:0] \@1$data1 ;
            assign \@1$data1 = RD_Mismatch_data1_a1;
            logic [3:0] \@1$data2 ;
            assign \@1$data2 = RD_Mismatch_data2_a1;
         end

         </span><span class="tlx_comments">//
         // Scope: /trans2
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/trans2 
            logic [7:0] \@1$data1 ;
            assign \@1$data1 = RD_Trans2_data1_a1;
            logic [3:0] \@1$data2 ;
            assign \@1$data2 = RD_Trans2_data2_a1;
         end

         </span><span class="tlx_comments">//
         // Scope: /trans3
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/trans3 
            logic [7:0] \@1$data1 ;
            assign \@1$data1 = RD_Trans3_data1_a1;
            logic [3:0] \@1$data2 ;
            assign \@1$data2 = RD_Trans3_data2_a1;
         end

         </span><span class="tlx_comments">//
         // Scope: /trans4
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/trans4 
            logic [7:0] \@1$data1 ;
            assign \@1$data1 = RD_Trans4_data1_a1;
            logic [3:0] \@1$data2 ;
            assign \@1$data2 = RD_Trans4_data2_a1;
         end
      end

      </span><span class="tlx_comments">//
      // Scope: |wr
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|wr 
         logic [0:0] \@0$bank ;
         assign \@0$bank = WR_bank_a0;
         logic [1:0] \@0$entry ;
         assign \@0$entry = WR_entry_a0;
         logic [0:0] \@0$wr_en ;
         assign \@0$wr_en = WR_wr_en_a0;

         </span><span class="tlx_comments">//
         // Scope: /bank[1:0]
         //
         </span><span class="tlx_instrumentation">for (bank = 0; bank &lt;= 1; bank++) begin : \/bank 
</span><span class="tlx_comments">
            //
            // Scope: /entry[3:0]
            //
            </span><span class="tlx_instrumentation">for (entry = 0; entry &lt;= 3; entry++) begin : \/entry 
</span><span class="tlx_comments">
               //
               // Scope: /trans2
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans2 
                  logic [7:0] \@0$data1 ;
                  assign \@0$data1 = WR_Bank_Entry_Trans2_data1_a0[bank][entry];
                  logic [3:0] \@0$data2 ;
                  assign \@0$data2 = WR_Bank_Entry_Trans2_data2_a0[bank][entry];
               end

               </span><span class="tlx_comments">//
               // Scope: /trans3
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans3 
                  logic [7:0] \@0$data1 ;
                  assign \@0$data1 = WR_Bank_Entry_Trans3_data1_a0[bank][entry];
                  logic [3:0] \@0$data2 ;
                  assign \@0$data2 = WR_Bank_Entry_Trans3_data2_a0[bank][entry];
               end
            end
         end

         </span><span class="tlx_comments">//
         // Scope: /trans
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/trans 
            logic [7:0] \@0$data1 ;
            assign \@0$data1 = WR_Trans_data1_a0;
            logic [3:0] \@0$data2 ;
            assign \@0$data2 = WR_Trans_data2_a0;
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV

</span><span class="tlx_comments">// An example of a two-dimensional array (a banked register file) implemented various ways.
// The RF is written with a transaction (/top|wr/trans$ANY @0) and read into (/top|rd/trans$ANY @1).
// |rd and |wr pipelines are naturally-aligned in the sense that data written to the array from |wr is first
// visible to the stage-aligned |rd transaction.

</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/aa1f91c9e09326e8506bd81d8a077455ddfb0606/arrays.tlv&quot;

</span><span class="tlx_structure">\TLV
   </span><span class="tlx_comments">//$reset = *reset;

   //--------------------------------------------------
   // Stimulus
   //
   
   // Explicit random inputs (same inputs for all approaches).
   
   
   
   </span><span class="tlx_structure">|wr
      </span><span class="tlx_staging">@0
         </span><span class="tlx_comments">// The array hierarchy (to declare ranges)
         </span><span class="tlx_structure">/bank[</span><span class="tlx_logic">1</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            /entry[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
               </span><span class="tlx_comments">// These must be declared before referenced (currently).
               </span><span class="tlx_structure">/trans2
               /trans3
               /trans4
         </span><span class="tlx_logic">$wr_en[0:0] = *RW_rand_vect[(0 + (0)) % 257 +: 1];
         </span><span class="tlx_validity">?$wr_en
            </span><span class="tlx_logic">$bank[0:0] = *RW_rand_vect[(124 + (0)) % 257 +: 1];
            $entry[1:0] = *RW_rand_vect[(248 + (0)) % 257 +: 2];
            </span><span class="tlx_structure">/trans
               </span><span class="tlx_logic">$data1[7:0] = *RW_rand_vect[(115 + (0)) % 257 +: 8];
               $data2[3:0] = *RW_rand_vect[(239 + (0)) % 257 +: 4];
   </span><span class="tlx_structure">|rd
      </span><span class="tlx_staging">@1
         </span><span class="tlx_logic">$rd_en[0:0] = *RW_rand_vect[(106 + (0)) % 257 +: 1];
         </span><span class="tlx_validity">?$rd_en
            </span><span class="tlx_logic">$bank[0:0] = *RW_rand_vect[(230 + (0)) % 257 +: 1];
            $entry[1:0] = *RW_rand_vect[(97 + (0)) % 257 +: 2];
         
   
   </span><span class="tlx_comments">//----------------------------------------------------
   // Approach 1:
   // Utilizing SV module instantiation.
   
   // ... (not implemented)
   
   
   //----------------------------------------------------
   // Approach 2:
   // Utilizing array write.
   
   // Write Pipeline
   </span><span class="tlx_structure">|wr
      </span><span class="tlx_staging">@0
         </span><span class="tlx_comments">// Write the transaction
         // (TLV assignment syntax prohibits assignment outside of it's own scope, but \SV_plus does not.)
         </span><span class="tlx_structure">\SV_plus
            </span><span class="tlx_logic">always_comb
               if ($wr_en)
                  </span><span class="tlx_structure">/bank[</span><span class="tlx_logic">$bank</span><span class="tlx_structure">]/entry[</span><span class="tlx_logic">$entry</span><span class="tlx_structure">]/trans2</span><span class="tlx_logic">$$ANY = </span><span class="tlx_structure">/trans</span><span class="tlx_logic">$ANY;
   
   </span><span class="tlx_comments">// Read Pipeline
   </span><span class="tlx_structure">|rd
      </span><span class="tlx_staging">@1
         </span><span class="tlx_comments">// Read transaction from array
         </span><span class="tlx_validity">?$rd_en
            </span><span class="tlx_structure">/trans2
               </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top|wr/bank[|rd</span><span class="tlx_logic">$bank</span><span class="tlx_structure">]/entry[|rd</span><span class="tlx_logic">$entry</span><span class="tlx_structure">]/trans2</span><span class="tlx_logic">&lt;&gt;0$ANY;
               `BOGUS_USE($data1 $data2)  </span><span class="tlx_comments">// Pull transaction through.

   
   //----------------------------------------------------
   // Approach 3:
   // Write each entry every cycle (preserving value w/ recirculation).
   // Most-native TLV, but poor simulation performance today.
   
   // Write Pipeline
   </span><span class="tlx_structure">|wr
      </span><span class="tlx_staging">@0
         </span><span class="tlx_comments">// The array hierarchy
         </span><span class="tlx_structure">/bank[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
            /entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
               /trans3
                  </span><span class="tlx_logic">$ANY = (</span><span class="tlx_structure">|wr</span><span class="tlx_logic">$wr_en &amp;&amp; (</span><span class="tlx_structure">|wr</span><span class="tlx_logic">$bank == #bank) &amp;&amp; (</span><span class="tlx_structure">|wr</span><span class="tlx_logic">$entry == #entry))
                              ? </span><span class="tlx_structure">|wr/trans</span><span class="tlx_logic">$ANY :
                                &gt;&gt;1$ANY;
   
   </span><span class="tlx_comments">// Read Pipeline
   </span><span class="tlx_structure">|rd
      </span><span class="tlx_staging">@1
         </span><span class="tlx_comments">// Read
         </span><span class="tlx_validity">?$rd_en
            </span><span class="tlx_structure">/trans3
               </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top|wr/bank[|rd</span><span class="tlx_logic">$bank</span><span class="tlx_structure">]/entry[|rd</span><span class="tlx_logic">$entry</span><span class="tlx_structure">]/trans3</span><span class="tlx_logic">&lt;&gt;0$ANY;
               `BOGUS_USE($data1 $data2)  </span><span class="tlx_comments">// Pull transaction through.

   //----------------------------------------------------
   // Approach 4:
   // Utilizing macro, per bank.

   </span><span class="tlx_structure">/bank[</span><span class="tlx_logic">1</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
      </span><span class="tlx_comments">// Copy of /top|wr and /top|rd per bank.
      </span><span class="tlx_structure">|wr
         </span><span class="tlx_staging">@0
            </span><span class="tlx_logic">$wr_en = </span><span class="tlx_structure">/top|wr</span><span class="tlx_logic">$wr_en &amp;&amp; </span><span class="tlx_structure">/top|wr</span><span class="tlx_logic">$bank == #bank;
            </span><span class="tlx_validity">?$wr_en
               </span><span class="tlx_logic">$entry[3:0] = </span><span class="tlx_structure">/top|wr</span><span class="tlx_logic">$entry;
               </span><span class="tlx_structure">/trans4
                  </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top|wr/trans</span><span class="tlx_logic">$ANY;
      </span><span class="tlx_structure">|rd
         </span><span class="tlx_staging">@1
            </span><span class="tlx_logic">$rd_en = </span><span class="tlx_structure">/top|rd</span><span class="tlx_logic">$rd_en &amp;&amp; </span><span class="tlx_structure">/top|rd</span><span class="tlx_logic">$bank == #bank;
            </span><span class="tlx_validity">?$rd_en
               </span><span class="tlx_logic">$entry[3:0] = </span><span class="tlx_structure">/top|rd</span><span class="tlx_logic">$entry;
      </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/aa1f91c9e09326e8506bd81d8a077455ddfb0606/arrays.tlv 33   </span><span class="tlx_comments">// Instantiated from top.tlv, 121 as: m4+array1r1w(/bank, /entry, |wr, @0, $wr_en, $entry, |rd, @1, $rd_en, $entry, $ANY, /trans4)
         // Write Pipeline
         // The array entries hierarchy (needs a definition to define range, and currently, /trans4 declaration required before reference).
         </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            /trans4
               
         </span><span class="tlx_comments">// Write transaction to cache
         // (TLV assignment syntax prohibits assignment outside of it's own scope, but \SV_plus does not.)
         </span><span class="tlx_structure">\SV_plus
            </span><span class="tlx_logic">always_comb
               if (</span><span class="tlx_structure">|wr</span><span class="tlx_logic">&gt;&gt;0$wr_en)
                  </span><span class="tlx_structure">/entry[|wr</span><span class="tlx_logic">&gt;&gt;0$entry</span><span class="tlx_structure">]/trans4</span><span class="tlx_logic">$$ANY = </span><span class="tlx_structure">|wr/trans4</span><span class="tlx_logic">&gt;&gt;0$ANY;
         
         </span><span class="tlx_comments">// Read Pipeline
         </span><span class="tlx_structure">|rd
            </span><span class="tlx_staging">@1
               </span><span class="tlx_comments">// Read transaction from cache.
               </span><span class="tlx_validity">?$rd_en
                  </span><span class="tlx_structure">/trans4
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/bank/entry[|rd</span><span class="tlx_logic">$entry</span><span class="tlx_structure">]/trans4</span><span class="tlx_logic">&gt;&gt;-1$ANY;
      </span><span class="tlx_structure">\end_source
   </span><span class="tlx_comments">// Pull read out of the bank.
   </span><span class="tlx_structure">|rd
      </span><span class="tlx_staging">@1
         </span><span class="tlx_validity">?$rd_en
            </span><span class="tlx_structure">/trans4
               </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top/bank[|rd</span><span class="tlx_logic">$bank</span><span class="tlx_structure">]|rd/trans4</span><span class="tlx_logic">$ANY;


   </span><span class="tlx_comments">//-----------------------------------------------------
   // Checking
   
   </span><span class="tlx_structure">|rd
      </span><span class="tlx_staging">@1
         </span><span class="tlx_validity">?$rd_en
            </span><span class="tlx_structure">/mismatch
               </span><span class="tlx_comments">// A vector pulled through $ANY, with bits asserted for any mismatches between read data for
               // different implementations.
               </span><span class="tlx_logic">$ANY = (</span><span class="tlx_structure">|rd/trans2</span><span class="tlx_logic">$ANY ^ </span><span class="tlx_structure">|rd/trans3</span><span class="tlx_logic">$ANY) |
                      (</span><span class="tlx_structure">|rd/trans2</span><span class="tlx_logic">$ANY ^ </span><span class="tlx_structure">|rd/trans4</span><span class="tlx_logic">$ANY);
         </span><span class="tlx_comments">// $error if any mismatching data was read.
         </span><span class="tlx_logic">$error = $rd_en &amp;&amp;
                  (| </span><span class="tlx_structure">/mismatch</span><span class="tlx_logic">$data1 ||
                   | </span><span class="tlx_structure">/mismatch</span><span class="tlx_logic">$data2);
      
      
   </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">*passed = *cyc_cnt &gt; 50;
   *failed = *cyc_cnt &gt; 4 &amp;&amp; </span><span class="tlx_structure">|rd</span><span class="tlx_logic">&gt;&gt;2$error;

</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV

// An example of a two-dimensional array (a banked register file) implemented various ways.
// The RF is written with a transaction (/top|wr/trans$ANY @0) and read into (/top|rd/trans$ANY @1).
// |rd and |wr pipelines are naturally-aligned in the sense that data written to the array from |wr is first
// visible to the stage-aligned |rd transaction.

</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/aa1f91c9e09326e8506bd81d8a077455ddfb0606/arrays.tlv&quot;

</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   //$reset = *reset;

   //--------------------------------------------------
   // Stimulus
   //
   
   // Explicit random inputs (same inputs for all approaches).
   
   
   
   //_|wr
      //_@0
         // The array hierarchy (to declare ranges)
         </span><span class="tlx_structure">for (bank = 0; bank &lt;= 1; bank++) begin : L1_WR_Bank </span><span class="tlx_comments">//_/bank
            </span><span class="tlx_structure">for (entry = 0; entry &lt;= 3; entry++) begin : L2_Entry </span><span class="tlx_comments">//_/entry
               // These must be declared before referenced (currently).
               //_/trans2
               //_/trans3
               </span><span class="tlx_structure">end end </span><span class="tlx_comments">//_/trans4
         </span><span class="tlx_logic">assign WR_wr_en_a0[0:0] = RW_rand_vect[(0 + (0)) % 257 +: 1];
         </span><span class="tlx_comments">//_?$wr_en
            </span><span class="tlx_logic">assign WR_bank_a0[0:0] = RW_rand_vect[(124 + (0)) % 257 +: 1];
            assign WR_entry_a0[1:0] = RW_rand_vect[(248 + (0)) % 257 +: 2];
            </span><span class="tlx_comments">//_/trans
               </span><span class="tlx_logic">assign WR_Trans_data1_a0[7:0] = RW_rand_vect[(115 + (0)) % 257 +: 8];
               assign WR_Trans_data2_a0[3:0] = RW_rand_vect[(239 + (0)) % 257 +: 4];
   </span><span class="tlx_comments">//_|rd
      //_@1
         </span><span class="tlx_logic">assign RD_rd_en_a1[0:0] = RW_rand_vect[(106 + (0)) % 257 +: 1];
         </span><span class="tlx_comments">//_?$rd_en
            </span><span class="tlx_logic">assign RD_bank_a1[0:0] = RW_rand_vect[(230 + (0)) % 257 +: 1];
            assign RD_entry_a1[1:0] = RW_rand_vect[(97 + (0)) % 257 +: 2];
         
   
   </span><span class="tlx_comments">//----------------------------------------------------
   // Approach 1:
   // Utilizing SV module instantiation.
   
   // ... (not implemented)
   
   
   //----------------------------------------------------
   // Approach 2:
   // Utilizing array write.
   
   // Write Pipeline
   //_|wr
      //_@0
         // Write the transaction
         // (TLV assignment syntax prohibits assignment outside of it's own scope, but \SV_plus does not.)
         /*SV_plus*/
            </span><span class="tlx_logic">always_comb
               if (WR_wr_en_a0)
                  {WR_Bank_Entry_Trans2_data1_a0[WR_bank_a0][WR_entry_a0][7:0], WR_Bank_Entry_Trans2_data2_a0[WR_bank_a0][WR_entry_a0][3:0]} = {WR_Trans_data1_a0, WR_Trans_data2_a0};
   
   </span><span class="tlx_comments">// Read Pipeline
   //_|rd
      //_@1
         // Read transaction from array
         //_?$rd_en
            //_/trans2
               </span><span class="tlx_logic">assign {RD_Trans2_data1_a1[7:0], RD_Trans2_data2_a1[3:0]} = {WR_Bank_Entry_Trans2_data1_a1[RD_bank_a1][RD_entry_a1], WR_Bank_Entry_Trans2_data2_a1[RD_bank_a1][RD_entry_a1]};
               `BOGUS_USE(RD_Trans2_data1_a1 RD_Trans2_data2_a1)  </span><span class="tlx_comments">// Pull transaction through.

   
   //----------------------------------------------------
   // Approach 3:
   // Write each entry every cycle (preserving value w/ recirculation).
   // Most-native TLV, but poor simulation performance today.
   
   // Write Pipeline
   //_|wr
      //_@0
         // The array hierarchy
         </span><span class="tlx_structure">for (bank = 0; bank &lt;= 1; bank++) begin : L1b_WR_Bank </span><span class="tlx_comments">//_/bank
            </span><span class="tlx_structure">for (entry = 0; entry &lt;= 3; entry++) begin : L2b_Entry </span><span class="tlx_comments">//_/entry
               //_/trans3
                  </span><span class="tlx_logic">assign {WR_Bank_Entry_Trans3_data1_a0[bank][entry][7:0], WR_Bank_Entry_Trans3_data2_a0[bank][entry][3:0]} = (WR_wr_en_a0 &amp;&amp; (WR_bank_a0 == bank) &amp;&amp; (WR_entry_a0 == entry))
                              ? {WR_Trans_data1_a0[7:0], WR_Trans_data2_a0[3:0]} :
                                {WR_Bank_Entry_Trans3_data1_a1[bank][entry][7:0], WR_Bank_Entry_Trans3_data2_a1[bank][entry][3:0]}; </span><span class="tlx_structure">end end
   
   </span><span class="tlx_comments">// Read Pipeline
   //_|rd
      //_@1
         // Read
         //_?$rd_en
            //_/trans3
               </span><span class="tlx_logic">assign {RD_Trans3_data1_a1[7:0], RD_Trans3_data2_a1[3:0]} = {WR_Bank_Entry_Trans3_data1_a1[RD_bank_a1][RD_entry_a1][7:0], WR_Bank_Entry_Trans3_data2_a1[RD_bank_a1][RD_entry_a1][3:0]};
               `BOGUS_USE(RD_Trans3_data1_a1 RD_Trans3_data2_a1)  </span><span class="tlx_comments">// Pull transaction through.

   //----------------------------------------------------
   // Approach 4:
   // Utilizing macro, per bank.

   </span><span class="tlx_structure">for (bank = 0; bank &lt;= 1; bank++) begin : L1_Bank </span><span class="tlx_declarations">logic [7:0] L1_Entry_Trans4_data1_a0 [3:0]; logic [3:0] L1_Entry_Trans4_data2_a0 [3:0]; logic [3:0] L1_RD_entry_a1; logic L1_RD_rd_en_a1; logic [3:0] L1_WR_entry_a0; logic L1_WR_wr_en_a0; logic [7:0] L1_WR_Trans4_data1_a0; logic [3:0] L1_WR_Trans4_data2_a0; </span><span class="tlx_comments">//_/bank
      // Copy of /top|wr and /top|rd per bank.
      //_|wr
         //_@0
            </span><span class="tlx_logic">assign L1_WR_wr_en_a0 = WR_wr_en_a0 &amp;&amp; WR_bank_a0 == bank;
            </span><span class="tlx_comments">//_?$wr_en
               </span><span class="tlx_logic">assign L1_WR_entry_a0[3:0] = WR_entry_a0;
               </span><span class="tlx_comments">//_/trans4
                  </span><span class="tlx_logic">assign {L1_WR_Trans4_data1_a0[7:0], L1_WR_Trans4_data2_a0[3:0]} = {WR_Trans_data1_a0[7:0], WR_Trans_data2_a0[3:0]};
      </span><span class="tlx_comments">//_|rd
         //_@1
            </span><span class="tlx_logic">assign L1_RD_rd_en_a1 = RD_rd_en_a1 &amp;&amp; RD_bank_a1 == bank;
            </span><span class="tlx_comments">//_?$rd_en
               </span><span class="tlx_logic">assign L1_RD_entry_a1[3:0] = RD_entry_a1;
      </span><span class="tlx_structure">`line 34 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/aa1f91c9e09326e8506bd81d8a077455ddfb0606/arrays.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 121 as: m4+array1r1w(/bank, /entry, |wr, @0, $wr_en, $entry, |rd, @1, $rd_en, $entry, $ANY, /trans4)
         // Write Pipeline
         // The array entries hierarchy (needs a definition to define range, and currently, /trans4 declaration required before reference).
         </span><span class="tlx_structure">for (entry = 0; entry &lt;= 3; entry++) begin : L2_Entry </span><span class="tlx_comments">//_/entry
            </span><span class="tlx_structure">end </span><span class="tlx_comments">//_/trans4
               
         // Write transaction to cache
         // (TLV assignment syntax prohibits assignment outside of it's own scope, but \SV_plus does not.)
         /*SV_plus*/
            </span><span class="tlx_logic">always_comb
               if (L1_WR_wr_en_a0)
                  {L1_Entry_Trans4_data1_a0[L1_WR_entry_a0][7:0], L1_Entry_Trans4_data2_a0[L1_WR_entry_a0][3:0]} = {L1_WR_Trans4_data1_a0[7:0], L1_WR_Trans4_data2_a0[3:0]};
         
         </span><span class="tlx_comments">// Read Pipeline
         //_|rd
            //_@1
               // Read transaction from cache.
               //_?$rd_en
                  //_/trans4
                     </span><span class="tlx_logic">assign {Bank_RD_Trans4_data1_a1[bank][7:0], Bank_RD_Trans4_data2_a1[bank][3:0]} = {L1_Entry_Trans4_data1_a0[L1_RD_entry_a1][7:0], L1_Entry_Trans4_data2_a0[L1_RD_entry_a1][3:0]};
      </span><span class="tlx_structure">end </span><span class="tlx_comments">//_\end_source
      </span><span class="tlx_structure">`line 122 &quot;top.tlv&quot; 2
   </span><span class="tlx_comments">// Pull read out of the bank.
   //_|rd
      //_@1
         //_?$rd_en
            //_/trans4
               </span><span class="tlx_logic">assign {RD_Trans4_data1_a1[7:0], RD_Trans4_data2_a1[3:0]} = {Bank_RD_Trans4_data1_a1[RD_bank_a1][7:0], Bank_RD_Trans4_data2_a1[RD_bank_a1][3:0]};


   </span><span class="tlx_comments">//-----------------------------------------------------
   // Checking
   
   //_|rd
      //_@1
         //_?$rd_en
            //_/mismatch
               // A vector pulled through $ANY, with bits asserted for any mismatches between read data for
               // different implementations.
               </span><span class="tlx_logic">assign {RD_Mismatch_data1_a1[7:0], RD_Mismatch_data2_a1[3:0]} = ({RD_Trans2_data1_a1, RD_Trans2_data2_a1} ^ {RD_Trans3_data1_a1[7:0], RD_Trans3_data2_a1[3:0]}) |
                      ({RD_Trans2_data1_a1[7:0], RD_Trans2_data2_a1[3:0]} ^ {RD_Trans4_data1_a1[7:0], RD_Trans4_data2_a1[3:0]});
         </span><span class="tlx_comments">// $error if any mismatching data was read.
         </span><span class="tlx_logic">assign RD_error_a1 = RD_rd_en_a1 &amp;&amp;
                  (| RD_Mismatch_data1_a1 ||
                   | RD_Mismatch_data2_a1);
      
      
   </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">assign passed = cyc_cnt &gt; 50;
   assign failed = cyc_cnt &gt; 4 &amp;&amp; RD_error_a2; </span><span class="tlx_structure">endgenerate

</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

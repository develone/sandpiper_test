`line 2 "top.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
`include "sp_default.vh" //_\SV

// An example of a two-dimensional array (a banked register file) implemented various ways.
// The RF is written with a transaction (/top|wr/trans$ANY @0) and read into (/top|rd/trans$ANY @1).
// |rd and |wr pipelines are naturally-aligned in the sense that data written to the array from |wr is first
// visible to the stage-aligned |rd transaction.

module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
// Included URL: "https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/aa1f91c9e09326e8506bd81d8a077455ddfb0606/arrays.tlv"

`include "top_gen.sv" //_\TLV
   //$reset = *reset;

   //--------------------------------------------------
   // Stimulus
   //
   
   // Explicit random inputs (same inputs for all approaches).
   
   
   
   //_|wr
      //_@0
         // The array hierarchy (to declare ranges)
         for (bank = 0; bank <= 1; bank++) begin : L1_WR_Bank //_/bank
            for (entry = 0; entry <= 3; entry++) begin : L2_Entry //_/entry
               // These must be declared before referenced (currently).
               //_/trans2
               //_/trans3
               end end //_/trans4
         assign WR_wr_en_a0[0:0] = RW_rand_vect[(0 + (0)) % 257 +: 1];
         //_?$wr_en
            assign WR_bank_a0[0:0] = RW_rand_vect[(124 + (0)) % 257 +: 1];
            assign WR_entry_a0[1:0] = RW_rand_vect[(248 + (0)) % 257 +: 2];
            //_/trans
               assign WR_Trans_data1_a0[7:0] = RW_rand_vect[(115 + (0)) % 257 +: 8];
               assign WR_Trans_data2_a0[3:0] = RW_rand_vect[(239 + (0)) % 257 +: 4];
   //_|rd
      //_@1
         assign RD_rd_en_a1[0:0] = RW_rand_vect[(106 + (0)) % 257 +: 1];
         //_?$rd_en
            assign RD_bank_a1[0:0] = RW_rand_vect[(230 + (0)) % 257 +: 1];
            assign RD_entry_a1[1:0] = RW_rand_vect[(97 + (0)) % 257 +: 2];
         
   
   //----------------------------------------------------
   // Approach 1:
   // Utilizing SV module instantiation.
   
   // ... (not implemented)
   
   
   //----------------------------------------------------
   // Approach 2:
   // Utilizing array write.
   
   // Write Pipeline
   //_|wr
      //_@0
         // Write the transaction
         // (TLV assignment syntax prohibits assignment outside of it's own scope, but \SV_plus does not.)
         /*SV_plus*/
            always_comb
               if (WR_wr_en_a0)
                  {WR_Bank_Entry_Trans2_data1_a0[WR_bank_a0][WR_entry_a0][7:0], WR_Bank_Entry_Trans2_data2_a0[WR_bank_a0][WR_entry_a0][3:0]} = {WR_Trans_data1_a0, WR_Trans_data2_a0};
   
   // Read Pipeline
   //_|rd
      //_@1
         // Read transaction from array
         //_?$rd_en
            //_/trans2
               assign {RD_Trans2_data1_a1[7:0], RD_Trans2_data2_a1[3:0]} = {WR_Bank_Entry_Trans2_data1_a1[RD_bank_a1][RD_entry_a1], WR_Bank_Entry_Trans2_data2_a1[RD_bank_a1][RD_entry_a1]};
               `BOGUS_USE(RD_Trans2_data1_a1 RD_Trans2_data2_a1)  // Pull transaction through.

   
   //----------------------------------------------------
   // Approach 3:
   // Write each entry every cycle (preserving value w/ recirculation).
   // Most-native TLV, but poor simulation performance today.
   
   // Write Pipeline
   //_|wr
      //_@0
         // The array hierarchy
         for (bank = 0; bank <= 1; bank++) begin : L1b_WR_Bank //_/bank
            for (entry = 0; entry <= 3; entry++) begin : L2b_Entry //_/entry
               //_/trans3
                  assign {WR_Bank_Entry_Trans3_data1_a0[bank][entry][7:0], WR_Bank_Entry_Trans3_data2_a0[bank][entry][3:0]} = (WR_wr_en_a0 && (WR_bank_a0 == bank) && (WR_entry_a0 == entry))
                              ? {WR_Trans_data1_a0[7:0], WR_Trans_data2_a0[3:0]} :
                                {WR_Bank_Entry_Trans3_data1_a1[bank][entry][7:0], WR_Bank_Entry_Trans3_data2_a1[bank][entry][3:0]}; end end
   
   // Read Pipeline
   //_|rd
      //_@1
         // Read
         //_?$rd_en
            //_/trans3
               assign {RD_Trans3_data1_a1[7:0], RD_Trans3_data2_a1[3:0]} = {WR_Bank_Entry_Trans3_data1_a1[RD_bank_a1][RD_entry_a1][7:0], WR_Bank_Entry_Trans3_data2_a1[RD_bank_a1][RD_entry_a1][3:0]};
               `BOGUS_USE(RD_Trans3_data1_a1 RD_Trans3_data2_a1)  // Pull transaction through.

   //----------------------------------------------------
   // Approach 4:
   // Utilizing macro, per bank.

   for (bank = 0; bank <= 1; bank++) begin : L1_Bank logic [7:0] L1_Entry_Trans4_data1_a0 [3:0]; logic [3:0] L1_Entry_Trans4_data2_a0 [3:0]; logic [3:0] L1_RD_entry_a1; logic L1_RD_rd_en_a1; logic [3:0] L1_WR_entry_a0; logic L1_WR_wr_en_a0; logic [7:0] L1_WR_Trans4_data1_a0; logic [3:0] L1_WR_Trans4_data2_a0; //_/bank
      // Copy of /top|wr and /top|rd per bank.
      //_|wr
         //_@0
            assign L1_WR_wr_en_a0 = WR_wr_en_a0 && WR_bank_a0 == bank;
            //_?$wr_en
               assign L1_WR_entry_a0[3:0] = WR_entry_a0;
               //_/trans4
                  assign {L1_WR_Trans4_data1_a0[7:0], L1_WR_Trans4_data2_a0[3:0]} = {WR_Trans_data1_a0[7:0], WR_Trans_data2_a0[3:0]};
      //_|rd
         //_@1
            assign L1_RD_rd_en_a1 = RD_rd_en_a1 && RD_bank_a1 == bank;
            //_?$rd_en
               assign L1_RD_entry_a1[3:0] = RD_entry_a1;
      `line 34 "/raw.githubusercontent.com/stevehoover/tlvflowlib/aa1f91c9e09326e8506bd81d8a077455ddfb0606/arrays.tlv" 1   // Instantiated from top.tlv, 121 as: m4+array1r1w(/bank, /entry, |wr, @0, $wr_en, $entry, |rd, @1, $rd_en, $entry, $ANY, /trans4)
         // Write Pipeline
         // The array entries hierarchy (needs a definition to define range, and currently, /trans4 declaration required before reference).
         for (entry = 0; entry <= 3; entry++) begin : L2_Entry //_/entry
            end //_/trans4
               
         // Write transaction to cache
         // (TLV assignment syntax prohibits assignment outside of it's own scope, but \SV_plus does not.)
         /*SV_plus*/
            always_comb
               if (L1_WR_wr_en_a0)
                  {L1_Entry_Trans4_data1_a0[L1_WR_entry_a0][7:0], L1_Entry_Trans4_data2_a0[L1_WR_entry_a0][3:0]} = {L1_WR_Trans4_data1_a0[7:0], L1_WR_Trans4_data2_a0[3:0]};
         
         // Read Pipeline
         //_|rd
            //_@1
               // Read transaction from cache.
               //_?$rd_en
                  //_/trans4
                     assign {Bank_RD_Trans4_data1_a1[bank][7:0], Bank_RD_Trans4_data2_a1[bank][3:0]} = {L1_Entry_Trans4_data1_a0[L1_RD_entry_a1][7:0], L1_Entry_Trans4_data2_a0[L1_RD_entry_a1][3:0]};
      end //_\end_source
      `line 122 "top.tlv" 2
   // Pull read out of the bank.
   //_|rd
      //_@1
         //_?$rd_en
            //_/trans4
               assign {RD_Trans4_data1_a1[7:0], RD_Trans4_data2_a1[3:0]} = {Bank_RD_Trans4_data1_a1[RD_bank_a1][7:0], Bank_RD_Trans4_data2_a1[RD_bank_a1][3:0]};


   //-----------------------------------------------------
   // Checking
   
   //_|rd
      //_@1
         //_?$rd_en
            //_/mismatch
               // A vector pulled through $ANY, with bits asserted for any mismatches between read data for
               // different implementations.
               assign {RD_Mismatch_data1_a1[7:0], RD_Mismatch_data2_a1[3:0]} = ({RD_Trans2_data1_a1, RD_Trans2_data2_a1} ^ {RD_Trans3_data1_a1[7:0], RD_Trans3_data2_a1[3:0]}) |
                      ({RD_Trans2_data1_a1[7:0], RD_Trans2_data2_a1[3:0]} ^ {RD_Trans4_data1_a1[7:0], RD_Trans4_data2_a1[3:0]});
         // $error if any mismatching data was read.
         assign RD_error_a1 = RD_rd_en_a1 &&
                  (| RD_Mismatch_data1_a1 ||
                   | RD_Mismatch_data2_a1);
      
      
   // Assert these to end simulation (before Makerchip cycle limit).
   assign passed = cyc_cnt > 50;
   assign failed = cyc_cnt > 4 && RD_error_a2; endgenerate

//_\SV
   endmodule

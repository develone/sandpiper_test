`line 2 "top.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
`include "sp_default.vh" //_\SV
// -----------------------------------------------------------------------------
// Copyright (c) 2017, Redwood EDA
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Redwood EDA nor the names of its contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------


// A dirt-simple CPU for educational purposes.

// What's interesting about this CPU?
//   o It's super small.
//   o It's easy to play with and learn from.
//   o Instructions are short, kind-of-readable strings, so no assembler is needed.
//     They would map directly to a denser (~17-bit) encoding if desired.
//   o The only instruction formats are op, load, and store.
//   o Branch/Jump: There is no special format for control-flow instructions. Any
//     instruction can write the PC (relative or absolute). A conditional branch
//     will typically utilize a condition operation that provides a (relative) branch
//     target or zero. The condition can be predicted as per traditional branch
//     prediction (though there is no branch predictor in this example as it stands).

// Machine Arch:
//   o Single stage "pipeline".
//   o 8 registers.
//   o A word is 12 bits wide.
//   o Operators operate on and produce words as signed or unsigned values and
//     booleans (all-zero/one)
//
// ISA:
//
// Instructions are 5-character strings: "D=1o2"
//
// =: Appears in every instruction (just for readability).
// D, 2, 1: "a" - "h" for register values;
//          "0" - "7" for immediate constants (sources, or "0" for unused dest);
//          "P" for absolute dest PC (jump);
//          "p" for relative dest PC (branch), PC = PC + 1 + result(signed).
//
// o: operator
//   Op: (D = 1 o 2) (Eg: "c=a+b"):
//     +, -, *, /: Arithmetic. *, / are unsigned.
//     =, !, <, >, [, ]: Compare (D = (1 o r) ? all-1s : 0) (] is >=, [ is <=)
//        (On booleans these are XNOR, XOR, !1&2, 1&!2, !1|2, 1|!2)
//     &, |: Bitwise
//        (Can be used on booleans as well as vectors.)
//     (There are no operators for NAND and NOR and unary !.)
//     ~: Extended constant (D = {1[2:0], 2[2:0]})
//     ,: Combine (D = {1[11:6], 2[5:0]})
//     ?: Conditional (D = 2 ? `0 : 1)
//   Load (Eg: "c=a{b") (D = [1 + 2] (typically 1 would be an immediate offset):
//     {: Load
//   Store (Eg: "0=a}b") ([2] = 1):
//     }: Store
//
// A full-width immediate load sequence, to load octal 2017 is:
//   a=2~0
//   b=1~7
//   a=a,b

// A typical local conditional branch sequence is:
//   a=0-6  // offset
//   c=c-1  // decrementing loop counter
//   p=a?c  // branch by a (to PC+1-6) if c is non-negative (MSB==0)


module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
/* verilator lint_on WIDTH */  // Let's be strict about bit widths.

   
   logic [39:0] instrs [0:12-1];


   // =======
   // Program
   // =======

   // Add 1,2,3,...,10 (in that order).
   // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
   //
   // Regs:
   // b: cnt
   // c: ten
   // d: out
   // e: tmp
   // f: offset
   // g: store addr

   assign instrs = '{
      "g=0~0", //     store_addr = 0
      "b=0~1", //     cnt = 1
      "c=1~2", //     ten = 10
      "d=0~0", //     out = 0
      "f=0-6", //     offset = -6
      "d=d+b", //  -> out += cnt
      "0=d}g", //     store out at store_addr
      "b=b+1", //     cnt ++
      "g=g+1", //     store_addr++
      "e=c-b", //     tmp = 10 - cnt
      "p=f?e", //  ^- branch back if tmp >= 0
      "P=0-1"  //     TERMINATE by jumping to -1
   };


`include "top_gen.sv" //_\TLV
   
   // =======
   // The CPU
   // =======
   
   assign L0_reset_a0 = reset;

   //_|fetch
      //_@0
         
         //_/instr
            assign FETCH_Instr_reset_a0 = L0_reset_a0;
            
            //?$fetch  // We'll need this once there are invalid cycles.

            // =====
            // Fetch
            // =====

            assign FETCH_Instr_raw_a0[39:0] = instrs[FETCH_Instr_Pc_a0[3:0]];

            // ======
            // DECODE
            // ======

            // Characters
            assign FETCH_Instr_dest_char_a0[7:0] = FETCH_Instr_raw_a0[39:32];
            for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_Src logic [7:0] L1_char_a0; //_/src
               assign L1_char_a0[7:0] = (src == 1) ? FETCH_Instr_raw_a0[23:16] : FETCH_Instr_raw_a0[7:0]; end
            assign FETCH_Instr_op_char_a0[7:0] = FETCH_Instr_raw_a0[15:8];

            // Dest
            assign FETCH_Instr_dest_is_reg_a0 = FETCH_Instr_dest_char_a0 >= "a" && FETCH_Instr_dest_char_a0 <= "h";
            assign FETCH_Instr_dest_tmp_a0[7:0] = FETCH_Instr_dest_char_a0 - "a";
            assign FETCH_Instr_dest_reg_a0[2:0] = FETCH_Instr_dest_tmp_a0[2:0];
            assign FETCH_Instr_jump_a0 = FETCH_Instr_dest_char_a0 == "P";
            assign FETCH_Instr_branch_a0 = FETCH_Instr_dest_char_a0 == "p";
            assign FETCH_Instr_no_dest_a0 = FETCH_Instr_dest_char_a0 == "0";
            assign FETCH_Instr_write_pc_a0 = FETCH_Instr_jump_a0 || FETCH_Instr_branch_a0;
            assign FETCH_Instr_dest_valid_a0 = FETCH_Instr_write_pc_a0 || FETCH_Instr_dest_is_reg_a0;
            assign FETCH_Instr_illegal_dest_a0 = !(FETCH_Instr_dest_is_reg_a0 || 
                              FETCH_Instr_branch_a0 || FETCH_Instr_jump_a0 || FETCH_Instr_no_dest_a0);

            for (src = 1; src <= 2; src++) begin : L1b_FETCH_Instr_Src logic [7:0] L1_imm_tmp_a0; logic [2:0] L1_imm_value_a0; logic L1_is_imm_a0; logic L1_is_reg_a0; logic [2:0] L1_reg_a0; logic [7:0] L1_reg_tmp_a0; //_/src
               // Src1
               assign L1_is_reg_a0 = L1_FETCH_Instr_Src[src].L1_char_a0 >= "a" && L1_FETCH_Instr_Src[src].L1_char_a0 <= "h";
               assign L1_reg_tmp_a0[7:0] = L1_FETCH_Instr_Src[src].L1_char_a0 - "a";
               assign L1_reg_a0[2:0] = L1_reg_tmp_a0[2:0];
               assign L1_is_imm_a0 = L1_FETCH_Instr_Src[src].L1_char_a0 >= "0" && L1_FETCH_Instr_Src[src].L1_char_a0 < "8";
               assign L1_imm_tmp_a0[7:0] = L1_FETCH_Instr_Src[src].L1_char_a0 - "0";
               assign L1_imm_value_a0[2:0] = L1_imm_tmp_a0[2:0];
               assign FETCH_Instr_Src_illegal_a0[src] = !(L1_is_reg_a0 || L1_is_imm_a0); end

            // Opcode:
            //_/op
               assign FETCH_Instr_Op_char_a0[7:0] = FETCH_Instr_op_char_a0;
               // Arithmetic
               assign FETCH_Instr_Op_add_a0 = FETCH_Instr_Op_char_a0 == "+";
               assign FETCH_Instr_Op_sub_a0 = FETCH_Instr_Op_char_a0 == "-";
               assign FETCH_Instr_Op_mul_a0 = FETCH_Instr_Op_char_a0 == "*";
               assign FETCH_Instr_Op_div_a0 = FETCH_Instr_Op_char_a0 == "/";
               // Compare and bool (w/ 1 bit rslt)
               assign FETCH_Instr_Op_eq_a0 = FETCH_Instr_Op_char_a0 == "=";
               assign FETCH_Instr_Op_ne_a0 = FETCH_Instr_Op_char_a0 == "!";
               assign FETCH_Instr_Op_lt_a0 = FETCH_Instr_Op_char_a0 == "<";
               assign FETCH_Instr_Op_gt_a0 = FETCH_Instr_Op_char_a0 == ">";
               assign FETCH_Instr_Op_le_a0 = FETCH_Instr_Op_char_a0 == "[";
               assign FETCH_Instr_Op_ge_a0 = FETCH_Instr_Op_char_a0 == "]";
               assign FETCH_Instr_Op_and_a0 = FETCH_Instr_Op_char_a0 == "&";
               assign FETCH_Instr_Op_or_a0 = FETCH_Instr_Op_char_a0 == "|";
               // Wide Immediate
               assign FETCH_Instr_Op_wide_imm_a0 = FETCH_Instr_Op_char_a0 == "~";
               assign FETCH_Instr_Op_combine_a0 = FETCH_Instr_Op_char_a0 == ",";
               // Conditional
               assign FETCH_Instr_Op_conditional_a0 = FETCH_Instr_Op_char_a0 == "?";
               // Memory
               assign FETCH_Instr_Op_ld_a0 = FETCH_Instr_Op_char_a0 == "{";
               assign FETCH_Instr_Op_st_a0 = FETCH_Instr_Op_char_a0 == "}";
               // Opcode classes:
               assign FETCH_Instr_Op_arith_a0 = FETCH_Instr_Op_add_a0 || FETCH_Instr_Op_sub_a0 || FETCH_Instr_Op_mul_a0 || FETCH_Instr_Op_div_a0;
               assign FETCH_Instr_Op_compare_a0 = FETCH_Instr_Op_eq_a0 || FETCH_Instr_Op_ne_a0 || FETCH_Instr_Op_lt_a0 || FETCH_Instr_Op_gt_a0 || FETCH_Instr_Op_le_a0 || FETCH_Instr_Op_ge_a0;
               assign FETCH_Instr_Op_bitwise_a0 = FETCH_Instr_Op_and_a0 || FETCH_Instr_Op_or_a0;
               assign FETCH_Instr_Op_full_a0 = FETCH_Instr_Op_arith_a0 || FETCH_Instr_Op_bitwise_a0 || FETCH_Instr_Op_wide_imm_a0 || FETCH_Instr_Op_combine_a0 || FETCH_Instr_Op_conditional_a0;
               //$op3 = $compare || $full;
               assign FETCH_Instr_Op_mem_a0 = FETCH_Instr_Op_ld_a0 || FETCH_Instr_Op_st_a0;
               assign FETCH_Instr_Op_illegal_a0 = !(FETCH_Instr_Op_compare_a0 || FETCH_Instr_Op_full_a0 || FETCH_Instr_Op_mem_a0);
            assign FETCH_Instr_op_compare_a0 = FETCH_Instr_Op_compare_a0;
            assign FETCH_Instr_op_full_a0 = FETCH_Instr_Op_full_a0;
            assign FETCH_Instr_ld_a0 = FETCH_Instr_Op_ld_a0;
            assign FETCH_Instr_st_a0 = FETCH_Instr_Op_st_a0;
            assign FETCH_Instr_illegal_a0 = FETCH_Instr_illegal_dest_a0 || (| FETCH_Instr_Src_illegal_a0) || FETCH_Instr_Op_illegal_a0;
            
            // ======
            // Reg Rd
            // ======
            
            for (src = 1; src <= 2; src++) begin : L1c_FETCH_Instr_Src logic L1_local_is_reg_a0; logic [11:0] L1_reg_value_a0; logic L1_valid_a0; logic [11:0] L1_value_a0; //_/src
               assign L1_local_is_reg_a0 = L1b_FETCH_Instr_Src[src].L1_is_reg_a0;
               //_?$local_is_reg
                  assign L1_reg_value_a0[11:0] = FETCH_Instr_Reg_Value_a0[L1b_FETCH_Instr_Src[src].L1_reg_a0];
               assign L1_valid_a0 = !FETCH_Instr_Src_illegal_a0[src];
               //_?$valid
                  assign L1_value_a0[11:0] = L1b_FETCH_Instr_Src[src].L1_is_reg_a0      ? L1_reg_value_a0 :
                                                {9'b0, L1b_FETCH_Instr_Src[src].L1_imm_value_a0}; end // $is_imm
            
            
            // =======
            // Execute
            // =======
            
            //_?$op_compare
               assign FETCH_Instr_compare_rslt_a0 =
                  FETCH_Instr_Op_eq_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 == L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_ne_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 != L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_lt_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 < L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_gt_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 > L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_le_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 <= L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_ge_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 >= L1c_FETCH_Instr_Src[2].L1_value_a0 :
                           1'b0;
            //_?$op_full
               assign FETCH_Instr_op_full_rslt_a0[11:0] =
                  FETCH_Instr_Op_add_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 + L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_sub_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 - L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_mul_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 * L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_div_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 * L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_and_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 & L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_or_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 | L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_wide_imm_a0 ? {6'b0, L1c_FETCH_Instr_Src[1].L1_value_a0[2:0], L1c_FETCH_Instr_Src[2].L1_value_a0[2:0]} :
                  FETCH_Instr_Op_combine_a0 ? {L1c_FETCH_Instr_Src[1].L1_value_a0[5:0], L1c_FETCH_Instr_Src[2].L1_value_a0[5:0]} :
                  FETCH_Instr_Op_conditional_a0 ? (L1c_FETCH_Instr_Src[2].L1_value_a0[11] ? 12'b0 : L1c_FETCH_Instr_Src[1].L1_value_a0) :
                                    12'b0;
            
            // =======
            // Next PC
            // =======
            
            // Jump (Dest = "P") and Branch (Dest = "p") Targets.
            //_?$jump
               assign FETCH_Instr_jump_target_a0[11:0] = FETCH_Instr_rslt_a0;
            //_?$branch
               assign FETCH_Instr_branch_target_a0[11:0] = FETCH_Instr_Pc_a0 + 12'b1 + FETCH_Instr_rslt_a0;
            
            //?$fetch_or_reset
            assign FETCH_Instr_Pc_n1[11:0] =
               FETCH_Instr_reset_a0 ? 0 :
               FETCH_Instr_jump_a0  ? FETCH_Instr_jump_target_a0 :
               FETCH_Instr_branch_a0 ? FETCH_Instr_branch_target_a0 :
               //$stall ? $RETAIN :
                        FETCH_Instr_Pc_a0 + 12'b1;
            
            // ?$fetch
            
            // ====
            // Load
            // ====
            
            //_?$ld
               assign FETCH_Instr_addr_a0[11:0] = L1c_FETCH_Instr_Src[1].L1_value_a0 + L1c_FETCH_Instr_Src[2].L1_value_a0;
               assign FETCH_Instr_ld_rslt_a0[11:0] = FETCH_Instr_Mem_Word_a0[FETCH_Instr_addr_a0[4:0]];
            
            // =========
            // Reg Write
            // =========
            
            //_?$dest_valid
               assign FETCH_Instr_rslt_a0[11:0] =
                  FETCH_Instr_op_full_a0 ? FETCH_Instr_op_full_rslt_a0 :
                  FETCH_Instr_op_compare_a0 ? {12{FETCH_Instr_compare_rslt_a0}} :
                  FETCH_Instr_ld_a0 ? FETCH_Instr_ld_rslt_a0 :
                        12'b0;
               
         // Array writes are not currently permitted to use assignment
         // syntax, so \always_comb is used, and this must be outside of
         // when conditions, so we need to use if. <<1 because no <= support
         // in this context. (This limitation will be lifted.)
         //_/instr
            // Store mem write.
            //_/mem
            always_comb begin
               if (FETCH_Instr_st_a0) // && $fetch
                  FETCH_Instr_Mem_Word_n1[L1c_FETCH_Instr_Src[2].L1_value_a0[4:0]][11:0] = L1c_FETCH_Instr_Src[1].L1_value_a0; end
            // Reg file write.
            //_/reg
            always_comb begin
               if (FETCH_Instr_dest_is_reg_a0) // && $fetch
                  FETCH_Instr_Reg_Value_n1[FETCH_Instr_dest_reg_a0][11:0] = FETCH_Instr_rslt_a0; end
            
            
   // Assert these to end simulation (before Makerchip cycle limit).
   assign passed = ! reset && cyc_cnt > 1000 || FETCH_Instr_Pc_a3 == 12'hfff;
   assign failed = ! reset && ! FETCH_Instr_reset_a3 && FETCH_Instr_illegal_a3; endgenerate
//_\SV
   endmodule

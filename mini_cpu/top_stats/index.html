<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 424, 2236, 0, 2, 469, 72, 0, 0, 'opacity: 0.1', 5577, 'opacity: 0.1', 3396, 'opacity: 0.1'],
      ['top.sv', 0, 424, 6468, 242, 0, 228, 0, 0, 0, 'opacity: 0.1', 5841, 'opacity: 0.1', 3537, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 1882, 878, 186, 0, 0, 4164, 'opacity: 0.1', 2232, 'opacity: 0.1', 3526, 'opacity: 0.1'],
      ['SV Total', 0, 424, 6468, 2124, 878, 414, 0, 0, 4164, 'opacity: 0.1', 8073, 'opacity: 0.1', 7063, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar mem, src, v_reg;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0;

</span><span class="tlx_comments">// For |fetch/instr$Pc.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_Pc_n1,
             FETCH_Instr_Pc_a0,
             FETCH_Instr_Pc_a1,
             FETCH_Instr_Pc_a2,
             FETCH_Instr_Pc_a3;

</span><span class="tlx_comments">// For |fetch/instr$addr.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_addr_a0;

</span><span class="tlx_comments">// For |fetch/instr$branch.
</span><span class="tlx_declarations">logic FETCH_Instr_branch_a0;

</span><span class="tlx_comments">// For |fetch/instr$branch_target.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_branch_target_a0;

</span><span class="tlx_comments">// For |fetch/instr$compare_rslt.
</span><span class="tlx_declarations">logic FETCH_Instr_compare_rslt_a0;

</span><span class="tlx_comments">// For |fetch/instr$dest_char.
</span><span class="tlx_declarations">logic [7:0] FETCH_Instr_dest_char_a0;

</span><span class="tlx_comments">// For |fetch/instr$dest_is_reg.
</span><span class="tlx_declarations">logic FETCH_Instr_dest_is_reg_a0;

</span><span class="tlx_comments">// For |fetch/instr$dest_reg.
</span><span class="tlx_declarations">logic [2:0] FETCH_Instr_dest_reg_a0;

</span><span class="tlx_comments">// For |fetch/instr$dest_tmp.
</span><span class="tlx_declarations">logic [7:0] FETCH_Instr_dest_tmp_a0;

</span><span class="tlx_comments">// For |fetch/instr$dest_valid.
</span><span class="tlx_declarations">logic FETCH_Instr_dest_valid_a0;

</span><span class="tlx_comments">// For |fetch/instr$illegal.
</span><span class="tlx_declarations">logic FETCH_Instr_illegal_a0,
      FETCH_Instr_illegal_a1,
      FETCH_Instr_illegal_a2,
      FETCH_Instr_illegal_a3;

</span><span class="tlx_comments">// For |fetch/instr$illegal_dest.
</span><span class="tlx_declarations">logic FETCH_Instr_illegal_dest_a0;

</span><span class="tlx_comments">// For |fetch/instr$jump.
</span><span class="tlx_declarations">logic FETCH_Instr_jump_a0;

</span><span class="tlx_comments">// For |fetch/instr$jump_target.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_jump_target_a0;

</span><span class="tlx_comments">// For |fetch/instr$ld.
</span><span class="tlx_declarations">logic FETCH_Instr_ld_a0;

</span><span class="tlx_comments">// For |fetch/instr$ld_rslt.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_ld_rslt_a0;

</span><span class="tlx_comments">// For |fetch/instr$no_dest.
</span><span class="tlx_declarations">logic FETCH_Instr_no_dest_a0;

</span><span class="tlx_comments">// For |fetch/instr$op_char.
</span><span class="tlx_declarations">logic [7:0] FETCH_Instr_op_char_a0;

</span><span class="tlx_comments">// For |fetch/instr$op_compare.
</span><span class="tlx_declarations">logic FETCH_Instr_op_compare_a0;

</span><span class="tlx_comments">// For |fetch/instr$op_full.
</span><span class="tlx_declarations">logic FETCH_Instr_op_full_a0;

</span><span class="tlx_comments">// For |fetch/instr$op_full_rslt.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_op_full_rslt_a0;

</span><span class="tlx_comments">// For |fetch/instr$raw.
</span><span class="tlx_declarations">logic [39:0] FETCH_Instr_raw_a0;

</span><span class="tlx_comments">// For |fetch/instr$reset.
</span><span class="tlx_declarations">logic FETCH_Instr_reset_a0,
      FETCH_Instr_reset_a1,
      FETCH_Instr_reset_a2,
      FETCH_Instr_reset_a3;

</span><span class="tlx_comments">// For |fetch/instr$rslt.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_rslt_a0;

</span><span class="tlx_comments">// For |fetch/instr$st.
</span><span class="tlx_declarations">logic FETCH_Instr_st_a0;

</span><span class="tlx_comments">// For |fetch/instr$write_pc.
</span><span class="tlx_declarations">logic FETCH_Instr_write_pc_a0;

</span><span class="tlx_comments">// For |fetch/instr/mem$Word.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_Mem_Word_n1 [31:0],
             FETCH_Instr_Mem_Word_a0 [31:0];

</span><span class="tlx_comments">// For |fetch/instr/op$add.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_add_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$and.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_and_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$arith.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_arith_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$bitwise.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_bitwise_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$char.
</span><span class="tlx_declarations">logic [7:0] FETCH_Instr_Op_char_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$combine.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_combine_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$compare.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_compare_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$conditional.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_conditional_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$div.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_div_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$eq.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_eq_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$full.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_full_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$ge.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_ge_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$gt.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_gt_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$illegal.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_illegal_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$ld.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_ld_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$le.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_le_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$lt.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_lt_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$mem.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_mem_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$mul.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_mul_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$ne.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_ne_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$or.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_or_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$st.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_st_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$sub.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_sub_a0;

</span><span class="tlx_comments">// For |fetch/instr/op$wide_imm.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_wide_imm_a0;

</span><span class="tlx_comments">// For |fetch/instr/reg$Value.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_Reg_Value_n1 [7:0],
             FETCH_Instr_Reg_Value_a0 [7:0];

</span><span class="tlx_comments">// For |fetch/instr/src$illegal.
</span><span class="tlx_declarations">logic [2:1] FETCH_Instr_Src_illegal_a0;


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">

   //
   // Scope: |fetch
   //


      //
      // Scope: /instr
      //

         // For $Pc.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Pc_a0[11:0] &lt;= FETCH_Instr_Pc_n1[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a1[11:0] &lt;= FETCH_Instr_Pc_a0[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a2[11:0] &lt;= FETCH_Instr_Pc_a1[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a3[11:0] &lt;= FETCH_Instr_Pc_a2[11:0];

         </span><span class="tlx_comments">// For $illegal.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_illegal_a1 &lt;= FETCH_Instr_illegal_a0;
         always_ff @(posedge clk) FETCH_Instr_illegal_a2 &lt;= FETCH_Instr_illegal_a1;
         always_ff @(posedge clk) FETCH_Instr_illegal_a3 &lt;= FETCH_Instr_illegal_a2;

         </span><span class="tlx_comments">// For $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_reset_a1 &lt;= FETCH_Instr_reset_a0;
         always_ff @(posedge clk) FETCH_Instr_reset_a2 &lt;= FETCH_Instr_reset_a1;
         always_ff @(posedge clk) FETCH_Instr_reset_a3 &lt;= FETCH_Instr_reset_a2;


         </span><span class="tlx_comments">//
         // Scope: /mem[31:0]
         //
         </span><span class="tlx_structure">for (mem = 0; mem &lt;= 31; mem++) begin : L1gen_FETCH_Instr_Mem
</span><span class="tlx_comments">            // For $Word.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Mem_Word_a0[mem][11:0] &lt;= FETCH_Instr_Mem_Word_n1[mem][11:0];

         </span><span class="tlx_structure">end

         </span><span class="tlx_comments">//
         // Scope: /reg[7:0]
         //
         </span><span class="tlx_structure">for (v_reg = 0; v_reg &lt;= 7; v_reg++) begin : L1gen_FETCH_Instr_Reg
</span><span class="tlx_comments">            // For $Value.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Reg_Value_a0[v_reg][11:0] &lt;= FETCH_Instr_Reg_Value_n1[v_reg][11:0];

         </span><span class="tlx_structure">end




endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      </span><span class="tlx_comments">//
      // Scope: |fetch
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|fetch 
</span><span class="tlx_comments">
         //
         // Scope: /instr
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/instr 
            logic [11:0] \@-1$Pc ;
            assign \@-1$Pc = FETCH_Instr_Pc_n1;
            logic [11:0] \@0$addr ;
            assign \@0$addr = FETCH_Instr_addr_a0;
            logic  \@0$branch ;
            assign \@0$branch = FETCH_Instr_branch_a0;
            logic [11:0] \@0$branch_target ;
            assign \@0$branch_target = FETCH_Instr_branch_target_a0;
            logic  \@0$compare_rslt ;
            assign \@0$compare_rslt = FETCH_Instr_compare_rslt_a0;
            logic [7:0] \@0$dest_char ;
            assign \@0$dest_char = FETCH_Instr_dest_char_a0;
            logic  \@0$dest_is_reg ;
            assign \@0$dest_is_reg = FETCH_Instr_dest_is_reg_a0;
            logic [2:0] \@0$dest_reg ;
            assign \@0$dest_reg = FETCH_Instr_dest_reg_a0;
            logic [7:0] \@0$dest_tmp ;
            assign \@0$dest_tmp = FETCH_Instr_dest_tmp_a0;
            logic  \@0$dest_valid ;
            assign \@0$dest_valid = FETCH_Instr_dest_valid_a0;
            logic  \@0$illegal ;
            assign \@0$illegal = FETCH_Instr_illegal_a0;
            logic  \@0$illegal_dest ;
            assign \@0$illegal_dest = FETCH_Instr_illegal_dest_a0;
            logic  \@0$jump ;
            assign \@0$jump = FETCH_Instr_jump_a0;
            logic [11:0] \@0$jump_target ;
            assign \@0$jump_target = FETCH_Instr_jump_target_a0;
            logic  \@0$ld ;
            assign \@0$ld = FETCH_Instr_ld_a0;
            logic [11:0] \@0$ld_rslt ;
            assign \@0$ld_rslt = FETCH_Instr_ld_rslt_a0;
            logic  \@0$no_dest ;
            assign \@0$no_dest = FETCH_Instr_no_dest_a0;
            logic [7:0] \@0$op_char ;
            assign \@0$op_char = FETCH_Instr_op_char_a0;
            logic  \@0$op_compare ;
            assign \@0$op_compare = FETCH_Instr_op_compare_a0;
            logic  \@0$op_full ;
            assign \@0$op_full = FETCH_Instr_op_full_a0;
            logic [11:0] \@0$op_full_rslt ;
            assign \@0$op_full_rslt = FETCH_Instr_op_full_rslt_a0;
            logic [39:0] \@0$raw ;
            assign \@0$raw = FETCH_Instr_raw_a0;
            logic  \@0$reset ;
            assign \@0$reset = FETCH_Instr_reset_a0;
            logic [11:0] \@0$rslt ;
            assign \@0$rslt = FETCH_Instr_rslt_a0;
            logic  \@0$st ;
            assign \@0$st = FETCH_Instr_st_a0;
            logic  \@0$write_pc ;
            assign \@0$write_pc = FETCH_Instr_write_pc_a0;

            </span><span class="tlx_comments">//
            // Scope: /mem[31:0]
            //
            </span><span class="tlx_instrumentation">for (mem = 0; mem &lt;= 31; mem++) begin : \/mem 
               logic [11:0] \@-1$Word ;
               assign \@-1$Word = FETCH_Instr_Mem_Word_n1[mem];
            end

            </span><span class="tlx_comments">//
            // Scope: /op
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/op 
               logic  \@0$add ;
               assign \@0$add = FETCH_Instr_Op_add_a0;
               logic  \@0$and ;
               assign \@0$and = FETCH_Instr_Op_and_a0;
               logic  \@0$arith ;
               assign \@0$arith = FETCH_Instr_Op_arith_a0;
               logic  \@0$bitwise ;
               assign \@0$bitwise = FETCH_Instr_Op_bitwise_a0;
               logic [7:0] \@0$char ;
               assign \@0$char = FETCH_Instr_Op_char_a0;
               logic  \@0$combine ;
               assign \@0$combine = FETCH_Instr_Op_combine_a0;
               logic  \@0$compare ;
               assign \@0$compare = FETCH_Instr_Op_compare_a0;
               logic  \@0$conditional ;
               assign \@0$conditional = FETCH_Instr_Op_conditional_a0;
               logic  \@0$div ;
               assign \@0$div = FETCH_Instr_Op_div_a0;
               logic  \@0$eq ;
               assign \@0$eq = FETCH_Instr_Op_eq_a0;
               logic  \@0$full ;
               assign \@0$full = FETCH_Instr_Op_full_a0;
               logic  \@0$ge ;
               assign \@0$ge = FETCH_Instr_Op_ge_a0;
               logic  \@0$gt ;
               assign \@0$gt = FETCH_Instr_Op_gt_a0;
               logic  \@0$illegal ;
               assign \@0$illegal = FETCH_Instr_Op_illegal_a0;
               logic  \@0$ld ;
               assign \@0$ld = FETCH_Instr_Op_ld_a0;
               logic  \@0$le ;
               assign \@0$le = FETCH_Instr_Op_le_a0;
               logic  \@0$lt ;
               assign \@0$lt = FETCH_Instr_Op_lt_a0;
               logic  \@0$mem ;
               assign \@0$mem = FETCH_Instr_Op_mem_a0;
               logic  \@0$mul ;
               assign \@0$mul = FETCH_Instr_Op_mul_a0;
               logic  \@0$ne ;
               assign \@0$ne = FETCH_Instr_Op_ne_a0;
               logic  \@0$or ;
               assign \@0$or = FETCH_Instr_Op_or_a0;
               logic  \@0$st ;
               assign \@0$st = FETCH_Instr_Op_st_a0;
               logic  \@0$sub ;
               assign \@0$sub = FETCH_Instr_Op_sub_a0;
               logic  \@0$wide_imm ;
               assign \@0$wide_imm = FETCH_Instr_Op_wide_imm_a0;
            end

            </span><span class="tlx_comments">//
            // Scope: /reg[7:0]
            //
            </span><span class="tlx_instrumentation">for (v_reg = 0; v_reg &lt;= 7; v_reg++) begin : \/reg 
               logic [11:0] \@-1$Value ;
               assign \@-1$Value = FETCH_Instr_Reg_Value_n1[v_reg];
            end

            </span><span class="tlx_comments">//
            // Scope: /src[2:1]
            //
            </span><span class="tlx_instrumentation">for (src = 1; src &lt;= 2; src++) begin : \/src 
               logic [7:0] \@0$char ;
               assign \@0$char = L1_FETCH_Instr_Src[src].L1_char_a0;
               logic  \@0$illegal ;
               assign \@0$illegal = FETCH_Instr_Src_illegal_a0[src];
               logic [7:0] \@0$imm_tmp ;
               assign \@0$imm_tmp = L1b_FETCH_Instr_Src[src].L1_imm_tmp_a0;
               logic [2:0] \@0$imm_value ;
               assign \@0$imm_value = L1b_FETCH_Instr_Src[src].L1_imm_value_a0;
               logic  \@0$is_imm ;
               assign \@0$is_imm = L1b_FETCH_Instr_Src[src].L1_is_imm_a0;
               logic  \@0$is_reg ;
               assign \@0$is_reg = L1b_FETCH_Instr_Src[src].L1_is_reg_a0;
               logic  \@0$local_is_reg ;
               assign \@0$local_is_reg = L1c_FETCH_Instr_Src[src].L1_local_is_reg_a0;
               logic [2:0] \@0$reg ;
               assign \@0$reg = L1b_FETCH_Instr_Src[src].L1_reg_a0;
               logic [7:0] \@0$reg_tmp ;
               assign \@0$reg_tmp = L1b_FETCH_Instr_Src[src].L1_reg_tmp_a0;
               logic [11:0] \@0$reg_value ;
               assign \@0$reg_value = L1c_FETCH_Instr_Src[src].L1_reg_value_a0;
               logic  \@0$valid ;
               assign \@0$valid = L1c_FETCH_Instr_Src[src].L1_valid_a0;
               logic [11:0] \@0$value ;
               assign \@0$value = L1c_FETCH_Instr_Src[src].L1_value_a0;
            end
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
</span><span class="tlx_comments">// -----------------------------------------------------------------------------
// Copyright (c) 2017, Redwood EDA
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Redwood EDA nor the names of its contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------


// A dirt-simple CPU for educational purposes.

// What's interesting about this CPU?
//   o It's super small.
//   o It's easy to play with and learn from.
//   o Instructions are short, kind-of-readable strings, so no assembler is needed.
//     They would map directly to a denser (~17-bit) encoding if desired.
//   o The only instruction formats are op, load, and store.
//   o Branch/Jump: There is no special format for control-flow instructions. Any
//     instruction can write the PC (relative or absolute). A conditional branch
//     will typically utilize a condition operation that provides a (relative) branch
//     target or zero. The condition can be predicted as per traditional branch
//     prediction (though there is no branch predictor in this example as it stands).

// Machine Arch:
//   o Single stage &quot;pipeline&quot;.
//   o 8 registers.
//   o A word is 12 bits wide.
//   o Operators operate on and produce words as signed or unsigned values and
//     booleans (all-zero/one)
//
// ISA:
//
// Instructions are 5-character strings: &quot;D=1o2&quot;
//
// =: Appears in every instruction (just for readability).
// D, 2, 1: &quot;a&quot; - &quot;h&quot; for register values;
//          &quot;0&quot; - &quot;7&quot; for immediate constants (sources, or &quot;0&quot; for unused dest);
//          &quot;P&quot; for absolute dest PC (jump);
//          &quot;p&quot; for relative dest PC (branch), PC = PC + 1 + result(signed).
//
// o: operator
//   Op: (D = 1 o 2) (Eg: &quot;c=a+b&quot;):
//     +, -, *, /: Arithmetic. *, / are unsigned.
//     =, !, &lt;, &gt;, [, ]: Compare (D = (1 o r) ? all-1s : 0) (] is &gt;=, [ is &lt;=)
//        (On booleans these are XNOR, XOR, !1&amp;2, 1&amp;!2, !1|2, 1|!2)
//     &amp;, |: Bitwise
//        (Can be used on booleans as well as vectors.)
//     (There are no operators for NAND and NOR and unary !.)
//     ~: Extended constant (D = {1[2:0], 2[2:0]})
//     ,: Combine (D = {1[11:6], 2[5:0]})
//     ?: Conditional (D = 2 ? `0 : 1)
//   Load (Eg: &quot;c=a{b&quot;) (D = [1 + 2] (typically 1 would be an immediate offset):
//     {: Load
//   Store (Eg: &quot;0=a}b&quot;) ([2] = 1):
//     }: Store
//
// A full-width immediate load sequence, to load octal 2017 is:
//   a=2~0
//   b=1~7
//   a=a,b

// A typical local conditional branch sequence is:
//   a=0-6  // offset
//   c=c-1  // decrementing loop counter
//   p=a?c  // branch by a (to PC+1-6) if c is non-negative (MSB==0)


</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
/* verilator lint_on WIDTH */  // Let's be strict about bit widths.

   
   </span><span class="tlx_untouched">logic [39:0] instrs [0:12-1];


   </span><span class="tlx_comments">// =======
   // Program
   // =======

   // Add 1,2,3,...,10 (in that order).
   // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
   //
   // Regs:
   // b: cnt
   // c: ten
   // d: out
   // e: tmp
   // f: offset
   // g: store addr

   </span><span class="tlx_untouched">assign instrs = '{
      &quot;g=0~0&quot;, </span><span class="tlx_comments">//     store_addr = 0
      </span><span class="tlx_untouched">&quot;b=0~1&quot;, </span><span class="tlx_comments">//     cnt = 1
      </span><span class="tlx_untouched">&quot;c=1~2&quot;, </span><span class="tlx_comments">//     ten = 10
      </span><span class="tlx_untouched">&quot;d=0~0&quot;, </span><span class="tlx_comments">//     out = 0
      </span><span class="tlx_untouched">&quot;f=0-6&quot;, </span><span class="tlx_comments">//     offset = -6
      </span><span class="tlx_untouched">&quot;d=d+b&quot;, </span><span class="tlx_comments">//  -&gt; out += cnt
      </span><span class="tlx_untouched">&quot;0=d}g&quot;, </span><span class="tlx_comments">//     store out at store_addr
      </span><span class="tlx_untouched">&quot;b=b+1&quot;, </span><span class="tlx_comments">//     cnt ++
      </span><span class="tlx_untouched">&quot;g=g+1&quot;, </span><span class="tlx_comments">//     store_addr++
      </span><span class="tlx_untouched">&quot;e=c-b&quot;, </span><span class="tlx_comments">//     tmp = 10 - cnt
      </span><span class="tlx_untouched">&quot;p=f?e&quot;, </span><span class="tlx_comments">//  ^- branch back if tmp &gt;= 0
      </span><span class="tlx_untouched">&quot;P=0-1&quot;  </span><span class="tlx_comments">//     TERMINATE by jumping to -1
   </span><span class="tlx_untouched">};


</span><span class="tlx_structure">\TLV
   
   </span><span class="tlx_comments">// =======
   // The CPU
   // =======
   
   </span><span class="tlx_logic">$reset = *reset;

   </span><span class="tlx_structure">|fetch
      </span><span class="tlx_staging">@0
         
         </span><span class="tlx_structure">/instr
            </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/top</span><span class="tlx_logic">&lt;&gt;0$reset;
            
            </span><span class="tlx_comments">//?$fetch  // We'll need this once there are invalid cycles.

            // =====
            // Fetch
            // =====

            </span><span class="tlx_logic">$raw[39:0] = *instrs\[$Pc[3:0]\];

            </span><span class="tlx_comments">// ======
            // DECODE
            // ======

            // Characters
            </span><span class="tlx_logic">$dest_char[7:0] = $raw[39:32];
            </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">:</span><span class="tlx_logic">1</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$char[7:0] = (#src == 1) ? </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$raw[23:16] : </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$raw[7:0];
            $op_char[7:0] = $raw[15:8];

            </span><span class="tlx_comments">// Dest
            </span><span class="tlx_logic">$dest_is_reg = $dest_char &gt;= &quot;a&quot; &amp;&amp; $dest_char &lt;= &quot;h&quot;;
            $dest_tmp[7:0] = $dest_char - &quot;a&quot;;
            $dest_reg[2:0] = $dest_tmp[2:0];
            $jump = $dest_char == &quot;P&quot;;
            $branch = $dest_char == &quot;p&quot;;
            $no_dest = $dest_char == &quot;0&quot;;
            $write_pc = $jump || $branch;
            $dest_valid = $write_pc || $dest_is_reg;
            $illegal_dest = !($dest_is_reg || 
                              $branch || $jump || $no_dest);

            </span><span class="tlx_structure">/src[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
               </span><span class="tlx_comments">// Src1
               </span><span class="tlx_logic">$is_reg = $char &gt;= &quot;a&quot; &amp;&amp; $char &lt;= &quot;h&quot;;
               $reg_tmp[7:0] = $char - &quot;a&quot;;
               $reg[2:0] = $reg_tmp[2:0];
               $is_imm = $char &gt;= &quot;0&quot; &amp;&amp; $char &lt; &quot;8&quot;;
               $imm_tmp[7:0] = $char - &quot;0&quot;;
               $imm_value[2:0] = $imm_tmp[2:0];
               $illegal = !($is_reg || $is_imm);

            </span><span class="tlx_comments">// Opcode:
            </span><span class="tlx_structure">/op
               </span><span class="tlx_logic">$char[7:0] = </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$op_char;
               </span><span class="tlx_comments">// Arithmetic
               </span><span class="tlx_logic">$add = $char == &quot;+&quot;;
               $sub = $char == &quot;-&quot;;
               $mul = $char == &quot;*&quot;;
               $div = $char == &quot;/&quot;;
               </span><span class="tlx_comments">// Compare and bool (w/ 1 bit rslt)
               </span><span class="tlx_logic">$eq = $char == &quot;=&quot;;
               $ne = $char == &quot;!&quot;;
               $lt = $char == &quot;&lt;&quot;;
               $gt = $char == &quot;&gt;&quot;;
               $le = $char == &quot;[&quot;;
               $ge = $char == &quot;]&quot;;
               $and = $char == &quot;&amp;&quot;;
               $or = $char == &quot;|&quot;;
               </span><span class="tlx_comments">// Wide Immediate
               </span><span class="tlx_logic">$wide_imm = $char == &quot;~&quot;;
               $combine = $char == &quot;,&quot;;
               </span><span class="tlx_comments">// Conditional
               </span><span class="tlx_logic">$conditional = $char == &quot;?&quot;;
               </span><span class="tlx_comments">// Memory
               </span><span class="tlx_logic">$ld = $char == &quot;{&quot;;
               $st = $char == &quot;}&quot;;
               </span><span class="tlx_comments">// Opcode classes:
               </span><span class="tlx_logic">$arith = $add || $sub || $mul || $div;
               $compare = $eq || $ne || $lt || $gt || $le || $ge;
               $bitwise = $and || $or;
               $full = $arith || $bitwise || $wide_imm || $combine || $conditional;
               </span><span class="tlx_comments">//$op3 = $compare || $full;
               </span><span class="tlx_logic">$mem = $ld || $st;
               $illegal = !($compare || $full || $mem);
            $op_compare = </span><span class="tlx_structure">/op</span><span class="tlx_logic">$compare;
            $op_full = </span><span class="tlx_structure">/op</span><span class="tlx_logic">$full;
            $ld = </span><span class="tlx_structure">/op</span><span class="tlx_logic">$ld;
            $st = </span><span class="tlx_structure">/op</span><span class="tlx_logic">$st;
            $illegal = $illegal_dest || (| </span><span class="tlx_structure">/src[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$illegal) || </span><span class="tlx_structure">/op</span><span class="tlx_logic">$illegal;
            
            </span><span class="tlx_comments">// ======
            // Reg Rd
            // ======
            
            </span><span class="tlx_structure">/src[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$local_is_reg = $is_reg;
               </span><span class="tlx_validity">?$local_is_reg
                  </span><span class="tlx_logic">$reg_value[11:0] = </span><span class="tlx_structure">/instr/reg[</span><span class="tlx_logic">$reg</span><span class="tlx_structure">]</span><span class="tlx_logic">$Value;
               $valid = !$illegal;
               </span><span class="tlx_validity">?$valid
                  </span><span class="tlx_logic">$value[11:0] = $is_reg      ? $reg_value :
                                                {9'b0, $imm_value}; </span><span class="tlx_comments">// $is_imm
            
            
            // =======
            // Execute
            // =======
            
            </span><span class="tlx_validity">?$op_compare
               </span><span class="tlx_logic">$compare_rslt =
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$eq ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value == </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$ne ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value != </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$lt ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &lt; </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$gt ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &gt; </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$le ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &lt;= </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$ge ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &gt;= </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                           1'b0;
            </span><span class="tlx_validity">?$op_full
               </span><span class="tlx_logic">$op_full_rslt[11:0] =
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$add ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value + </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$sub ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value - </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$mul ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value * </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$div ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value * </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$and ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &amp; </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$or ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value | </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$wide_imm ? {6'b0, </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[2:0], </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[2:0]} :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$combine ? {</span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[5:0], </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[5:0]} :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$conditional ? (</span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[11] ? 12'b0 : </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value) :
                                    12'b0;
            
            </span><span class="tlx_comments">// =======
            // Next PC
            // =======
            
            // Jump (Dest = &quot;P&quot;) and Branch (Dest = &quot;p&quot;) Targets.
            </span><span class="tlx_validity">?$jump
               </span><span class="tlx_logic">$jump_target[11:0] = $rslt;
            </span><span class="tlx_validity">?$branch
               </span><span class="tlx_logic">$branch_target[11:0] = $Pc + 12'b1 + $rslt;
            
            </span><span class="tlx_comments">//?$fetch_or_reset
            </span><span class="tlx_logic">$Pc[11:0] &lt;=
               $reset ? 0 :
               $jump  ? $jump_target :
               $branch ? $branch_target :
               </span><span class="tlx_comments">//$stall ? $RETAIN :
                        </span><span class="tlx_logic">$Pc + 12'b1;
            
            </span><span class="tlx_comments">// ?$fetch
            
            // ====
            // Load
            // ====
            
            </span><span class="tlx_validity">?$ld
               </span><span class="tlx_logic">$addr[11:0] = </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value + </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value;
               $ld_rslt[11:0] = </span><span class="tlx_structure">/mem[</span><span class="tlx_logic">$addr[4:0]</span><span class="tlx_structure">]</span><span class="tlx_logic">$Word;
            
            </span><span class="tlx_comments">// =========
            // Reg Write
            // =========
            
            </span><span class="tlx_validity">?$dest_valid
               </span><span class="tlx_logic">$rslt[11:0] =
                  $op_full ? $op_full_rslt :
                  $op_compare ? {12{$compare_rslt}} :
                  $ld ? $ld_rslt :
                        12'b0;
               
         </span><span class="tlx_comments">// Array writes are not currently permitted to use assignment
         // syntax, so \always_comb is used, and this must be outside of
         // when conditions, so we need to use if. &lt;&lt;1 because no &lt;= support
         // in this context. (This limitation will be lifted.)
         </span><span class="tlx_structure">/instr
            </span><span class="tlx_comments">// Store mem write.
            </span><span class="tlx_structure">/mem[</span><span class="tlx_logic">31</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            \always_comb
               </span><span class="tlx_logic">if ($st) </span><span class="tlx_comments">// &amp;&amp; $fetch
                  </span><span class="tlx_structure">/mem[/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[4:0]</span><span class="tlx_structure">]</span><span class="tlx_logic">&lt;&lt;1$$Word[11:0] = </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value;
            </span><span class="tlx_comments">// Reg file write.
            </span><span class="tlx_structure">/reg[</span><span class="tlx_logic">7</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            \always_comb
               </span><span class="tlx_logic">if ($dest_is_reg) </span><span class="tlx_comments">// &amp;&amp; $fetch
                  </span><span class="tlx_structure">/reg[</span><span class="tlx_logic">$dest_reg</span><span class="tlx_structure">]</span><span class="tlx_logic">&lt;&lt;1$$Value[11:0] = $rslt;
            
            
   </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">*passed = ! *reset &amp;&amp; *cyc_cnt &gt; 1000 || </span><span class="tlx_structure">|fetch/instr</span><span class="tlx_logic">&gt;&gt;3$Pc == 12'hfff;
   *failed = ! *reset &amp;&amp; ! </span><span class="tlx_structure">|fetch/instr</span><span class="tlx_logic">&gt;&gt;3$reset &amp;&amp; </span><span class="tlx_structure">|fetch/instr</span><span class="tlx_logic">&gt;&gt;3$illegal;
</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
// -----------------------------------------------------------------------------
// Copyright (c) 2017, Redwood EDA
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Redwood EDA nor the names of its contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------


// A dirt-simple CPU for educational purposes.

// What's interesting about this CPU?
//   o It's super small.
//   o It's easy to play with and learn from.
//   o Instructions are short, kind-of-readable strings, so no assembler is needed.
//     They would map directly to a denser (~17-bit) encoding if desired.
//   o The only instruction formats are op, load, and store.
//   o Branch/Jump: There is no special format for control-flow instructions. Any
//     instruction can write the PC (relative or absolute). A conditional branch
//     will typically utilize a condition operation that provides a (relative) branch
//     target or zero. The condition can be predicted as per traditional branch
//     prediction (though there is no branch predictor in this example as it stands).

// Machine Arch:
//   o Single stage &quot;pipeline&quot;.
//   o 8 registers.
//   o A word is 12 bits wide.
//   o Operators operate on and produce words as signed or unsigned values and
//     booleans (all-zero/one)
//
// ISA:
//
// Instructions are 5-character strings: &quot;D=1o2&quot;
//
// =: Appears in every instruction (just for readability).
// D, 2, 1: &quot;a&quot; - &quot;h&quot; for register values;
//          &quot;0&quot; - &quot;7&quot; for immediate constants (sources, or &quot;0&quot; for unused dest);
//          &quot;P&quot; for absolute dest PC (jump);
//          &quot;p&quot; for relative dest PC (branch), PC = PC + 1 + result(signed).
//
// o: operator
//   Op: (D = 1 o 2) (Eg: &quot;c=a+b&quot;):
//     +, -, *, /: Arithmetic. *, / are unsigned.
//     =, !, &lt;, &gt;, [, ]: Compare (D = (1 o r) ? all-1s : 0) (] is &gt;=, [ is &lt;=)
//        (On booleans these are XNOR, XOR, !1&amp;2, 1&amp;!2, !1|2, 1|!2)
//     &amp;, |: Bitwise
//        (Can be used on booleans as well as vectors.)
//     (There are no operators for NAND and NOR and unary !.)
//     ~: Extended constant (D = {1[2:0], 2[2:0]})
//     ,: Combine (D = {1[11:6], 2[5:0]})
//     ?: Conditional (D = 2 ? `0 : 1)
//   Load (Eg: &quot;c=a{b&quot;) (D = [1 + 2] (typically 1 would be an immediate offset):
//     {: Load
//   Store (Eg: &quot;0=a}b&quot;) ([2] = 1):
//     }: Store
//
// A full-width immediate load sequence, to load octal 2017 is:
//   a=2~0
//   b=1~7
//   a=a,b

// A typical local conditional branch sequence is:
//   a=0-6  // offset
//   c=c-1  // decrementing loop counter
//   p=a?c  // branch by a (to PC+1-6) if c is non-negative (MSB==0)


</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
/* verilator lint_on WIDTH */  // Let's be strict about bit widths.

   
   </span><span class="tlx_untouched">logic [39:0] instrs [0:12-1];


   </span><span class="tlx_comments">// =======
   // Program
   // =======

   // Add 1,2,3,...,10 (in that order).
   // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
   //
   // Regs:
   // b: cnt
   // c: ten
   // d: out
   // e: tmp
   // f: offset
   // g: store addr

   </span><span class="tlx_untouched">assign instrs = '{
      &quot;g=0~0&quot;, </span><span class="tlx_comments">//     store_addr = 0
      </span><span class="tlx_untouched">&quot;b=0~1&quot;, </span><span class="tlx_comments">//     cnt = 1
      </span><span class="tlx_untouched">&quot;c=1~2&quot;, </span><span class="tlx_comments">//     ten = 10
      </span><span class="tlx_untouched">&quot;d=0~0&quot;, </span><span class="tlx_comments">//     out = 0
      </span><span class="tlx_untouched">&quot;f=0-6&quot;, </span><span class="tlx_comments">//     offset = -6
      </span><span class="tlx_untouched">&quot;d=d+b&quot;, </span><span class="tlx_comments">//  -&gt; out += cnt
      </span><span class="tlx_untouched">&quot;0=d}g&quot;, </span><span class="tlx_comments">//     store out at store_addr
      </span><span class="tlx_untouched">&quot;b=b+1&quot;, </span><span class="tlx_comments">//     cnt ++
      </span><span class="tlx_untouched">&quot;g=g+1&quot;, </span><span class="tlx_comments">//     store_addr++
      </span><span class="tlx_untouched">&quot;e=c-b&quot;, </span><span class="tlx_comments">//     tmp = 10 - cnt
      </span><span class="tlx_untouched">&quot;p=f?e&quot;, </span><span class="tlx_comments">//  ^- branch back if tmp &gt;= 0
      </span><span class="tlx_untouched">&quot;P=0-1&quot;  </span><span class="tlx_comments">//     TERMINATE by jumping to -1
   </span><span class="tlx_untouched">};


</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   
   // =======
   // The CPU
   // =======
   
   </span><span class="tlx_logic">assign L0_reset_a0 = reset;

   </span><span class="tlx_comments">//_|fetch
      //_@0
         
         //_/instr
            </span><span class="tlx_logic">assign FETCH_Instr_reset_a0 = L0_reset_a0;
            
            </span><span class="tlx_comments">//?$fetch  // We'll need this once there are invalid cycles.

            // =====
            // Fetch
            // =====

            </span><span class="tlx_logic">assign FETCH_Instr_raw_a0[39:0] = instrs[FETCH_Instr_Pc_a0[3:0]];

            </span><span class="tlx_comments">// ======
            // DECODE
            // ======

            // Characters
            </span><span class="tlx_logic">assign FETCH_Instr_dest_char_a0[7:0] = FETCH_Instr_raw_a0[39:32];
            </span><span class="tlx_structure">for (src = 1; src &lt;= 2; src++) begin : L1_FETCH_Instr_Src </span><span class="tlx_declarations">logic [7:0] L1_char_a0; </span><span class="tlx_comments">//_/src
               </span><span class="tlx_logic">assign L1_char_a0[7:0] = (src == 1) ? FETCH_Instr_raw_a0[23:16] : FETCH_Instr_raw_a0[7:0]; </span><span class="tlx_structure">end
            </span><span class="tlx_logic">assign FETCH_Instr_op_char_a0[7:0] = FETCH_Instr_raw_a0[15:8];

            </span><span class="tlx_comments">// Dest
            </span><span class="tlx_logic">assign FETCH_Instr_dest_is_reg_a0 = FETCH_Instr_dest_char_a0 &gt;= &quot;a&quot; &amp;&amp; FETCH_Instr_dest_char_a0 &lt;= &quot;h&quot;;
            assign FETCH_Instr_dest_tmp_a0[7:0] = FETCH_Instr_dest_char_a0 - &quot;a&quot;;
            assign FETCH_Instr_dest_reg_a0[2:0] = FETCH_Instr_dest_tmp_a0[2:0];
            assign FETCH_Instr_jump_a0 = FETCH_Instr_dest_char_a0 == &quot;P&quot;;
            assign FETCH_Instr_branch_a0 = FETCH_Instr_dest_char_a0 == &quot;p&quot;;
            assign FETCH_Instr_no_dest_a0 = FETCH_Instr_dest_char_a0 == &quot;0&quot;;
            assign FETCH_Instr_write_pc_a0 = FETCH_Instr_jump_a0 || FETCH_Instr_branch_a0;
            assign FETCH_Instr_dest_valid_a0 = FETCH_Instr_write_pc_a0 || FETCH_Instr_dest_is_reg_a0;
            assign FETCH_Instr_illegal_dest_a0 = !(FETCH_Instr_dest_is_reg_a0 || 
                              FETCH_Instr_branch_a0 || FETCH_Instr_jump_a0 || FETCH_Instr_no_dest_a0);

            </span><span class="tlx_structure">for (src = 1; src &lt;= 2; src++) begin : L1b_FETCH_Instr_Src </span><span class="tlx_declarations">logic [7:0] L1_imm_tmp_a0; logic [2:0] L1_imm_value_a0; logic L1_is_imm_a0; logic L1_is_reg_a0; logic [2:0] L1_reg_a0; logic [7:0] L1_reg_tmp_a0; </span><span class="tlx_comments">//_/src
               // Src1
               </span><span class="tlx_logic">assign L1_is_reg_a0 = L1_FETCH_Instr_Src[src].L1_char_a0 &gt;= &quot;a&quot; &amp;&amp; L1_FETCH_Instr_Src[src].L1_char_a0 &lt;= &quot;h&quot;;
               assign L1_reg_tmp_a0[7:0] = L1_FETCH_Instr_Src[src].L1_char_a0 - &quot;a&quot;;
               assign L1_reg_a0[2:0] = L1_reg_tmp_a0[2:0];
               assign L1_is_imm_a0 = L1_FETCH_Instr_Src[src].L1_char_a0 &gt;= &quot;0&quot; &amp;&amp; L1_FETCH_Instr_Src[src].L1_char_a0 &lt; &quot;8&quot;;
               assign L1_imm_tmp_a0[7:0] = L1_FETCH_Instr_Src[src].L1_char_a0 - &quot;0&quot;;
               assign L1_imm_value_a0[2:0] = L1_imm_tmp_a0[2:0];
               assign FETCH_Instr_Src_illegal_a0[src] = !(L1_is_reg_a0 || L1_is_imm_a0); </span><span class="tlx_structure">end

            </span><span class="tlx_comments">// Opcode:
            //_/op
               </span><span class="tlx_logic">assign FETCH_Instr_Op_char_a0[7:0] = FETCH_Instr_op_char_a0;
               </span><span class="tlx_comments">// Arithmetic
               </span><span class="tlx_logic">assign FETCH_Instr_Op_add_a0 = FETCH_Instr_Op_char_a0 == &quot;+&quot;;
               assign FETCH_Instr_Op_sub_a0 = FETCH_Instr_Op_char_a0 == &quot;-&quot;;
               assign FETCH_Instr_Op_mul_a0 = FETCH_Instr_Op_char_a0 == &quot;*&quot;;
               assign FETCH_Instr_Op_div_a0 = FETCH_Instr_Op_char_a0 == &quot;/&quot;;
               </span><span class="tlx_comments">// Compare and bool (w/ 1 bit rslt)
               </span><span class="tlx_logic">assign FETCH_Instr_Op_eq_a0 = FETCH_Instr_Op_char_a0 == &quot;=&quot;;
               assign FETCH_Instr_Op_ne_a0 = FETCH_Instr_Op_char_a0 == &quot;!&quot;;
               assign FETCH_Instr_Op_lt_a0 = FETCH_Instr_Op_char_a0 == &quot;&lt;&quot;;
               assign FETCH_Instr_Op_gt_a0 = FETCH_Instr_Op_char_a0 == &quot;&gt;&quot;;
               assign FETCH_Instr_Op_le_a0 = FETCH_Instr_Op_char_a0 == &quot;[&quot;;
               assign FETCH_Instr_Op_ge_a0 = FETCH_Instr_Op_char_a0 == &quot;]&quot;;
               assign FETCH_Instr_Op_and_a0 = FETCH_Instr_Op_char_a0 == &quot;&amp;&quot;;
               assign FETCH_Instr_Op_or_a0 = FETCH_Instr_Op_char_a0 == &quot;|&quot;;
               </span><span class="tlx_comments">// Wide Immediate
               </span><span class="tlx_logic">assign FETCH_Instr_Op_wide_imm_a0 = FETCH_Instr_Op_char_a0 == &quot;~&quot;;
               assign FETCH_Instr_Op_combine_a0 = FETCH_Instr_Op_char_a0 == &quot;,&quot;;
               </span><span class="tlx_comments">// Conditional
               </span><span class="tlx_logic">assign FETCH_Instr_Op_conditional_a0 = FETCH_Instr_Op_char_a0 == &quot;?&quot;;
               </span><span class="tlx_comments">// Memory
               </span><span class="tlx_logic">assign FETCH_Instr_Op_ld_a0 = FETCH_Instr_Op_char_a0 == &quot;{&quot;;
               assign FETCH_Instr_Op_st_a0 = FETCH_Instr_Op_char_a0 == &quot;}&quot;;
               </span><span class="tlx_comments">// Opcode classes:
               </span><span class="tlx_logic">assign FETCH_Instr_Op_arith_a0 = FETCH_Instr_Op_add_a0 || FETCH_Instr_Op_sub_a0 || FETCH_Instr_Op_mul_a0 || FETCH_Instr_Op_div_a0;
               assign FETCH_Instr_Op_compare_a0 = FETCH_Instr_Op_eq_a0 || FETCH_Instr_Op_ne_a0 || FETCH_Instr_Op_lt_a0 || FETCH_Instr_Op_gt_a0 || FETCH_Instr_Op_le_a0 || FETCH_Instr_Op_ge_a0;
               assign FETCH_Instr_Op_bitwise_a0 = FETCH_Instr_Op_and_a0 || FETCH_Instr_Op_or_a0;
               assign FETCH_Instr_Op_full_a0 = FETCH_Instr_Op_arith_a0 || FETCH_Instr_Op_bitwise_a0 || FETCH_Instr_Op_wide_imm_a0 || FETCH_Instr_Op_combine_a0 || FETCH_Instr_Op_conditional_a0;
               </span><span class="tlx_comments">//$op3 = $compare || $full;
               </span><span class="tlx_logic">assign FETCH_Instr_Op_mem_a0 = FETCH_Instr_Op_ld_a0 || FETCH_Instr_Op_st_a0;
               assign FETCH_Instr_Op_illegal_a0 = !(FETCH_Instr_Op_compare_a0 || FETCH_Instr_Op_full_a0 || FETCH_Instr_Op_mem_a0);
            assign FETCH_Instr_op_compare_a0 = FETCH_Instr_Op_compare_a0;
            assign FETCH_Instr_op_full_a0 = FETCH_Instr_Op_full_a0;
            assign FETCH_Instr_ld_a0 = FETCH_Instr_Op_ld_a0;
            assign FETCH_Instr_st_a0 = FETCH_Instr_Op_st_a0;
            assign FETCH_Instr_illegal_a0 = FETCH_Instr_illegal_dest_a0 || (| FETCH_Instr_Src_illegal_a0) || FETCH_Instr_Op_illegal_a0;
            
            </span><span class="tlx_comments">// ======
            // Reg Rd
            // ======
            
            </span><span class="tlx_structure">for (src = 1; src &lt;= 2; src++) begin : L1c_FETCH_Instr_Src </span><span class="tlx_declarations">logic L1_local_is_reg_a0; logic [11:0] L1_reg_value_a0; logic L1_valid_a0; logic [11:0] L1_value_a0; </span><span class="tlx_comments">//_/src
               </span><span class="tlx_logic">assign L1_local_is_reg_a0 = L1b_FETCH_Instr_Src[src].L1_is_reg_a0;
               </span><span class="tlx_comments">//_?$local_is_reg
                  </span><span class="tlx_logic">assign L1_reg_value_a0[11:0] = FETCH_Instr_Reg_Value_a0[L1b_FETCH_Instr_Src[src].L1_reg_a0];
               assign L1_valid_a0 = !FETCH_Instr_Src_illegal_a0[src];
               </span><span class="tlx_comments">//_?$valid
                  </span><span class="tlx_logic">assign L1_value_a0[11:0] = L1b_FETCH_Instr_Src[src].L1_is_reg_a0      ? L1_reg_value_a0 :
                                                {9'b0, L1b_FETCH_Instr_Src[src].L1_imm_value_a0}; </span><span class="tlx_structure">end </span><span class="tlx_comments">// $is_imm
            
            
            // =======
            // Execute
            // =======
            
            //_?$op_compare
               </span><span class="tlx_logic">assign FETCH_Instr_compare_rslt_a0 =
                  FETCH_Instr_Op_eq_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 == L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_ne_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 != L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_lt_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 &lt; L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_gt_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 &gt; L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_le_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 &lt;= L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_ge_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 &gt;= L1c_FETCH_Instr_Src[2].L1_value_a0 :
                           1'b0;
            </span><span class="tlx_comments">//_?$op_full
               </span><span class="tlx_logic">assign FETCH_Instr_op_full_rslt_a0[11:0] =
                  FETCH_Instr_Op_add_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 + L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_sub_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 - L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_mul_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 * L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_div_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 * L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_and_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 &amp; L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_or_a0 ? L1c_FETCH_Instr_Src[1].L1_value_a0 | L1c_FETCH_Instr_Src[2].L1_value_a0 :
                  FETCH_Instr_Op_wide_imm_a0 ? {6'b0, L1c_FETCH_Instr_Src[1].L1_value_a0[2:0], L1c_FETCH_Instr_Src[2].L1_value_a0[2:0]} :
                  FETCH_Instr_Op_combine_a0 ? {L1c_FETCH_Instr_Src[1].L1_value_a0[5:0], L1c_FETCH_Instr_Src[2].L1_value_a0[5:0]} :
                  FETCH_Instr_Op_conditional_a0 ? (L1c_FETCH_Instr_Src[2].L1_value_a0[11] ? 12'b0 : L1c_FETCH_Instr_Src[1].L1_value_a0) :
                                    12'b0;
            
            </span><span class="tlx_comments">// =======
            // Next PC
            // =======
            
            // Jump (Dest = &quot;P&quot;) and Branch (Dest = &quot;p&quot;) Targets.
            //_?$jump
               </span><span class="tlx_logic">assign FETCH_Instr_jump_target_a0[11:0] = FETCH_Instr_rslt_a0;
            </span><span class="tlx_comments">//_?$branch
               </span><span class="tlx_logic">assign FETCH_Instr_branch_target_a0[11:0] = FETCH_Instr_Pc_a0 + 12'b1 + FETCH_Instr_rslt_a0;
            
            </span><span class="tlx_comments">//?$fetch_or_reset
            </span><span class="tlx_logic">assign FETCH_Instr_Pc_n1[11:0] =
               FETCH_Instr_reset_a0 ? 0 :
               FETCH_Instr_jump_a0  ? FETCH_Instr_jump_target_a0 :
               FETCH_Instr_branch_a0 ? FETCH_Instr_branch_target_a0 :
               </span><span class="tlx_comments">//$stall ? $RETAIN :
                        </span><span class="tlx_logic">FETCH_Instr_Pc_a0 + 12'b1;
            
            </span><span class="tlx_comments">// ?$fetch
            
            // ====
            // Load
            // ====
            
            //_?$ld
               </span><span class="tlx_logic">assign FETCH_Instr_addr_a0[11:0] = L1c_FETCH_Instr_Src[1].L1_value_a0 + L1c_FETCH_Instr_Src[2].L1_value_a0;
               assign FETCH_Instr_ld_rslt_a0[11:0] = FETCH_Instr_Mem_Word_a0[FETCH_Instr_addr_a0[4:0]];
            
            </span><span class="tlx_comments">// =========
            // Reg Write
            // =========
            
            //_?$dest_valid
               </span><span class="tlx_logic">assign FETCH_Instr_rslt_a0[11:0] =
                  FETCH_Instr_op_full_a0 ? FETCH_Instr_op_full_rslt_a0 :
                  FETCH_Instr_op_compare_a0 ? {12{FETCH_Instr_compare_rslt_a0}} :
                  FETCH_Instr_ld_a0 ? FETCH_Instr_ld_rslt_a0 :
                        12'b0;
               
         </span><span class="tlx_comments">// Array writes are not currently permitted to use assignment
         // syntax, so \always_comb is used, and this must be outside of
         // when conditions, so we need to use if. &lt;&lt;1 because no &lt;= support
         // in this context. (This limitation will be lifted.)
         //_/instr
            // Store mem write.
            //_/mem
            </span><span class="tlx_logic">always_comb begin
               if (FETCH_Instr_st_a0) </span><span class="tlx_comments">// &amp;&amp; $fetch
                  </span><span class="tlx_logic">FETCH_Instr_Mem_Word_n1[L1c_FETCH_Instr_Src[2].L1_value_a0[4:0]][11:0] = L1c_FETCH_Instr_Src[1].L1_value_a0; </span><span class="tlx_structure">end
            </span><span class="tlx_comments">// Reg file write.
            //_/reg
            </span><span class="tlx_logic">always_comb begin
               if (FETCH_Instr_dest_is_reg_a0) </span><span class="tlx_comments">// &amp;&amp; $fetch
                  </span><span class="tlx_logic">FETCH_Instr_Reg_Value_n1[FETCH_Instr_dest_reg_a0][11:0] = FETCH_Instr_rslt_a0; </span><span class="tlx_structure">end
            
            
   </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">assign passed = ! reset &amp;&amp; cyc_cnt &gt; 1000 || FETCH_Instr_Pc_a3 == 12'hfff;
   assign failed = ! reset &amp;&amp; ! FETCH_Instr_reset_a3 &amp;&amp; FETCH_Instr_illegal_a3; </span><span class="tlx_structure">endgenerate
</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"


genvar mem, src, v_reg;


//
// Signals declared top-level.
//

// For $reset.
logic L0_reset_a0;

// For |fetch/instr$Pc.
logic [11:0] FETCH_Instr_Pc_n1,
             FETCH_Instr_Pc_a0,
             FETCH_Instr_Pc_a1,
             FETCH_Instr_Pc_a2,
             FETCH_Instr_Pc_a3;

// For |fetch/instr$addr.
logic [11:0] FETCH_Instr_addr_a0;

// For |fetch/instr$branch.
logic FETCH_Instr_branch_a0;

// For |fetch/instr$branch_target.
logic [11:0] FETCH_Instr_branch_target_a0;

// For |fetch/instr$compare_rslt.
logic FETCH_Instr_compare_rslt_a0;

// For |fetch/instr$dest_char.
logic [7:0] FETCH_Instr_dest_char_a0;

// For |fetch/instr$dest_is_reg.
logic FETCH_Instr_dest_is_reg_a0;

// For |fetch/instr$dest_reg.
logic [2:0] FETCH_Instr_dest_reg_a0;

// For |fetch/instr$dest_tmp.
logic [7:0] FETCH_Instr_dest_tmp_a0;

// For |fetch/instr$dest_valid.
logic FETCH_Instr_dest_valid_a0;

// For |fetch/instr$illegal.
logic FETCH_Instr_illegal_a0,
      FETCH_Instr_illegal_a1,
      FETCH_Instr_illegal_a2,
      FETCH_Instr_illegal_a3;

// For |fetch/instr$illegal_dest.
logic FETCH_Instr_illegal_dest_a0;

// For |fetch/instr$jump.
logic FETCH_Instr_jump_a0;

// For |fetch/instr$jump_target.
logic [11:0] FETCH_Instr_jump_target_a0;

// For |fetch/instr$ld.
logic FETCH_Instr_ld_a0;

// For |fetch/instr$ld_rslt.
logic [11:0] FETCH_Instr_ld_rslt_a0;

// For |fetch/instr$no_dest.
logic FETCH_Instr_no_dest_a0;

// For |fetch/instr$op_char.
logic [7:0] FETCH_Instr_op_char_a0;

// For |fetch/instr$op_compare.
logic FETCH_Instr_op_compare_a0;

// For |fetch/instr$op_full.
logic FETCH_Instr_op_full_a0;

// For |fetch/instr$op_full_rslt.
logic [11:0] FETCH_Instr_op_full_rslt_a0;

// For |fetch/instr$raw.
logic [39:0] FETCH_Instr_raw_a0;

// For |fetch/instr$reset.
logic FETCH_Instr_reset_a0,
      FETCH_Instr_reset_a1,
      FETCH_Instr_reset_a2,
      FETCH_Instr_reset_a3;

// For |fetch/instr$rslt.
logic [11:0] FETCH_Instr_rslt_a0;

// For |fetch/instr$st.
logic FETCH_Instr_st_a0;

// For |fetch/instr$write_pc.
logic FETCH_Instr_write_pc_a0;

// For |fetch/instr/mem$Word.
logic [11:0] FETCH_Instr_Mem_Word_n1 [31:0],
             FETCH_Instr_Mem_Word_a0 [31:0];

// For |fetch/instr/op$add.
logic FETCH_Instr_Op_add_a0;

// For |fetch/instr/op$and.
logic FETCH_Instr_Op_and_a0;

// For |fetch/instr/op$arith.
logic FETCH_Instr_Op_arith_a0;

// For |fetch/instr/op$bitwise.
logic FETCH_Instr_Op_bitwise_a0;

// For |fetch/instr/op$char.
logic [7:0] FETCH_Instr_Op_char_a0;

// For |fetch/instr/op$combine.
logic FETCH_Instr_Op_combine_a0;

// For |fetch/instr/op$compare.
logic FETCH_Instr_Op_compare_a0;

// For |fetch/instr/op$conditional.
logic FETCH_Instr_Op_conditional_a0;

// For |fetch/instr/op$div.
logic FETCH_Instr_Op_div_a0;

// For |fetch/instr/op$eq.
logic FETCH_Instr_Op_eq_a0;

// For |fetch/instr/op$full.
logic FETCH_Instr_Op_full_a0;

// For |fetch/instr/op$ge.
logic FETCH_Instr_Op_ge_a0;

// For |fetch/instr/op$gt.
logic FETCH_Instr_Op_gt_a0;

// For |fetch/instr/op$illegal.
logic FETCH_Instr_Op_illegal_a0;

// For |fetch/instr/op$ld.
logic FETCH_Instr_Op_ld_a0;

// For |fetch/instr/op$le.
logic FETCH_Instr_Op_le_a0;

// For |fetch/instr/op$lt.
logic FETCH_Instr_Op_lt_a0;

// For |fetch/instr/op$mem.
logic FETCH_Instr_Op_mem_a0;

// For |fetch/instr/op$mul.
logic FETCH_Instr_Op_mul_a0;

// For |fetch/instr/op$ne.
logic FETCH_Instr_Op_ne_a0;

// For |fetch/instr/op$or.
logic FETCH_Instr_Op_or_a0;

// For |fetch/instr/op$st.
logic FETCH_Instr_Op_st_a0;

// For |fetch/instr/op$sub.
logic FETCH_Instr_Op_sub_a0;

// For |fetch/instr/op$wide_imm.
logic FETCH_Instr_Op_wide_imm_a0;

// For |fetch/instr/reg$Value.
logic [11:0] FETCH_Instr_Reg_Value_n1 [7:0],
             FETCH_Instr_Reg_Value_a0 [7:0];

// For |fetch/instr/src$illegal.
logic [2:1] FETCH_Instr_Src_illegal_a0;



generate


   //
   // Scope: |fetch
   //


      //
      // Scope: /instr
      //

         // For $Pc.
         always_ff @(posedge clk) FETCH_Instr_Pc_a0[11:0] <= FETCH_Instr_Pc_n1[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a1[11:0] <= FETCH_Instr_Pc_a0[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a2[11:0] <= FETCH_Instr_Pc_a1[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a3[11:0] <= FETCH_Instr_Pc_a2[11:0];

         // For $illegal.
         always_ff @(posedge clk) FETCH_Instr_illegal_a1 <= FETCH_Instr_illegal_a0;
         always_ff @(posedge clk) FETCH_Instr_illegal_a2 <= FETCH_Instr_illegal_a1;
         always_ff @(posedge clk) FETCH_Instr_illegal_a3 <= FETCH_Instr_illegal_a2;

         // For $reset.
         always_ff @(posedge clk) FETCH_Instr_reset_a1 <= FETCH_Instr_reset_a0;
         always_ff @(posedge clk) FETCH_Instr_reset_a2 <= FETCH_Instr_reset_a1;
         always_ff @(posedge clk) FETCH_Instr_reset_a3 <= FETCH_Instr_reset_a2;


         //
         // Scope: /mem[31:0]
         //
         for (mem = 0; mem <= 31; mem++) begin : L1gen_FETCH_Instr_Mem
            // For $Word.
            always_ff @(posedge clk) FETCH_Instr_Mem_Word_a0[mem][11:0] <= FETCH_Instr_Mem_Word_n1[mem][11:0];

         end

         //
         // Scope: /reg[7:0]
         //
         for (v_reg = 0; v_reg <= 7; v_reg++) begin : L1gen_FETCH_Instr_Reg
            // For $Value.
            always_ff @(posedge clk) FETCH_Instr_Reg_Value_a0[v_reg][11:0] <= FETCH_Instr_Reg_Value_n1[v_reg][11:0];

         end




endgenerate




//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      //
      // Scope: |fetch
      //
      if (1) begin : \|fetch 

         //
         // Scope: /instr
         //
         if (1) begin : \/instr 
            logic [11:0] \@-1$Pc ;
            assign \@-1$Pc = FETCH_Instr_Pc_n1;
            logic [11:0] \@0$addr ;
            assign \@0$addr = FETCH_Instr_addr_a0;
            logic  \@0$branch ;
            assign \@0$branch = FETCH_Instr_branch_a0;
            logic [11:0] \@0$branch_target ;
            assign \@0$branch_target = FETCH_Instr_branch_target_a0;
            logic  \@0$compare_rslt ;
            assign \@0$compare_rslt = FETCH_Instr_compare_rslt_a0;
            logic [7:0] \@0$dest_char ;
            assign \@0$dest_char = FETCH_Instr_dest_char_a0;
            logic  \@0$dest_is_reg ;
            assign \@0$dest_is_reg = FETCH_Instr_dest_is_reg_a0;
            logic [2:0] \@0$dest_reg ;
            assign \@0$dest_reg = FETCH_Instr_dest_reg_a0;
            logic [7:0] \@0$dest_tmp ;
            assign \@0$dest_tmp = FETCH_Instr_dest_tmp_a0;
            logic  \@0$dest_valid ;
            assign \@0$dest_valid = FETCH_Instr_dest_valid_a0;
            logic  \@0$illegal ;
            assign \@0$illegal = FETCH_Instr_illegal_a0;
            logic  \@0$illegal_dest ;
            assign \@0$illegal_dest = FETCH_Instr_illegal_dest_a0;
            logic  \@0$jump ;
            assign \@0$jump = FETCH_Instr_jump_a0;
            logic [11:0] \@0$jump_target ;
            assign \@0$jump_target = FETCH_Instr_jump_target_a0;
            logic  \@0$ld ;
            assign \@0$ld = FETCH_Instr_ld_a0;
            logic [11:0] \@0$ld_rslt ;
            assign \@0$ld_rslt = FETCH_Instr_ld_rslt_a0;
            logic  \@0$no_dest ;
            assign \@0$no_dest = FETCH_Instr_no_dest_a0;
            logic [7:0] \@0$op_char ;
            assign \@0$op_char = FETCH_Instr_op_char_a0;
            logic  \@0$op_compare ;
            assign \@0$op_compare = FETCH_Instr_op_compare_a0;
            logic  \@0$op_full ;
            assign \@0$op_full = FETCH_Instr_op_full_a0;
            logic [11:0] \@0$op_full_rslt ;
            assign \@0$op_full_rslt = FETCH_Instr_op_full_rslt_a0;
            logic [39:0] \@0$raw ;
            assign \@0$raw = FETCH_Instr_raw_a0;
            logic  \@0$reset ;
            assign \@0$reset = FETCH_Instr_reset_a0;
            logic [11:0] \@0$rslt ;
            assign \@0$rslt = FETCH_Instr_rslt_a0;
            logic  \@0$st ;
            assign \@0$st = FETCH_Instr_st_a0;
            logic  \@0$write_pc ;
            assign \@0$write_pc = FETCH_Instr_write_pc_a0;

            //
            // Scope: /mem[31:0]
            //
            for (mem = 0; mem <= 31; mem++) begin : \/mem 
               logic [11:0] \@-1$Word ;
               assign \@-1$Word = FETCH_Instr_Mem_Word_n1[mem];
            end

            //
            // Scope: /op
            //
            if (1) begin : \/op 
               logic  \@0$add ;
               assign \@0$add = FETCH_Instr_Op_add_a0;
               logic  \@0$and ;
               assign \@0$and = FETCH_Instr_Op_and_a0;
               logic  \@0$arith ;
               assign \@0$arith = FETCH_Instr_Op_arith_a0;
               logic  \@0$bitwise ;
               assign \@0$bitwise = FETCH_Instr_Op_bitwise_a0;
               logic [7:0] \@0$char ;
               assign \@0$char = FETCH_Instr_Op_char_a0;
               logic  \@0$combine ;
               assign \@0$combine = FETCH_Instr_Op_combine_a0;
               logic  \@0$compare ;
               assign \@0$compare = FETCH_Instr_Op_compare_a0;
               logic  \@0$conditional ;
               assign \@0$conditional = FETCH_Instr_Op_conditional_a0;
               logic  \@0$div ;
               assign \@0$div = FETCH_Instr_Op_div_a0;
               logic  \@0$eq ;
               assign \@0$eq = FETCH_Instr_Op_eq_a0;
               logic  \@0$full ;
               assign \@0$full = FETCH_Instr_Op_full_a0;
               logic  \@0$ge ;
               assign \@0$ge = FETCH_Instr_Op_ge_a0;
               logic  \@0$gt ;
               assign \@0$gt = FETCH_Instr_Op_gt_a0;
               logic  \@0$illegal ;
               assign \@0$illegal = FETCH_Instr_Op_illegal_a0;
               logic  \@0$ld ;
               assign \@0$ld = FETCH_Instr_Op_ld_a0;
               logic  \@0$le ;
               assign \@0$le = FETCH_Instr_Op_le_a0;
               logic  \@0$lt ;
               assign \@0$lt = FETCH_Instr_Op_lt_a0;
               logic  \@0$mem ;
               assign \@0$mem = FETCH_Instr_Op_mem_a0;
               logic  \@0$mul ;
               assign \@0$mul = FETCH_Instr_Op_mul_a0;
               logic  \@0$ne ;
               assign \@0$ne = FETCH_Instr_Op_ne_a0;
               logic  \@0$or ;
               assign \@0$or = FETCH_Instr_Op_or_a0;
               logic  \@0$st ;
               assign \@0$st = FETCH_Instr_Op_st_a0;
               logic  \@0$sub ;
               assign \@0$sub = FETCH_Instr_Op_sub_a0;
               logic  \@0$wide_imm ;
               assign \@0$wide_imm = FETCH_Instr_Op_wide_imm_a0;
            end

            //
            // Scope: /reg[7:0]
            //
            for (v_reg = 0; v_reg <= 7; v_reg++) begin : \/reg 
               logic [11:0] \@-1$Value ;
               assign \@-1$Value = FETCH_Instr_Reg_Value_n1[v_reg];
            end

            //
            // Scope: /src[2:1]
            //
            for (src = 1; src <= 2; src++) begin : \/src 
               logic [7:0] \@0$char ;
               assign \@0$char = L1_FETCH_Instr_Src[src].L1_char_a0;
               logic  \@0$illegal ;
               assign \@0$illegal = FETCH_Instr_Src_illegal_a0[src];
               logic [7:0] \@0$imm_tmp ;
               assign \@0$imm_tmp = L1b_FETCH_Instr_Src[src].L1_imm_tmp_a0;
               logic [2:0] \@0$imm_value ;
               assign \@0$imm_value = L1b_FETCH_Instr_Src[src].L1_imm_value_a0;
               logic  \@0$is_imm ;
               assign \@0$is_imm = L1b_FETCH_Instr_Src[src].L1_is_imm_a0;
               logic  \@0$is_reg ;
               assign \@0$is_reg = L1b_FETCH_Instr_Src[src].L1_is_reg_a0;
               logic  \@0$local_is_reg ;
               assign \@0$local_is_reg = L1c_FETCH_Instr_Src[src].L1_local_is_reg_a0;
               logic [2:0] \@0$reg ;
               assign \@0$reg = L1b_FETCH_Instr_Src[src].L1_reg_a0;
               logic [7:0] \@0$reg_tmp ;
               assign \@0$reg_tmp = L1b_FETCH_Instr_Src[src].L1_reg_tmp_a0;
               logic [11:0] \@0$reg_value ;
               assign \@0$reg_value = L1c_FETCH_Instr_Src[src].L1_reg_value_a0;
               logic  \@0$valid ;
               assign \@0$valid = L1c_FETCH_Instr_Src[src].L1_valid_a0;
               logic [11:0] \@0$value ;
               assign \@0$value = L1c_FETCH_Instr_Src[src].L1_value_a0;
            end
         end
      end


   end

endgenerate




generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.

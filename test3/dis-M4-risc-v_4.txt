3c3
< `include "sp_default.vh" //_\source warp-v_risc-v_4-stage.tlv 5
---
> `include "sp_default.vh" //_\source warp-v_risc-v_4-stage.tlv 6
7,9d6
< `include "out/sv_url_inc/picorv32_pcpi_div.sv"  // From: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/master/divmul/picorv32_pcpi_div.sv"
< `include "out/sv_url_inc/picorv32_pcpi_fast_mul.sv"  // From: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/master/divmul/picorv32_pcpi_fast_mul.sv"
< 
12c9
< //_\source warp-v_risc-v_4-stage.tlv 9
---
> //_\source warp-v_risc-v_4-stage.tlv 10
14,15c11
< 
<    //_\source ./warpv.tlv 3556   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+warpv()
---
>    //_\source ./warpv.tlv 3556   // Instantiated from warp-v_risc-v_4-stage.tlv, 12 as: m4+warpv()
283,289c279,280
<                //_\source <builtin> 1   // Instantiated from warp-v_risc-v_4-stage.tlv, 1290 as: m4+indirect(['riscv_']divmul_test['_prog'])
<                   //_\source ./warpv.tlv 1209   // Instantiated from built-in definition.
<                      // /==========================\
<                      // | M-extension Test Program |
<                      // \==========================/
<                      //
<                      //3 MULs followed by 3 DIVs, check r11-r15 for correct results
---
>                //_\source <builtin> 1   // Instantiated from warp-v_risc-v_4-stage.tlv, 1290 as: m4+indirect(['riscv_']cnt10['_prog'])
>                   //_\source ./warpv.tlv 1179   // Instantiated from built-in definition.
291,306c282,308
<                      // Inst #0: ORI,r8,r0,1011
<                      // Inst #1: ORI,r9,r0,1010
<                      // Inst #2: ORI,r10,r0,10101010
<                      // Inst #3: MUL,r11,r8,r9
<                      // Inst #4: ORI,r6,r0,0
<                      // Inst #5: SW,r6,r11,0
<                      // Inst #6: MUL,r12,r9,r10
<                      // Inst #7: LW,r4,r6,0
<                      // Inst #8: ADDI,r6,r6,100
<                      // Inst #9: SW,r6,r12,0
<                      // Inst #10: MUL,r13,r8,r10
<                      // Inst #11: DIV,r14,r11,r8
<                      // Inst #12: DIV,r15,r13,r10
<                      // Inst #13: LW,r5,r6,0
<                      // Inst #14: ADDI,r4,r0,101101
<                      // Inst #15: BGE,r8,r9,111111111110
---
>                      // /=====================\
>                      // | Count to 10 Program |
>                      // \=====================/
>                      //
>                      // Default program for RV32I test
>                      // Add 1,2,3,...,9 (in that order).
>                      // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
>                      //
>                      // Regs:
>                      // 1: cnt
>                      // 2: ten
>                      // 3: out
>                      // 4: tmp
>                      // 5: offset
>                      // 6: store addr
>                    
>                      // Inst #0: ORI,r6,r0,0        //     store_addr = 0
>                      // Inst #1: ORI,r1,r0,1        //     cnt = 1
>                      // Inst #2: ORI,r2,r0,1010     //     ten = 10
>                      // Inst #3: ORI,r3,r0,0        //     out = 0
>                      // Inst #4: ADD,r3,r1,r3       //  -> out += cnt
>                      // Inst #5: SW,r6,r3,0         //     store out at store_addr
>                      // Inst #6: ADDI,r1,r1,1       //     cnt ++
>                      // Inst #7: ADDI,r6,r6,100     //     store_addr++
>                      // Inst #8: BLT,r1,r2,1111111110000 //  ^- branch back if cnt < 10
>                      // Inst #9: LW,r4,r6,111111111100 //     load the final value into tmp
>                      // Inst #10: BGE,r1,r2,1111111010100 //     TERMINATE by branching to -1
346c348
<                   for (instr_mem = 0; instr_mem <= 16-1; instr_mem++) begin : L1_FETCH_InstrMem //_/instr_mem
---
>                   for (instr_mem = 0; instr_mem <= 11-1; instr_mem++) begin : L1_FETCH_InstrMem //_/instr_mem
350c352
<                             (instr_mem == 0) ? {12'b1011, 5'd0, 3'b110, 5'd8, 7'b0010011} : (instr_mem == 1) ? {12'b1010, 5'd0, 3'b110, 5'd9, 7'b0010011} : (instr_mem == 2) ? {12'b10101010, 5'd0, 3'b110, 5'd10, 7'b0010011} : (instr_mem == 3) ? {7'b0000001, 5'd9, 5'd8, 3'b000, 5'd11, 7'b0110011} : (instr_mem == 4) ? {12'b0, 5'd0, 3'b110, 5'd6, 7'b0010011} : (instr_mem == 5) ? {7'b0000000, 5'd11, 5'd6, 3'b010, 5'b00000, 7'b0100011} : (instr_mem == 6) ? {7'b0000001, 5'd10, 5'd9, 3'b000, 5'd12, 7'b0110011} : (instr_mem == 7) ? {12'b0, 5'd6, 3'b010, 5'd4, 7'b0000011} : (instr_mem == 8) ? {12'b100, 5'd6, 3'b000, 5'd6, 7'b0010011} : (instr_mem == 9) ? {7'b0000000, 5'd12, 5'd6, 3'b010, 5'b00000, 7'b0100011} : (instr_mem == 10) ? {7'b0000001, 5'd10, 5'd8, 3'b000, 5'd13, 7'b0110011} : (instr_mem == 11) ? {7'b0000001, 5'd8, 5'd11, 3'b100, 5'd14, 7'b0110011} : (instr_mem == 12) ? {7'b0000001, 5'd10, 5'd13, 3'b100, 5'd15, 7'b0110011} : (instr_mem == 13) ? {12'b0, 5'd6, 3'b010, 5'd5, 7'b0000011} : (instr_mem == 14) ? {12'b101101, 5'd0, 3'b000, 5'd4, 7'b0010011} : (instr_mem == 15) ? {1'b0, 6'b111111, 5'd9, 5'd8, 3'b101, 4'b1111, 1'b1, 7'b1100011} : 32'b0; end
---
>                             (instr_mem == 0) ? {12'b0, 5'd0, 3'b110, 5'd6, 7'b0010011} : (instr_mem == 1) ? {12'b1, 5'd0, 3'b110, 5'd1, 7'b0010011} : (instr_mem == 2) ? {12'b1010, 5'd0, 3'b110, 5'd2, 7'b0010011} : (instr_mem == 3) ? {12'b0, 5'd0, 3'b110, 5'd3, 7'b0010011} : (instr_mem == 4) ? {7'b0000000, 5'd3, 5'd1, 3'b000, 5'd3, 7'b0110011} : (instr_mem == 5) ? {7'b0000000, 5'd3, 5'd6, 3'b010, 5'b00000, 7'b0100011} : (instr_mem == 6) ? {12'b1, 5'd1, 3'b000, 5'd1, 7'b0010011} : (instr_mem == 7) ? {12'b100, 5'd6, 3'b000, 5'd6, 7'b0010011} : (instr_mem == 8) ? {1'b1, 6'b111111, 5'd2, 5'd1, 3'b100, 4'b1000, 1'b1, 7'b1100011} : (instr_mem == 9) ? {12'b111111111100, 5'd6, 3'b010, 5'd4, 7'b0000011} : (instr_mem == 10) ? {1'b1, 6'b111110, 5'd2, 5'd1, 3'b101, 4'b1010, 1'b1, 7'b1100011} : 32'b0; end
548c550
<                   assign FETCH_Instr_second_issue_a0 = FETCH_Instr_second_issue_ld_a0 || FETCH_Instr_second_issue_div_mul_a0 ;
---
>                   assign FETCH_Instr_second_issue_a0 = FETCH_Instr_second_issue_ld_a0  ;
560c562
<                         assign {FETCH_Instr_OrigInst_dest_reg_a0[4:0]} = FETCH_Instr_second_issue_ld_a0 ? {FETCH_Instr_OrigLoadInst_dest_reg_a0} : FETCH_Instr_second_issue_div_mul_a0 ? {FETCH_Instr_HoldInst_dest_reg_a3} :  {FETCH_Instr_OrigLoadInst_dest_reg_a0};
---
>                         assign {FETCH_Instr_OrigInst_dest_reg_a0[4:0]} = FETCH_Instr_second_issue_ld_a0 ? {FETCH_Instr_OrigLoadInst_dest_reg_a0} :   {FETCH_Instr_OrigLoadInst_dest_reg_a0};
562c564
<                            assign {L1_dummy_a0} = FETCH_Instr_second_issue_ld_a0 ? {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0} : FETCH_Instr_second_issue_div_mul_a0 ? {L1_FETCH_Instr_HoldInst_Src[src].L1_dummy_a3} :  {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0}; end
---
>                            assign {L1_dummy_a0} = FETCH_Instr_second_issue_ld_a0 ? {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0} :   {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0}; end
660,667d661
<                               assign FETCH_Instr_is_mul_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b000 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000001;
<                               assign FETCH_Instr_is_mulh_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b001 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000001;
<                               assign FETCH_Instr_is_mulhsu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b010 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000001;
<                               assign FETCH_Instr_is_mulhu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b011 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000001;
<                               assign FETCH_Instr_is_div_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b100 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000001;
<                               assign FETCH_Instr_is_divu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000001;
<                               assign FETCH_Instr_is_rem_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b110 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000001;
<                               assign FETCH_Instr_is_remu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b111 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000001;
672,675d665
<                            // Instruction requires integer mul/div unit and is long-latency.
<                            assign FETCH_Instr_divtype_instr_a1 = (FETCH_Instr_is_div_instr_a1 || FETCH_Instr_is_divu_instr_a1 || FETCH_Instr_is_rem_instr_a1 || FETCH_Instr_is_remu_instr_a1);
<                            assign FETCH_Instr_multype_instr_a1 = (FETCH_Instr_is_mul_instr_a1 || FETCH_Instr_is_mulh_instr_a1 || FETCH_Instr_is_mulhsu_instr_a1 || FETCH_Instr_is_mulhu_instr_a1);
<                            assign FETCH_Instr_div_mul_a1       = (FETCH_Instr_multype_instr_a1 || FETCH_Instr_divtype_instr_a1);
680a671,674
>                            assign FETCH_Instr_div_mul_a1 = 1'b0;
>                            assign FETCH_Instr_multype_instr_a1 = 1'b0;
>                            `BOGUS_USE(FETCH_Instr_multype_instr_a1)
>                            
727c721
<                            assign FETCH_Instr_illegal_a1 = (FETCH_Instr_illegal_itype_with_funct7_a1 && ! FETCH_Instr_is_lui_instr_a1 && ! FETCH_Instr_is_auipc_instr_a1 && ! FETCH_Instr_is_jal_instr_a1 && ! FETCH_Instr_is_jalr_instr_a1 && ! FETCH_Instr_is_beq_instr_a1 && ! FETCH_Instr_is_bne_instr_a1 && ! FETCH_Instr_is_blt_instr_a1 && ! FETCH_Instr_is_bge_instr_a1 && ! FETCH_Instr_is_bltu_instr_a1 && ! FETCH_Instr_is_bgeu_instr_a1 && ! FETCH_Instr_is_lb_instr_a1 && ! FETCH_Instr_is_lh_instr_a1 && ! FETCH_Instr_is_lw_instr_a1 && ! FETCH_Instr_is_lbu_instr_a1 && ! FETCH_Instr_is_lhu_instr_a1 && ! FETCH_Instr_is_sb_instr_a1 && ! FETCH_Instr_is_sh_instr_a1 && ! FETCH_Instr_is_sw_instr_a1 && ! FETCH_Instr_is_addi_instr_a1 && ! FETCH_Instr_is_slti_instr_a1 && ! FETCH_Instr_is_sltiu_instr_a1 && ! FETCH_Instr_is_xori_instr_a1 && ! FETCH_Instr_is_ori_instr_a1 && ! FETCH_Instr_is_andi_instr_a1 && ! FETCH_Instr_is_slli_instr_a1 && ! FETCH_Instr_is_srli_instr_a1 && ! FETCH_Instr_is_srai_instr_a1 && ! FETCH_Instr_is_add_instr_a1 && ! FETCH_Instr_is_sub_instr_a1 && ! FETCH_Instr_is_sll_instr_a1 && ! FETCH_Instr_is_slt_instr_a1 && ! FETCH_Instr_is_sltu_instr_a1 && ! FETCH_Instr_is_xor_instr_a1 && ! FETCH_Instr_is_srl_instr_a1 && ! FETCH_Instr_is_sra_instr_a1 && ! FETCH_Instr_is_or_instr_a1 && ! FETCH_Instr_is_and_instr_a1 && ! FETCH_Instr_is_csrrw_instr_a1 && ! FETCH_Instr_is_csrrs_instr_a1 && ! FETCH_Instr_is_csrrc_instr_a1 && ! FETCH_Instr_is_csrrwi_instr_a1 && ! FETCH_Instr_is_csrrsi_instr_a1 && ! FETCH_Instr_is_csrrci_instr_a1 && ! FETCH_Instr_is_mul_instr_a1 && ! FETCH_Instr_is_mulh_instr_a1 && ! FETCH_Instr_is_mulhsu_instr_a1 && ! FETCH_Instr_is_mulhu_instr_a1 && ! FETCH_Instr_is_div_instr_a1 && ! FETCH_Instr_is_divu_instr_a1 && ! FETCH_Instr_is_rem_instr_a1 && ! FETCH_Instr_is_remu_instr_a1) ||
---
>                            assign FETCH_Instr_illegal_a1 = (FETCH_Instr_illegal_itype_with_funct7_a1 && ! FETCH_Instr_is_lui_instr_a1 && ! FETCH_Instr_is_auipc_instr_a1 && ! FETCH_Instr_is_jal_instr_a1 && ! FETCH_Instr_is_jalr_instr_a1 && ! FETCH_Instr_is_beq_instr_a1 && ! FETCH_Instr_is_bne_instr_a1 && ! FETCH_Instr_is_blt_instr_a1 && ! FETCH_Instr_is_bge_instr_a1 && ! FETCH_Instr_is_bltu_instr_a1 && ! FETCH_Instr_is_bgeu_instr_a1 && ! FETCH_Instr_is_lb_instr_a1 && ! FETCH_Instr_is_lh_instr_a1 && ! FETCH_Instr_is_lw_instr_a1 && ! FETCH_Instr_is_lbu_instr_a1 && ! FETCH_Instr_is_lhu_instr_a1 && ! FETCH_Instr_is_sb_instr_a1 && ! FETCH_Instr_is_sh_instr_a1 && ! FETCH_Instr_is_sw_instr_a1 && ! FETCH_Instr_is_addi_instr_a1 && ! FETCH_Instr_is_slti_instr_a1 && ! FETCH_Instr_is_sltiu_instr_a1 && ! FETCH_Instr_is_xori_instr_a1 && ! FETCH_Instr_is_ori_instr_a1 && ! FETCH_Instr_is_andi_instr_a1 && ! FETCH_Instr_is_slli_instr_a1 && ! FETCH_Instr_is_srli_instr_a1 && ! FETCH_Instr_is_srai_instr_a1 && ! FETCH_Instr_is_add_instr_a1 && ! FETCH_Instr_is_sub_instr_a1 && ! FETCH_Instr_is_sll_instr_a1 && ! FETCH_Instr_is_slt_instr_a1 && ! FETCH_Instr_is_sltu_instr_a1 && ! FETCH_Instr_is_xor_instr_a1 && ! FETCH_Instr_is_srl_instr_a1 && ! FETCH_Instr_is_sra_instr_a1 && ! FETCH_Instr_is_or_instr_a1 && ! FETCH_Instr_is_and_instr_a1 && ! FETCH_Instr_is_csrrw_instr_a1 && ! FETCH_Instr_is_csrrs_instr_a1 && ! FETCH_Instr_is_csrrc_instr_a1 && ! FETCH_Instr_is_csrrwi_instr_a1 && ! FETCH_Instr_is_csrrsi_instr_a1 && ! FETCH_Instr_is_csrrci_instr_a1) ||
749c743
<                            assign FETCH_Instr_mnemonic_a1[10*8-1:0] = FETCH_Instr_is_lui_instr_a1 ? "LUI       " : FETCH_Instr_is_auipc_instr_a1 ? "AUIPC     " : FETCH_Instr_is_jal_instr_a1 ? "JAL       " : FETCH_Instr_is_jalr_instr_a1 ? "JALR      " : FETCH_Instr_is_beq_instr_a1 ? "BEQ       " : FETCH_Instr_is_bne_instr_a1 ? "BNE       " : FETCH_Instr_is_blt_instr_a1 ? "BLT       " : FETCH_Instr_is_bge_instr_a1 ? "BGE       " : FETCH_Instr_is_bltu_instr_a1 ? "BLTU      " : FETCH_Instr_is_bgeu_instr_a1 ? "BGEU      " : FETCH_Instr_is_lb_instr_a1 ? "LB        " : FETCH_Instr_is_lh_instr_a1 ? "LH        " : FETCH_Instr_is_lw_instr_a1 ? "LW        " : FETCH_Instr_is_lbu_instr_a1 ? "LBU       " : FETCH_Instr_is_lhu_instr_a1 ? "LHU       " : FETCH_Instr_is_sb_instr_a1 ? "SB        " : FETCH_Instr_is_sh_instr_a1 ? "SH        " : FETCH_Instr_is_sw_instr_a1 ? "SW        " : FETCH_Instr_is_addi_instr_a1 ? "ADDI      " : FETCH_Instr_is_slti_instr_a1 ? "SLTI      " : FETCH_Instr_is_sltiu_instr_a1 ? "SLTIU     " : FETCH_Instr_is_xori_instr_a1 ? "XORI      " : FETCH_Instr_is_ori_instr_a1 ? "ORI       " : FETCH_Instr_is_andi_instr_a1 ? "ANDI      " : FETCH_Instr_is_slli_instr_a1 ? "SLLI      " : FETCH_Instr_is_srli_instr_a1 ? "SRLI      " : FETCH_Instr_is_srai_instr_a1 ? "SRAI      " : FETCH_Instr_is_add_instr_a1 ? "ADD       " : FETCH_Instr_is_sub_instr_a1 ? "SUB       " : FETCH_Instr_is_sll_instr_a1 ? "SLL       " : FETCH_Instr_is_slt_instr_a1 ? "SLT       " : FETCH_Instr_is_sltu_instr_a1 ? "SLTU      " : FETCH_Instr_is_xor_instr_a1 ? "XOR       " : FETCH_Instr_is_srl_instr_a1 ? "SRL       " : FETCH_Instr_is_sra_instr_a1 ? "SRA       " : FETCH_Instr_is_or_instr_a1 ? "OR        " : FETCH_Instr_is_and_instr_a1 ? "AND       " : FETCH_Instr_is_csrrw_instr_a1 ? "CSRRW     " : FETCH_Instr_is_csrrs_instr_a1 ? "CSRRS     " : FETCH_Instr_is_csrrc_instr_a1 ? "CSRRC     " : FETCH_Instr_is_csrrwi_instr_a1 ? "CSRRWI    " : FETCH_Instr_is_csrrsi_instr_a1 ? "CSRRSI    " : FETCH_Instr_is_csrrci_instr_a1 ? "CSRRCI    " : FETCH_Instr_is_mul_instr_a1 ? "MUL       " : FETCH_Instr_is_mulh_instr_a1 ? "MULH      " : FETCH_Instr_is_mulhsu_instr_a1 ? "MULHSU    " : FETCH_Instr_is_mulhu_instr_a1 ? "MULHU     " : FETCH_Instr_is_div_instr_a1 ? "DIV       " : FETCH_Instr_is_divu_instr_a1 ? "DIVU      " : FETCH_Instr_is_rem_instr_a1 ? "REM       " : FETCH_Instr_is_remu_instr_a1 ? "REMU      " :  "ILLEGAL   ";
---
>                            assign FETCH_Instr_mnemonic_a1[10*8-1:0] = FETCH_Instr_is_lui_instr_a1 ? "LUI       " : FETCH_Instr_is_auipc_instr_a1 ? "AUIPC     " : FETCH_Instr_is_jal_instr_a1 ? "JAL       " : FETCH_Instr_is_jalr_instr_a1 ? "JALR      " : FETCH_Instr_is_beq_instr_a1 ? "BEQ       " : FETCH_Instr_is_bne_instr_a1 ? "BNE       " : FETCH_Instr_is_blt_instr_a1 ? "BLT       " : FETCH_Instr_is_bge_instr_a1 ? "BGE       " : FETCH_Instr_is_bltu_instr_a1 ? "BLTU      " : FETCH_Instr_is_bgeu_instr_a1 ? "BGEU      " : FETCH_Instr_is_lb_instr_a1 ? "LB        " : FETCH_Instr_is_lh_instr_a1 ? "LH        " : FETCH_Instr_is_lw_instr_a1 ? "LW        " : FETCH_Instr_is_lbu_instr_a1 ? "LBU       " : FETCH_Instr_is_lhu_instr_a1 ? "LHU       " : FETCH_Instr_is_sb_instr_a1 ? "SB        " : FETCH_Instr_is_sh_instr_a1 ? "SH        " : FETCH_Instr_is_sw_instr_a1 ? "SW        " : FETCH_Instr_is_addi_instr_a1 ? "ADDI      " : FETCH_Instr_is_slti_instr_a1 ? "SLTI      " : FETCH_Instr_is_sltiu_instr_a1 ? "SLTIU     " : FETCH_Instr_is_xori_instr_a1 ? "XORI      " : FETCH_Instr_is_ori_instr_a1 ? "ORI       " : FETCH_Instr_is_andi_instr_a1 ? "ANDI      " : FETCH_Instr_is_slli_instr_a1 ? "SLLI      " : FETCH_Instr_is_srli_instr_a1 ? "SRLI      " : FETCH_Instr_is_srai_instr_a1 ? "SRAI      " : FETCH_Instr_is_add_instr_a1 ? "ADD       " : FETCH_Instr_is_sub_instr_a1 ? "SUB       " : FETCH_Instr_is_sll_instr_a1 ? "SLL       " : FETCH_Instr_is_slt_instr_a1 ? "SLT       " : FETCH_Instr_is_sltu_instr_a1 ? "SLTU      " : FETCH_Instr_is_xor_instr_a1 ? "XOR       " : FETCH_Instr_is_srl_instr_a1 ? "SRL       " : FETCH_Instr_is_sra_instr_a1 ? "SRA       " : FETCH_Instr_is_or_instr_a1 ? "OR        " : FETCH_Instr_is_and_instr_a1 ? "AND       " : FETCH_Instr_is_csrrw_instr_a1 ? "CSRRW     " : FETCH_Instr_is_csrrs_instr_a1 ? "CSRRS     " : FETCH_Instr_is_csrrc_instr_a1 ? "CSRRC     " : FETCH_Instr_is_csrrwi_instr_a1 ? "CSRRWI    " : FETCH_Instr_is_csrrsi_instr_a1 ? "CSRRSI    " : FETCH_Instr_is_csrrci_instr_a1 ? "CSRRCI    " :  "ILLEGAL   ";
752c746
<                         assign FETCH_Instr_dest_reg_a1[4:0] = FETCH_Instr_second_issue_div_mul_a1 ? FETCH_Instr_HoldInst_dest_reg_a4 :
---
>                         assign FETCH_Instr_dest_reg_a1[4:0] = 
887d880
<                      //_\source ./warpv.tlv 2570   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+m_extension()
889,921d881
<                         // RISC-V M-Extension instructions in WARP-V are fixed latency
<                         // As of today, to handle those instructions, WARP-V pipeline is stalled for the given latency, and the
<                         // results are written back through a second issue at the end of stalling duration.
<                         // Verilog modules are inherited from PicoRV32, and are located in the ./muldiv directory.
<                         // Since the modules have a fixed latency, their valid signals are instantiated as valid decode for M-type
<                         // instructions is detected, and results are put in /orig_inst scope to be used in second issue.
<                      
<                         // This macro handles the stalling logic using a counter, and triggers second issue accordingly.
<                      
<                         // latency for division is different for ALTOPS case
<                         
<                              
<                         
<                                // latency for multiplication is 2 cycles in case of ALTOPS,
<                                                                // but we flop it for 5 cycles (in rslt_mux) to augment the normal
<                                                                // second issue behavior
<                      
<                         // Relative to typical 1-cycle latency instructions.
<                      
<                         //_@0
<                            assign FETCH_Instr_second_issue_div_mul_a0 = FETCH_Instr_trigger_next_pc_div_mul_second_issue_a3;
<                         //_@2
<                            assign {FETCH_Instr_div_stall_a2, FETCH_Instr_mul_stall_a2, FETCH_Instr_stall_cnt_a2[5:0]} =    FETCH_Instr_reset_a2 ? '0 :
<                                                                           FETCH_Instr_second_issue_div_mul_a2 ? '0 :
<                                                                           (FETCH_Instr_commit_a2 && FETCH_Instr_div_mul_a2) ? {FETCH_Instr_divtype_instr_a2, FETCH_Instr_multype_instr_a2, 6'b1} :
<                                                                           FETCH_Instr_div_stall_a3 ? {1'b1, 1'b0, FETCH_Instr_stall_cnt_a3 + 6'b1} :
<                                                                           FETCH_Instr_mul_stall_a3 ? {1'b0, 1'b1, FETCH_Instr_stall_cnt_a3 + 6'b1} :
<                                                                           '0;
<                                                                           
<                            assign FETCH_Instr_stall_cnt_upper_mul_a2 = (FETCH_Instr_stall_cnt_a2 == 5);
<                            assign FETCH_Instr_stall_cnt_upper_div_a2 = (FETCH_Instr_stall_cnt_a2 == 37);
<                            assign FETCH_Instr_trigger_next_pc_div_mul_second_issue_a2 = (FETCH_Instr_div_stall_a2 && FETCH_Instr_stall_cnt_upper_div_a2) || (FETCH_Instr_mul_stall_a2 && FETCH_Instr_stall_cnt_upper_mul_a2);
<                      //_\end_source
939,1005c899,907
<                         // Verilog instantiation must happen outside when conditions' scope
<                         assign FETCH_Instr_divblk_valid_a2 = FETCH_Instr_divtype_instr_a2 && FETCH_Instr_commit_a2;
<                         assign FETCH_Instr_mulblk_valid_a2 = FETCH_Instr_multype_instr_a2 && FETCH_Instr_commit_a2;
<                         /* verilator lint_off WIDTH */
<                         /* verilator lint_off CASEINCOMPLETE */   
<                         //_\source ./warpv.tlv 2607   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+warpv_mul(|fetch/instr,/mul1, $mulblock_rslt, $wrm, $waitm, $readym, $clk, $resetn, $mul_in1, $mul_in2, $instr_type_mul, $mulblk_valid)
<                            //_/mul1      
<                               
<                               // instr type is one hot encoding of the required M type instruction
<                               // the idea is to concatenate is_*_instr from WARP-V and pass on to this module
<                                  
<                               assign FETCH_Instr_Mul1_opcode_a2[2:0] = (FETCH_Instr_instr_type_mul_a2 == 4'b0001) ? 3'b000 : // mull 
<                                              (FETCH_Instr_instr_type_mul_a2 == 4'b0010) ? 3'b001 : // mulh
<                                              (FETCH_Instr_instr_type_mul_a2 == 4'b0100) ? 3'b010 : // mulhsu
<                                              (FETCH_Instr_instr_type_mul_a2 == 4'b1000) ? 3'b011 : // mulhu
<                                                                               3'b000 ; // default to mul, but this case 
<                                                                                        // should not be encountered ideally
<                         
<                               assign FETCH_Instr_Mul1_mul_insn_a2[31:0] = {7'b0000001,10'b0011000101,FETCH_Instr_Mul1_opcode_a2,5'b00101,7'b0110011};
<                                              // {  funct7  ,{rs2, rs1} (X), funct3, rd (X),  opcode  }   
<                               // this module is located in ./muldiv/picorv32_pcpi_fast_mul.sv
<                               /*SV_plus*/      
<                                     picorv32_pcpi_fast_mul #(.EXTRA_MUL_FFS(1), .EXTRA_INSN_FFS(1), .MUL_CLKGATE(0)) mul(
<                                           .clk           (FETCH_Instr_clk_a2), 
<                                           .resetn        (FETCH_Instr_resetn_a2),
<                                           .pcpi_valid    (FETCH_Instr_mulblk_valid_a2),
<                                           .pcpi_insn     (FETCH_Instr_Mul1_mul_insn_a2),
<                                           .pcpi_rs1      (FETCH_Instr_mul_in1_a2),
<                                           .pcpi_rs2      (FETCH_Instr_mul_in2_a2),
<                                           .pcpi_wr       (FETCH_Instr_wrm_a2),
<                                           .pcpi_rd       (FETCH_Instr_mulblock_rslt_a2[31:0]),
<                                           .pcpi_wait     (FETCH_Instr_waitm_a2),
<                                           .pcpi_ready    (FETCH_Instr_readym_a2)
<                                     );
<                            
<                         //_\end_source
<                         //_\source ./warpv.tlv 2637   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+warpv_div(|fetch/instr,/div1, $divblock_rslt, $wrd, $waitd, $readyd, $clk, $resetn, $div_in1, $div_in2, $instr_type_div, >>1$div_stall)
<                            //_/div1
<                               
<                               // instr type is one hot encoding of the required M type instruction
<                               // the idea is to concatenate is_*_instr from WARP-V and pass on to this module
<                                  
<                               assign FETCH_Instr_Div1_opcode_a2[2:0] = (FETCH_Instr_instr_type_div_a2 == 4'b0001 ) ? 3'b100 : // div
<                                              (FETCH_Instr_instr_type_div_a2 == 4'b0010 ) ? 3'b101 : // divu
<                                              (FETCH_Instr_instr_type_div_a2 == 4'b0100 ) ? 3'b110 : // rem
<                                              (FETCH_Instr_instr_type_div_a2 == 4'b1000 ) ? 3'b111 : // remu
<                                                                                3'b100 ; // default to div, but this case 
<                                                                                         // should not be encountered ideally
<                               assign FETCH_Instr_Div1_div_insn_a2[31:0] = {7'b0000001,10'b0011000101,3'b000,5'b00101,7'b0110011} | (FETCH_Instr_Div1_opcode_a2 << 12);
<                                              // {  funct7  ,{rs2, rs1} (X), funct3, rd (X),  opcode  }   
<                               // this module is located in ./muldiv/picorv32_div_opt.sv
<                               /*SV_plus*/
<                                     picorv32_pcpi_div div(
<                                           .clk           (FETCH_Instr_clk_a2), 
<                                           .resetn        (FETCH_Instr_resetn_a2),
<                                           .pcpi_valid    (FETCH_Instr_div_stall_a3),
<                                           .pcpi_insn     (FETCH_Instr_Div1_div_insn_a2),
<                                           .pcpi_rs1      (FETCH_Instr_div_in1_a2),
<                                           .pcpi_rs2      (FETCH_Instr_div_in2_a2),
<                                           .pcpi_rd       (FETCH_Instr_divblock_rslt_a2[31:0]),
<                                           .pcpi_wait     (FETCH_Instr_waitd_a2),
<                                           .pcpi_wr       (FETCH_Instr_wrd_a2),
<                                           .pcpi_ready    (FETCH_Instr_readyd_a2)
<                                        );
<                         //_\end_source
<                         // for the division module, the valid signal must be asserted for the entire computation duration, hence >>1$div_stall is used for this purpose
<                         // for multiplication it is just a single cycle pulse to start operating
---
>                         
>                         
>                         
>                         
>                         
>                         
>                         
>                         
>                         
1007,1012c909,914
<                         /* verilator lint_on CASEINCOMPLETE */
<                         /* verilator lint_on WIDTH */
<                         // use $ANY for passing attributes from long-latency div/mul instructions into the pipeline 
<                         // stall_cnt_upper_div indicates that the results for div module are ready. The second issue of the instruction takes place
<                         // M4_NON_PIPELINED_BUBBLES after this point (depending on pipeline depth)
<                         // retain till next M-type instruction, to be used again at second issue
---
>                         
>                         
>                         
>                         
>                         
>                         
1039,1044d940
<                         // ORed with 1'b0 for maintaining correct behavior for all 3 combinations of F & M, only F and only M 
<                         //_/hold_inst
<                            assign {FETCH_Instr_HoldInst_dest_reg_a2[4:0]} = 1'b0  || (FETCH_Instr_mulblk_valid_a2 || (FETCH_Instr_div_stall_a2 && FETCH_Instr_commit_a2))  ? {FETCH_Instr_dest_reg_a2} : {FETCH_Instr_HoldInst_dest_reg_a3};
<                            for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_HoldInst_Src logic L1_dummy_a2, L1_dummy_a3; //_/src
<                               assign {L1_dummy_a2} = 1'b0  || (FETCH_Instr_mulblk_valid_a2 || (FETCH_Instr_div_stall_a2 && FETCH_Instr_commit_a2))  ? {L1b_FETCH_Instr_Src[src].L1_dummy_a2} : {L1_dummy_a3}; end
<                         
1127,1149c1023,1045
<                            // for Verilog modules instantiation
<                            assign FETCH_Instr_clk_a2 = clk;
<                            assign FETCH_Instr_resetn_a2 = !(reset);
<                   
<                            assign FETCH_Instr_instr_type_mul_a2[3:0]    = FETCH_Instr_reset_a2 ? '0 : FETCH_Instr_mulblk_valid_a2 ? {FETCH_Instr_is_mulhu_instr_a2,FETCH_Instr_is_mulhsu_instr_a2,FETCH_Instr_is_mulh_instr_a2,FETCH_Instr_is_mul_instr_a2} : FETCH_Instr_instr_type_mul_a3[3:0];
<                            assign FETCH_Instr_mul_in1_a2[31:0] = FETCH_Instr_reset_a2 ? '0 : FETCH_Instr_mulblk_valid_a2 ? L1b_FETCH_Instr_Src[1].L1_reg_value_a2 : FETCH_Instr_mul_in1_a3[31:0];
<                            assign FETCH_Instr_mul_in2_a2[31:0] = FETCH_Instr_reset_a2 ? '0 : FETCH_Instr_mulblk_valid_a2 ? L1b_FETCH_Instr_Src[2].L1_reg_value_a2 : FETCH_Instr_mul_in2_a3[31:0];
<                            
<                            assign FETCH_Instr_instr_type_div_a2[3:0]    = FETCH_Instr_reset_a2 ? '0 : FETCH_Instr_divblk_valid_a2 ? {FETCH_Instr_is_remu_instr_a2,FETCH_Instr_is_rem_instr_a2,FETCH_Instr_is_divu_instr_a2,FETCH_Instr_is_div_instr_a2} : FETCH_Instr_instr_type_div_a3[3:0];
<                            assign FETCH_Instr_div_in1_a2[31:0] = FETCH_Instr_reset_a2 ? '0 : FETCH_Instr_divblk_valid_a2 ? L1b_FETCH_Instr_Src[1].L1_reg_value_a2 : FETCH_Instr_div_in1_a3[31:0];
<                            assign FETCH_Instr_div_in2_a2[31:0] = FETCH_Instr_reset_a2 ? '0 : FETCH_Instr_divblk_valid_a2 ? L1b_FETCH_Instr_Src[2].L1_reg_value_a2 : FETCH_Instr_div_in2_a3[31:0];
<                            
<                            // result signals for div/mul can be pulled down to 0 here, as they are assigned only in the second issue
<                   
<                            assign FETCH_Instr_mul_rslt_a2[31:0]      = 32'b0;
<                            assign FETCH_Instr_mulh_rslt_a2[31:0]     = 32'b0;
<                            assign FETCH_Instr_mulhsu_rslt_a2[31:0]   = 32'b0;
<                            assign FETCH_Instr_mulhu_rslt_a2[31:0]    = 32'b0;
<                            assign FETCH_Instr_div_rslt_a2[31:0]      = 32'b0;
<                            assign FETCH_Instr_divu_rslt_a2[31:0]     = 32'b0;
<                            assign FETCH_Instr_rem_rslt_a2[31:0]      = 32'b0;
<                            assign FETCH_Instr_remu_rslt_a2[31:0]     = 32'b0;
<                            `BOGUS_USE (FETCH_Instr_wrm_a2 FETCH_Instr_wrd_a2 FETCH_Instr_readyd_a2 FETCH_Instr_readym_a2 FETCH_Instr_waitm_a2 FETCH_Instr_waitd_a2)
---
>                            
>                            
>                            
>                   
>                            
>                            
>                            
>                            
>                            
>                            
>                            
>                            
>                            
>                   
>                            
>                            
>                            
>                            
>                            
>                            
>                            
>                            
>                            
1231c1127
<                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
---
>                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 12 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
1273c1169
<                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
---
>                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 12 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
1315c1211
<                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
---
>                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 12 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
1357c1253
<                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
---
>                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 12 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
1399c1295
<                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
---
>                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 12 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
1441c1337
<                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 11 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
---
>                         //_\source ./warpv.tlv 1352   // Instantiated from warp-v_risc-v_4-stage.tlv, 12 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
1630,1631c1526,1527
<                                  (FETCH_Instr_second_issue_div_mul_a2 && FETCH_Instr_stall_cnt_upper_div_a5) ? FETCH_Instr_divblock_rslt_a2 : 
<                                  (FETCH_Instr_second_issue_div_mul_a2 && FETCH_Instr_stall_cnt_upper_mul_a5) ? FETCH_Instr_mulblock_rslt_a2 :
---
>                                  
>                                  
1669,1677c1565
<                                ({32{FETCH_Instr_is_csrrci_instr_a2}} & FETCH_Instr_csrrci_rslt_a2) |
<                                ({32{FETCH_Instr_is_mul_instr_a2}} & FETCH_Instr_mul_rslt_a2) |
<                                ({32{FETCH_Instr_is_mulh_instr_a2}} & FETCH_Instr_mulh_rslt_a2) |
<                                ({32{FETCH_Instr_is_mulhsu_instr_a2}} & FETCH_Instr_mulhsu_rslt_a2) |
<                                ({32{FETCH_Instr_is_mulhu_instr_a2}} & FETCH_Instr_mulhu_rslt_a2) |
<                                ({32{FETCH_Instr_is_div_instr_a2}} & FETCH_Instr_div_rslt_a2) |
<                                ({32{FETCH_Instr_is_divu_instr_a2}} & FETCH_Instr_divu_rslt_a2) |
<                                ({32{FETCH_Instr_is_rem_instr_a2}} & FETCH_Instr_rem_rslt_a2) |
<                                ({32{FETCH_Instr_is_remu_instr_a2}} & FETCH_Instr_remu_rslt_a2);
---
>                                ({32{FETCH_Instr_is_csrrci_instr_a2}} & FETCH_Instr_csrrci_rslt_a2);
1822c1710
<    //_\source ./warpv.tlv 3196   // Instantiated from warp-v_risc-v_4-stage.tlv, 12 as: m4+warpv_makerchip_cnt10_tb()
---
>    //_\source ./warpv.tlv 3196   // Instantiated from warp-v_risc-v_4-stage.tlv, 13 as: m4+warpv_makerchip_cnt10_tb()
1832c1720
<    //_\source ./warpv.tlv 4013   // Instantiated from warp-v_risc-v_4-stage.tlv, 13 as: m4+makerchip_pass_fail()
---
>    //_\source ./warpv.tlv 4013   // Instantiated from warp-v_risc-v_4-stage.tlv, 14 as: m4+makerchip_pass_fail()

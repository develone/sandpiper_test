<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 18143, 700, 0, 0, 33, 0, 0, 0, 'opacity: 0.1', 8440, 'opacity: 0.1', 4607, 'opacity: 0.1'],
      ['top.sv', 0, 18143, 983, 0, 0, 70, 0, 0, 0, 'opacity: 0.1', 8535, 'opacity: 0.1', 4643, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 512, 0, 53, 0, 0, 1326, 'opacity: 0.1', 882, 'opacity: 0.1', 607, 'opacity: 0.1'],
      ['SV Total', 0, 18143, 983, 512, 0, 123, 0, 0, 1326, 'opacity: 0.1', 9417, 'opacity: 0.1', 5250, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;





</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $i_ram_data.
</span><span class="tlx_declarations">logic [15:0] L0_i_ram_data_a0;

</span><span class="tlx_comments">// For $i_wb_addr.
</span><span class="tlx_declarations">logic [23:0] L0_i_wb_addr_a0;

</span><span class="tlx_comments">// For $i_wb_cyc.
</span><span class="tlx_declarations">logic L0_i_wb_cyc_a0;

</span><span class="tlx_comments">// For $i_wb_data.
</span><span class="tlx_declarations">logic [31:0] L0_i_wb_data_a0;

</span><span class="tlx_comments">// For $i_wb_sel.
</span><span class="tlx_declarations">logic L0_i_wb_sel_a0;

</span><span class="tlx_comments">// For $i_wb_stb.
</span><span class="tlx_declarations">logic L0_i_wb_stb_a0;

</span><span class="tlx_comments">// For $i_wb_we.
</span><span class="tlx_declarations">logic L0_i_wb_we_a0;

</span><span class="tlx_comments">// For $o_debug.
</span><span class="tlx_declarations">logic [31:0] L0_o_debug_a0;

</span><span class="tlx_comments">// For $o_ram_addr.
</span><span class="tlx_declarations">logic [12:0] L0_o_ram_addr_a0;

</span><span class="tlx_comments">// For $o_ram_bs.
</span><span class="tlx_declarations">logic [1:0] L0_o_ram_bs_a0;

</span><span class="tlx_comments">// For $o_ram_cas_n.
</span><span class="tlx_declarations">logic L0_o_ram_cas_n_a0;

</span><span class="tlx_comments">// For $o_ram_cke.
</span><span class="tlx_declarations">logic L0_o_ram_cke_a0;

</span><span class="tlx_comments">// For $o_ram_cs_n.
</span><span class="tlx_declarations">logic L0_o_ram_cs_n_a0;

</span><span class="tlx_comments">// For $o_ram_data.
</span><span class="tlx_declarations">logic [15:0] L0_o_ram_data_a0;

</span><span class="tlx_comments">// For $o_ram_dmod.
</span><span class="tlx_declarations">logic L0_o_ram_dmod_a0;

</span><span class="tlx_comments">// For $o_ram_dqm.
</span><span class="tlx_declarations">logic [1:0] L0_o_ram_dqm_a0;

</span><span class="tlx_comments">// For $o_ram_ras_n.
</span><span class="tlx_declarations">logic L0_o_ram_ras_n_a0;

</span><span class="tlx_comments">// For $o_ram_we_n.
</span><span class="tlx_declarations">logic L0_o_ram_we_n_a0;

</span><span class="tlx_comments">// For $o_wb_ack.
</span><span class="tlx_declarations">logic L0_o_wb_ack_a0;

</span><span class="tlx_comments">// For $o_wb_data.
</span><span class="tlx_declarations">logic [31:0] L0_o_wb_data_a0;

</span><span class="tlx_comments">// For $o_wb_stall.
</span><span class="tlx_declarations">logic L0_o_wb_stall_a0;

</span><span class="tlx_comments">// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0;


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">
   // For signal $o_ram_ras_n, which had no assignment.
   </span><span class="tlx_instrumentation">assign L0_o_ram_ras_n_a0 = 'x;



</span><span class="tlx_structure">endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS

      logic [15:0] \@0$i_ram_data ;
      assign \@0$i_ram_data = L0_i_ram_data_a0;
      logic [23:0] \@0$i_wb_addr ;
      assign \@0$i_wb_addr = L0_i_wb_addr_a0;
      logic  \@0$i_wb_cyc ;
      assign \@0$i_wb_cyc = L0_i_wb_cyc_a0;
      logic [31:0] \@0$i_wb_data ;
      assign \@0$i_wb_data = L0_i_wb_data_a0;
      logic  \@0$i_wb_sel ;
      assign \@0$i_wb_sel = L0_i_wb_sel_a0;
      logic  \@0$i_wb_stb ;
      assign \@0$i_wb_stb = L0_i_wb_stb_a0;
      logic  \@0$i_wb_we ;
      assign \@0$i_wb_we = L0_i_wb_we_a0;
      logic [31:0] \@0$o_debug ;
      assign \@0$o_debug = L0_o_debug_a0;
      logic [12:0] \@0$o_ram_addr ;
      assign \@0$o_ram_addr = L0_o_ram_addr_a0;
      logic [1:0] \@0$o_ram_bs ;
      assign \@0$o_ram_bs = L0_o_ram_bs_a0;
      logic  \@0$o_ram_cas_n ;
      assign \@0$o_ram_cas_n = L0_o_ram_cas_n_a0;
      logic  \@0$o_ram_cke ;
      assign \@0$o_ram_cke = L0_o_ram_cke_a0;
      logic  \@0$o_ram_cs_n ;
      assign \@0$o_ram_cs_n = L0_o_ram_cs_n_a0;
      logic [15:0] \@0$o_ram_data ;
      assign \@0$o_ram_data = L0_o_ram_data_a0;
      logic  \@0$o_ram_dmod ;
      assign \@0$o_ram_dmod = L0_o_ram_dmod_a0;
      logic [1:0] \@0$o_ram_dqm ;
      assign \@0$o_ram_dqm = L0_o_ram_dqm_a0;
      logic  \@0$o_ram_ras_n ;
      assign \@0$o_ram_ras_n = L0_o_ram_ras_n_a0;
      logic  \@0$o_ram_we_n ;
      assign \@0$o_ram_we_n = L0_o_ram_we_n_a0;
      logic  \@0$o_wb_ack ;
      assign \@0$o_wb_ack = L0_o_wb_ack_a0;
      logic [31:0] \@0$o_wb_data ;
      assign \@0$o_wb_data = L0_o_wb_data_a0;
      logic  \@0$o_wb_stall ;
      assign \@0$o_wb_stall = L0_o_wb_stall_a0;
      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
</span><span class="tlx_comments">////////////////////////////////////////////////////////////////////////////////
//
// Filename: 	wbsdram.v
//
// Project:	ArrowZip, a demonstration of the Arrow MAX1000 FPGA board
//
// Purpose:	Provide 32-bit wishbone access to the SDRAM memory on a MAX1000
//		board.  Specifically, on each access, the controller will
//	activate an appropriate bank of RAM (the SDRAM has four banks), and
//	then issue the read/write command.  In the case of walking off the
//	bank, the controller will activate the next bank before you get to it.
//	Upon concluding any wishbone access, all banks will be precharged and
//	returned to idle.
//
//	This particular implementation represents a second generation version
//	because my first version was too complex.  To speed things up, this
//	version includes an extra wait state where the wishbone inputs are
//	clocked into a flip flop before any action is taken on them.
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2015-2019, Gisselquist Technology, LLC
//
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of  the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// &lt;http://www.gnu.org/licenses/&gt; for a copy.
//
// License:	GPL, v3, as defined and found on www.gnu.org,
//		http://www.gnu.org/licenses/gpl.html
//
//
////////////////////////////////////////////////////////////////////////////////
//
//
</span><span class="tlx_untouched">`default_nettype	none
</span><span class="tlx_comments">//
</span><span class="tlx_untouched">`define	DMOD_GETINPUT	1'b0
`define	DMOD_PUTOUTPUT	1'b1
`define	RAM_OPERATIONAL	2'b00
`define	RAM_POWER_UP	2'b01
`define	RAM_SET_MODE	2'b10
`define	RAM_INITIAL_REFRESH	2'b11
</span><span class="tlx_comments">//
</span><span class="tlx_untouched">module	wbsdram(i_clk,
		i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel,
			o_wb_ack, o_wb_stall, o_wb_data,
		o_ram_cs_n, o_ram_cke, o_ram_ras_n, o_ram_cas_n, o_ram_we_n,
			o_ram_bs, o_ram_addr,
			o_ram_dmod, i_ram_data, o_ram_data, o_ram_dqm,
		o_debug);
	parameter	RDLY = 6;
	localparam	NCA=9, NRA=13, AW=(NCA+NRA+2)-1, DW=32;
	localparam	[NCA-2:0] COL_THRESHOLD = -16;
	input	wire			i_clk;
	</span><span class="tlx_comments">// Wishbone
	//	inputs
	</span><span class="tlx_untouched">input	wire			i_wb_cyc, i_wb_stb, i_wb_we;
	input	wire	[(AW-1):0]	i_wb_addr;
	input	wire	[(DW-1):0]	i_wb_data;
	input	wire	[(DW/8-1):0]	i_wb_sel;
	</span><span class="tlx_comments">//	outputs
	</span><span class="tlx_untouched">output	wire		o_wb_ack;
	output	reg		o_wb_stall;
	output	wire [31:0]	o_wb_data;
	</span><span class="tlx_comments">// SDRAM control
	</span><span class="tlx_untouched">output	wire		o_ram_cke;
	output	reg		o_ram_cs_n,
				o_ram_ras_n, o_ram_cas_n, o_ram_we_n;
	output	reg	[1:0]	o_ram_bs;
	output	reg	[12:0]	o_ram_addr;
	output	reg		o_ram_dmod;
	input		[15:0]	i_ram_data;
	output	reg	[15:0]	o_ram_data;
	output	reg	[1:0]	o_ram_dqm;
	output	wire [(DW-1):0]	o_debug;


	</span><span class="tlx_comments">// Calculate some metrics

	//
	// First, do we *need* a refresh now --- i.e., must we break out of
	// whatever we are doing to issue a refresh command?
	//
	// The step size here must be such that 8192 charges may be done in
	// 64 ms.  Thus for a clock of:
	//	ClkRate(MHz)	(64ms/1000(ms/s)*ClkRate)/8192
	//	100 MHz		781
	//	 96 MHz		750
	//	 92 MHz		718
	//	 88 MHz		687
	//	 84 MHz		656
	//	 80 MHz		625
	//
	// However, since we do two refresh cycles everytime we need a refresh,
	// this standard is close to overkill--but we'll use it anyway.  At
	// some later time we should address this, once we are entirely
	// convinced that the memory is otherwise working without failure.  Of
	// course, at that time, it may no longer be a priority ...
	//
	</span><span class="tlx_untouched">reg		need_refresh;
	reg	[9:0]	refresh_clk;
	wire	refresh_cmd;
	assign	refresh_cmd = (!o_ram_cs_n)&amp;&amp;(!o_ram_ras_n)&amp;&amp;(!o_ram_cas_n)&amp;&amp;(o_ram_we_n);
	initial	refresh_clk = 0;
	always @(posedge i_clk)
	begin
		if (refresh_cmd)
			</span><span class="tlx_comments">//refresh_clk &lt;= 10'd625; // Make suitable for 80 MHz clk
			</span><span class="tlx_untouched">refresh_clk &lt;= 10'd313; </span><span class="tlx_comments">// Make suitable for 40 MHz clk
		</span><span class="tlx_untouched">else if (|refresh_clk)
			refresh_clk &lt;= refresh_clk - 10'h1;
	end
	initial	need_refresh = 1'b0;
	always @(posedge i_clk)
		need_refresh &lt;= (refresh_clk == 10'h00)&amp;&amp;(!refresh_cmd);

	reg	in_refresh;
	reg	[2:0]	in_refresh_clk;
	initial	in_refresh_clk = 3'h0;
	always @(posedge i_clk)
		if (refresh_cmd)
			in_refresh_clk &lt;= 3'h6;
		else if (|in_refresh_clk)
			in_refresh_clk &lt;= in_refresh_clk - 3'h1;
	initial	in_refresh = 0;
	always @(posedge i_clk)
		in_refresh &lt;= (in_refresh_clk != 3'h0)||(refresh_cmd);
`ifdef	FORMAL
	always @(posedge i_clk)
		if (in_refresh)
			assert((refresh_cmd)||($past(in_refresh_clk) &lt;= 3'h6));
	always @(posedge i_clk)
		if (in_refresh)
			assert(refresh_clk==10'd619+{{(7){1'b0}},in_refresh_clk});
`endif


	reg	[2:0]		bank_active	[0:3];
	reg	[(RDLY-1):0]	r_barrell_ack;
	reg			r_pending;
	reg			r_we;
	reg	[(AW-1):0]	r_addr;
	reg	[31:0]		r_data;
	reg	[3:0]		r_sel;
	reg	[(AW-NCA-2):0]	bank_row	[0:3];


	</span><span class="tlx_comments">//
	// Second, do we *need* a precharge now --- must be break out of
	// whatever we are doing to issue a precharge command?
	//
	// Keep in mind, the number of clocks to wait has to be reduced by
	// the amount of time it may take us to go into a precharge state.
	// You may also notice that the precharge requirement is tighter
	// than this one, so ... perhaps this isn't as required?
	//

	</span><span class="tlx_untouched">reg	[2:0]	clocks_til_idle;
	reg	[1:0]	m_state;
	wire		bus_cyc;
	assign	bus_cyc  = ((i_wb_cyc)&amp;&amp;(i_wb_stb)&amp;&amp;(!o_wb_stall));
	reg	nxt_dmod;

	</span><span class="tlx_comments">// Pre-process pending operations
	</span><span class="tlx_untouched">wire	pending;
	initial	r_pending = 1'b0;
	reg	[(AW-1):0]	fwd_addr;
	initial	r_addr = 0;
	initial	fwd_addr = { {(AW-(NCA)){1'b0}}, 1'b1, {(NCA-1){1'b0}} };
	always @(posedge i_clk)
	begin
		fwd_addr[NCA-2:0] &lt;= 0;
		if (bus_cyc)
		begin
			r_pending &lt;= 1'b1;
			r_we      &lt;= i_wb_we;
			r_addr    &lt;= i_wb_addr;
			r_data    &lt;= i_wb_data;
			r_sel     &lt;= i_wb_sel;
			fwd_addr[AW-1:NCA-1]&lt;=i_wb_addr[(AW-1):(NCA-1)] + 1'b1;
		end else if ((!o_ram_cs_n)&amp;&amp;(o_ram_ras_n)&amp;&amp;(!o_ram_cas_n))
			r_pending &lt;= 1'b0;
		else if (!i_wb_cyc)
			r_pending &lt;= 1'b0;
	end

`ifdef	FORMAL
	always @(*)
		assert(fwd_addr[AW-1:NCA-1] == r_addr[(AW-1):(NCA-1)] + 1'b1);
	always @(*)
		assert(fwd_addr[NCA-3:0] == 0);
`endif

	wire	[1:0]	wb_bs, r_bs, fwd_bs;	</span><span class="tlx_comments">// Bank select
	</span><span class="tlx_untouched">assign	wb_bs = i_wb_addr[NCA:NCA-1];
	assign	r_bs  =    r_addr[NCA:NCA-1];
	assign fwd_bs =  fwd_addr[NCA:NCA-1];
	wire	[NRA-1:0]	wb_row, r_row, fwd_row;
	assign	wb_row = i_wb_addr[AW-1:NCA+1];
	assign	 r_row =    r_addr[AW-1:NCA+1];
	assign fwd_row =  fwd_addr[AW-1:NCA+1];

	reg	r_bank_valid;
	initial	r_bank_valid = 1'b0;
	always @(posedge i_clk)
		if (bus_cyc)
			r_bank_valid &lt;=((bank_active[wb_bs][2])
					&amp;&amp;(bank_row[wb_bs] == wb_row));
		else
			r_bank_valid &lt;= ((bank_active[r_bs][2])
				&amp;&amp;(bank_row[r_bs] == r_row));

	reg	fwd_bank_valid;
	initial	fwd_bank_valid = 0;
	always @(posedge i_clk)
		fwd_bank_valid &lt;= ((bank_active[fwd_bs][2])
				&amp;&amp;(bank_row[fwd_bs] == fwd_row));

	assign	pending = (r_pending)&amp;&amp;(o_wb_stall);

	</span><span class="tlx_comments">//
	//
	// Maintenance mode (i.e. startup) wires and logic
	</span><span class="tlx_untouched">reg	maintenance_mode;
	reg	m_ram_cs_n, m_ram_ras_n, m_ram_cas_n, m_ram_we_n, m_ram_dmod;
	reg	[(NRA-1):0]	m_ram_addr;
	</span><span class="tlx_comments">//
	//
	//

	// Address MAP:
	//	22-bits bits in, 23-bits out
	//
	//	22 1111 1111 1100 0000 0000
	//	10 9876 5432 1098 7654 3210
	//	rr rrrr rrrr rrBB cccc cccc 0
	//	                  8765 4321 0
	//
	</span><span class="tlx_untouched">initial r_barrell_ack = 0;
	initial	clocks_til_idle = 3'h0;
	initial o_wb_stall = 1'b1;
	initial	o_ram_dmod = `DMOD_GETINPUT;
	initial	nxt_dmod = `DMOD_GETINPUT;
	initial o_ram_cs_n  = 1'b0;
	initial o_ram_ras_n = 1'b1;
	initial o_ram_cas_n = 1'b1;
	initial o_ram_we_n  = 1'b1;
	initial	o_ram_dqm   = 2'b11;
	assign	o_ram_cke   = 1'b1;
	initial bank_active[0] = 3'b000;
	initial bank_active[1] = 3'b000;
	initial bank_active[2] = 3'b000;
	initial bank_active[3] = 3'b000;
	always @(posedge i_clk)
	if (maintenance_mode)
	begin
		bank_active[0] &lt;= 0;
		bank_active[1] &lt;= 0;
		bank_active[2] &lt;= 0;
		bank_active[3] &lt;= 0;
		r_barrell_ack[(RDLY-1):0] &lt;= 0;
		o_wb_stall  &lt;= 1'b1;
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">o_ram_cs_n  &lt;= m_ram_cs_n;
		o_ram_ras_n &lt;= m_ram_ras_n;
		o_ram_cas_n &lt;= m_ram_cas_n;
		o_ram_we_n  &lt;= m_ram_we_n;
		o_ram_dmod  &lt;= m_ram_dmod;
		o_ram_addr  &lt;= m_ram_addr;
		o_ram_bs    &lt;= 2'b00;
		nxt_dmod &lt;= `DMOD_GETINPUT;
	end else begin
		o_wb_stall &lt;= (r_pending)||(bus_cyc);
		if (!i_wb_cyc)
			r_barrell_ack &lt;= 0;
		else
			r_barrell_ack &lt;= r_barrell_ack &gt;&gt; 1;
		nxt_dmod &lt;= `DMOD_GETINPUT;
		o_ram_dmod &lt;= nxt_dmod;

		</span><span class="tlx_comments">//
		// We assume that, whatever state the bank is in, that it
		// continues in that state and set up a series of shift
		// registers to contain that information.  If it will not
		// continue in that state, all that therefore needs to be
		// done is to set bank_active[?][2] below.
		//
		</span><span class="tlx_untouched">bank_active[0] &lt;= { bank_active[0][2], bank_active[0][2:1] };
		bank_active[1] &lt;= { bank_active[1][2], bank_active[1][2:1] };
		bank_active[2] &lt;= { bank_active[2][2], bank_active[2][2:1] };
		bank_active[3] &lt;= { bank_active[3][2], bank_active[3][2:1] };
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">o_ram_cs_n &lt;= (!i_wb_cyc);
		</span><span class="tlx_comments">// o_ram_cke  &lt;= 1'b1;
		</span><span class="tlx_untouched">if (|clocks_til_idle[2:0])
			clocks_til_idle[2:0] &lt;= clocks_til_idle[2:0] - 3'h1;

		</span><span class="tlx_comments">// Default command is a
		//	NOOP if (i_wb_cyc)
		//	Device deselect if (!i_wb_cyc)
		// o_ram_cs_n  &lt;= (!i_wb_cyc) above, NOOP
		</span><span class="tlx_untouched">o_ram_ras_n &lt;= 1'b1;
		o_ram_cas_n &lt;= 1'b1;
		o_ram_we_n  &lt;= 1'b1;

		</span><span class="tlx_comments">// o_ram_data &lt;= r_data[15:0];

		</span><span class="tlx_untouched">if (nxt_dmod)
			;
		else
		if ((!i_wb_cyc)||(need_refresh))
		begin </span><span class="tlx_comments">// Issue a precharge all command (if any banks are open),
		// otherwise an autorefresh command
			</span><span class="tlx_untouched">if ((bank_active[0][2:1]==2'b10)
					||(bank_active[1][2:1]==2'b10)
					||(bank_active[2][2:1]==2'b10)
					||(bank_active[3][2:1]==2'b10)
				||(|clocks_til_idle[2:0]))
			begin
				</span><span class="tlx_comments">// Do nothing this clock
				// Can't precharge a bank immediately after
				// activating it
			</span><span class="tlx_untouched">end else if (bank_active[0][2]
				||(bank_active[1][2])
				||(bank_active[2][2])
				||(bank_active[3][2]))
			begin  </span><span class="tlx_comments">// Close all active banks
				</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
				o_ram_ras_n &lt;= 1'b0;
				o_ram_cas_n &lt;= 1'b1;
				o_ram_we_n  &lt;= 1'b0;
				o_ram_addr[10] &lt;= 1'b1;
				bank_active[0][2] &lt;= 1'b0;
				bank_active[1][2] &lt;= 1'b0;
				bank_active[2][2] &lt;= 1'b0;
				bank_active[3][2] &lt;= 1'b0;
			end else if ((|bank_active[0])
					||(|bank_active[1])
					||(|bank_active[2])
					||(|bank_active[3]))
				</span><span class="tlx_comments">// Can't precharge yet, the bus is still busy
			</span><span class="tlx_untouched">begin end else if ((!in_refresh)&amp;&amp;((refresh_clk[9:8]==2'b00)||(need_refresh)))
			begin </span><span class="tlx_comments">// Send autorefresh command
				</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
				o_ram_ras_n &lt;= 1'b0;
				o_ram_cas_n &lt;= 1'b0;
				o_ram_we_n  &lt;= 1'b1;
			end </span><span class="tlx_comments">// Else just send NOOP's, the default command
		</span><span class="tlx_untouched">end else if (in_refresh)
		begin
			</span><span class="tlx_comments">// NOOPS only here, until we are out of refresh
		</span><span class="tlx_untouched">end else if ((pending)&amp;&amp;(!r_bank_valid)&amp;&amp;(bank_active[r_bs]==3'h0))
		begin </span><span class="tlx_comments">// Need to activate the requested bank
			</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
			o_ram_ras_n &lt;= 1'b0;
			o_ram_cas_n &lt;= 1'b1;
			o_ram_we_n  &lt;= 1'b1;
			o_ram_addr  &lt;= r_row;
			o_ram_bs    &lt;= r_bs;
			</span><span class="tlx_comments">// clocks_til_idle[2:0] &lt;= 1;
			</span><span class="tlx_untouched">bank_active[r_bs][2] &lt;= 1'b1;
			bank_row[r_bs] &lt;= r_row;
			</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">end else if ((pending)&amp;&amp;(!r_bank_valid)
				&amp;&amp;(bank_active[r_bs]==3'b111))
		begin </span><span class="tlx_comments">// Need to close an active bank
			</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
			o_ram_ras_n &lt;= 1'b0;
			o_ram_cas_n &lt;= 1'b1;
			o_ram_we_n  &lt;= 1'b0;
			</span><span class="tlx_comments">// o_ram_addr  &lt;= r_addr[(AW-1):(NCA+2)];
			</span><span class="tlx_untouched">o_ram_addr[10]&lt;= 1'b0;
			o_ram_bs    &lt;= r_bs;
			</span><span class="tlx_comments">// clocks_til_idle[2:0] &lt;= 1;
			</span><span class="tlx_untouched">bank_active[r_bs][2] &lt;= 1'b0;
			</span><span class="tlx_comments">// bank_row[r_bs] &lt;= r_row;
		</span><span class="tlx_untouched">end else if ((pending)&amp;&amp;(!r_we)
				&amp;&amp;(bank_active[r_bs][2])
				&amp;&amp;(r_bank_valid)
				&amp;&amp;(clocks_til_idle[2:0] &lt; 4))
		begin </span><span class="tlx_comments">// Issue the read command
			</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
			o_ram_ras_n &lt;= 1'b1;
			o_ram_cas_n &lt;= 1'b0;
			o_ram_we_n  &lt;= 1'b1;
			o_ram_addr  &lt;= { 4'h0, r_addr[NCA-2:0], 1'b0 };
			o_ram_bs    &lt;= r_bs;
			clocks_til_idle[2:0] &lt;= 4;

			o_wb_stall &lt;= 1'b0;
			r_barrell_ack[(RDLY-1)] &lt;= 1'b1;
		end else if ((pending)&amp;&amp;(r_we)
			&amp;&amp;(bank_active[r_bs][2])
			&amp;&amp;(r_bank_valid)
			&amp;&amp;(clocks_til_idle[2:0] == 0))
		begin </span><span class="tlx_comments">// Issue the write command
			</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
			o_ram_ras_n &lt;= 1'b1;
			o_ram_cas_n &lt;= 1'b0;
			o_ram_we_n  &lt;= 1'b0;
			o_ram_addr  &lt;= { 4'h0, r_addr[NCA-2:0], 1'b0 };
			o_ram_bs    &lt;= r_bs;
			clocks_til_idle[2:0] &lt;= 3'h1;

			o_wb_stall &lt;= 1'b0;
			r_barrell_ack[1] &lt;= 1'b1;
			</span><span class="tlx_comments">// o_ram_data &lt;= r_data[31:16];
			//
			</span><span class="tlx_untouched">o_ram_dmod &lt;= `DMOD_PUTOUTPUT;
			nxt_dmod &lt;= `DMOD_PUTOUTPUT;
		end else if ((r_pending)&amp;&amp;(r_addr[(NCA-2):0] &gt;= COL_THRESHOLD)
				&amp;&amp;(!fwd_bank_valid))
		begin
			</span><span class="tlx_comments">// Do I need to close the next bank I'll need?
			</span><span class="tlx_untouched">if (bank_active[fwd_bs][2:1]==2'b11)
			begin </span><span class="tlx_comments">// Need to close the bank first
				</span><span class="tlx_untouched">o_ram_cs_n &lt;= 1'b0;
				o_ram_ras_n &lt;= 1'b0;
				o_ram_cas_n &lt;= 1'b1;
				o_ram_we_n  &lt;= 1'b0;
				o_ram_addr[10] &lt;= 1'b0;
				o_ram_bs       &lt;= fwd_bs;
				bank_active[fwd_bs][2] &lt;= 1'b0;
			end else if (bank_active[fwd_bs]==0)
			begin
				</span><span class="tlx_comments">// Need to (pre-)activate the next bank
				</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
				o_ram_ras_n &lt;= 1'b0;
				o_ram_cas_n &lt;= 1'b1;
				o_ram_we_n  &lt;= 1'b1;
				o_ram_addr  &lt;= fwd_row;
				o_ram_bs    &lt;= fwd_bs;
				</span><span class="tlx_comments">// clocks_til_idle[3:0] &lt;= 1;
				</span><span class="tlx_untouched">bank_active[fwd_bs] &lt;= 3'h4;
				bank_row[fwd_bs] &lt;= fwd_row;
			end
		end
		if (!i_wb_cyc)
			r_barrell_ack &lt;= 0;
	end

	reg		startup_hold;
	reg	[15:0]	startup_idle;
	initial	startup_idle = 16'd20500;
	initial	startup_hold = 1'b1;
	always @(posedge i_clk)
		if (|startup_idle)
			startup_idle &lt;= startup_idle - 1'b1;
	always @(posedge i_clk)
		startup_hold &lt;= |startup_idle;
`ifdef	FORMAL
	always @(*)
		if (startup_hold)
			assert(maintenance_mode);
	always @(*)
		if (|startup_idle)
			assert(startup_hold);
`endif

	reg	[3:0]	maintenance_clocks;
	reg		maintenance_clocks_zero;
	initial	maintenance_mode = 1'b1;
	initial	maintenance_clocks = 4'hf;
	initial	maintenance_clocks_zero = 1'b0;
	initial	m_ram_addr  = { 3'b000, 1'b0, 2'b00, 3'b010, 1'b0, 3'b001 };
	initial	m_state = `RAM_POWER_UP;
	initial	m_ram_cs_n  = 1'b1;
	initial	m_ram_ras_n = 1'b1;
	initial	m_ram_cas_n = 1'b1;
	initial	m_ram_we_n  = 1'b1;
	initial	m_ram_dmod  = `DMOD_GETINPUT;
	always @(posedge i_clk)
	begin
		if (!maintenance_clocks_zero)
		begin
			maintenance_clocks &lt;= maintenance_clocks - 4'h1;
			maintenance_clocks_zero &lt;= (maintenance_clocks == 4'h1);
		end
		</span><span class="tlx_comments">// The only time the RAM address matters is when we set
		// the mode.  At other times, addr[10] matters, but the rest
		// is ignored.  Hence ... we'll set it to a constant.
		</span><span class="tlx_untouched">m_ram_addr  &lt;= { 3'b000, 1'b0, 2'b00, 3'b010, 1'b0, 3'b001 };
		if (m_state == `RAM_POWER_UP)
		begin
			</span><span class="tlx_comments">// All signals must be held in NOOP state during powerup
			// m_ram_cke &lt;= 1'b1;
			</span><span class="tlx_untouched">m_ram_cs_n  &lt;= 1'b1;
			m_ram_ras_n &lt;= 1'b1;
			m_ram_cas_n &lt;= 1'b1;
			m_ram_we_n  &lt;= 1'b1;
			m_ram_dmod  &lt;= `DMOD_GETINPUT;
			if (!startup_hold)
			begin
				m_state &lt;= `RAM_SET_MODE;
				maintenance_clocks &lt;= 4'h3;
				maintenance_clocks_zero &lt;= 1'b0;
				</span><span class="tlx_comments">// Precharge all cmd
				</span><span class="tlx_untouched">m_ram_cs_n  &lt;= 1'b0;
				m_ram_ras_n &lt;= 1'b0;
				m_ram_cas_n &lt;= 1'b1;
				m_ram_we_n  &lt;= 1'b0;
				m_ram_addr[10] &lt;= 1'b1;
			end
		end else if (m_state == `RAM_SET_MODE)
		begin
			</span><span class="tlx_comments">// Wait
			</span><span class="tlx_untouched">m_ram_cs_n     &lt;= 1'b1;
			m_ram_cs_n     &lt;= 1'b1;
			m_ram_ras_n    &lt;= 1'b1;
			m_ram_cas_n    &lt;= 1'b1;
			m_ram_we_n     &lt;= 1'b1;
			m_ram_addr[10] &lt;= 1'b1;

			if (maintenance_clocks_zero)
			begin
				</span><span class="tlx_comments">// Set mode cycle
				</span><span class="tlx_untouched">m_ram_cs_n  &lt;= 1'b0;
				m_ram_ras_n &lt;= 1'b0;
				m_ram_cas_n &lt;= 1'b0;
				m_ram_we_n  &lt;= 1'b0;
				m_ram_dmod  &lt;= `DMOD_GETINPUT;
				m_ram_addr[10] &lt;= 1'b0;

				m_state &lt;= `RAM_INITIAL_REFRESH;
				maintenance_clocks &lt;= 4'hc;
				maintenance_clocks_zero &lt;= 1'b0;
			end
		end else if (m_state == `RAM_INITIAL_REFRESH)
		begin
			</span><span class="tlx_comments">// Refresh command
			</span><span class="tlx_untouched">if (maintenance_clocks &gt; 4'ha)
				</span><span class="tlx_comments">// Wait two clocks first
				</span><span class="tlx_untouched">m_ram_cs_n &lt;= 1'b1;
			else if (maintenance_clocks &gt; 4'h2)
				m_ram_cs_n  &lt;= 1'b0;
			else
				m_ram_cs_n &lt;= 1'b1;
			m_ram_ras_n &lt;= 1'b0;
			m_ram_cas_n &lt;= 1'b0;
			m_ram_we_n  &lt;= 1'b1;
			m_ram_dmod  &lt;= `DMOD_GETINPUT;
			</span><span class="tlx_comments">// m_ram_addr  &lt;= { 3'b000, 1'b0, 2'b00, 3'b010, 1'b0, 3'b001 };
			</span><span class="tlx_untouched">if (maintenance_clocks_zero)
				maintenance_mode &lt;= 1'b0;
		end
	end

	always @(posedge i_clk)
	if (nxt_dmod)
		o_ram_data &lt;= r_data[15:0];
	else
		o_ram_data &lt;= r_data[31:16];

	always @(posedge i_clk)
	if (maintenance_mode)
		o_ram_dqm &lt;= 2'b11;
	else if (r_we)
	begin
		if (nxt_dmod)
			o_ram_dqm &lt;= ~r_sel[1:0];
		else
			o_ram_dqm &lt;= ~r_sel[3:2];
	end else
		o_ram_dqm &lt;= 2'b00;

`ifdef	VERILATOR
	</span><span class="tlx_comments">// While I hate to build something that works one way under Verilator
	// and another way in practice, this really isn't that.  The problem
	// \/erilator is having is resolved in toplevel.v---one file that
	// \/erilator doesn't implement.  In toplevel.v, there's not only a
	// single clocked latch but two taking place.  Here, we replicate one
	// of those.  The second takes place (somehow) within the sdramsim.cpp
	// file.
	</span><span class="tlx_untouched">reg	[15:0]	ram_data, last_ram_data;
	always @(posedge i_clk)
		ram_data &lt;= i_ram_data;
	always @(posedge i_clk)
		last_ram_data &lt;= ram_data;
	assign	o_wb_data = { last_ram_data, ram_data };
`else
	reg	[15:0]	last_ram_data;
	always @(posedge i_clk)
		last_ram_data &lt;= i_ram_data;
	assign	o_wb_data = { last_ram_data, i_ram_data };
`endif
	assign	o_wb_ack  = r_barrell_ack[0];

	</span><span class="tlx_comments">//
	// The following outputs are not necessary for the functionality of
	// the SDRAM, but they can be used to feed an external &quot;scope&quot; to
	// get an idea of what the internals of this SDRAM are doing.
	//
	// Just be aware of the r_we: it is set based upon the currently pending
	// transaction, or (if none is pending) based upon the last transaction.
	// If you want to capture the first value &quot;written&quot; to the device,
	// you'll need to write a nothing value to the device to set r_we.
	// The first value &quot;written&quot; to the device can be caught in the next
	// interaction after that.
	//
	</span><span class="tlx_untouched">reg	trigger;
	always @(posedge i_clk)
		trigger &lt;= ((o_wb_data[15:0]==o_wb_data[31:16])
			&amp;&amp;(o_wb_ack)&amp;&amp;(!i_wb_we));


	assign	o_debug = { i_wb_cyc, i_wb_stb, i_wb_we, o_wb_ack, o_wb_stall, </span><span class="tlx_comments">// 5
		</span><span class="tlx_untouched">o_ram_cs_n, o_ram_ras_n, o_ram_cas_n, o_ram_we_n, o_ram_bs,</span><span class="tlx_comments">//6
			</span><span class="tlx_untouched">o_ram_dmod, r_pending, 				</span><span class="tlx_comments">//  2
			</span><span class="tlx_untouched">trigger,					</span><span class="tlx_comments">//  1
			</span><span class="tlx_untouched">o_ram_addr[9:0],				</span><span class="tlx_comments">// 10 more
			</span><span class="tlx_untouched">(r_we) ? { o_ram_data[7:0] }			</span><span class="tlx_comments">//  8 values
				</span><span class="tlx_untouched">: { o_wb_data[23:20], o_wb_data[3:0] }
			</span><span class="tlx_comments">// i_ram_data[7:0]
			 </span><span class="tlx_untouched">};

	</span><span class="tlx_comments">// Make Verilator happy
	// verilator lint_off UNUSED
	</span><span class="tlx_untouched">wire	[NCA-1:0]	unused;
	assign	unused = { fwd_addr[NCA-1:0] };
	</span><span class="tlx_comments">// verilator lint_on  UNUSED
</span><span class="tlx_untouched">`ifdef	FORMAL
	localparam	REFRESH_CLOCKS = 6;
	localparam	ACTIVATE_CLOCKS = 6;

	</span><span class="tlx_comments">// This device is 32MB, assert such
	</span><span class="tlx_untouched">always @(*)
		assert(AW == 23);
	always @(*)
		assert(NRA+NCA+2 == AW+1);

	wire	[(5-1):0]	f_nreqs, f_nacks, f_outstanding;
	reg	f_past_valid;
	wire	f_reset;

	always @(*)
		if (o_ram_dmod)
			assume(i_ram_data == o_ram_data);

	initial	f_past_valid = 1'b0;
	always @(posedge i_clk)
		f_past_valid &lt;= 1'b1;

	assign	f_reset = !f_past_valid;

	always @(*)
		if (o_ram_dmod)
			assert(i_ram_data == o_ram_data);

	</span><span class="tlx_comments">// Properties
	// 1. Wishbone
	</span><span class="tlx_untouched">fwb_slave #( .AW(AW), .DW(DW),
			.F_MAX_STALL(ACTIVATE_CLOCKS + REFRESH_CLOCKS
					+ ACTIVATE_CLOCKS + RDLY
					+ACTIVATE_CLOCKS),
			.F_MAX_ACK_DELAY(REFRESH_CLOCKS
				+ ACTIVATE_CLOCKS
				+ ACTIVATE_CLOCKS
				+ ACTIVATE_CLOCKS+RDLY),
			.F_LGDEPTH(5))
		fwb(i_clk, f_reset,
			i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr,
				i_wb_data, i_wb_sel,
			o_wb_ack, o_wb_stall, o_wb_data, 1'b0,
			f_nreqs, f_nacks, f_outstanding);

	</span><span class="tlx_comments">// 2. Proper startup ...
	// 3. Operation
	//   4. Refresh
	//   4. SDRAM request == WB request
	//

	// Once we leave maintenance mode (i.e. startup sequence), we *cannot*
	// go back into it.
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode)))
		assert(!maintenance_mode);

	</span><span class="tlx_comments">// On the very first clock, we must always start up in maintenance mode
	</span><span class="tlx_untouched">always @(posedge i_clk)
		if (!f_past_valid)
			assert(maintenance_mode);

	</span><span class="tlx_comments">// Just to make things simpler, assume no accesses to the core during
	// maintenance mode.  Such accesses might violate our minimum
	// acknowledgement time criteria for the wishbone above
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(maintenance_mode))
		assume(!i_wb_stb);

	</span><span class="tlx_comments">// Likewise, assert that there are *NO* outstanding transactions in
	// this maintenance mode
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(maintenance_mode))
		assert(f_outstanding == 0);

	</span><span class="tlx_comments">// ... and that while we are in maintenance mode, any incoming request
	// is stalled.  This guarantees that our assumptions above are kept
	// valid.
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(maintenance_mode))
		assume(o_wb_stall);

	</span><span class="tlx_comments">// If there are no attempts to access memory while in maintenance
	// mode, then there should never be any pending operations upon
	// completion of maintenance mode
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(maintenance_mode))
		assert(!r_pending);

	wire	[(2+AW+DW+DW/8-1):0]	f_pending, f_request;
	assign	f_pending = { r_pending, r_we, r_addr, r_data, r_sel };
	assign	f_request = {  i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(r_pending))&amp;&amp;($past(i_wb_cyc))
			&amp;&amp;(($past(o_ram_cs_n))
			||(!$past(o_ram_ras_n))
			||($past(o_ram_cas_n))) )
		assert($stable(f_pending));

	wire	[4:0]	f_cmd;
	assign	f_cmd = { o_ram_addr[10],
			o_ram_cs_n, o_ram_ras_n, o_ram_cas_n, o_ram_we_n };

`define	F_MODE_SET		5'b?0000
`define	F_BANK_PRECHARGE	5'b00010
`define	F_PRECHARGE_ALL		5'b10010
`define	F_BANK_ACTIVATE		5'b?0011
`define	F_WRITE			5'b00100
`define	F_READ			5'b00101
`define	F_REFRESH		5'b?0001
`define	F_NOOP			5'b?0111

`define	F_BANK_ACTIVATE_S	4'b0011
`define	F_REFRESH_S		4'b0001
`define	F_NOOP_S		4'b0111

	reg	[(AW-1):0]	f_next_addr;
	always @(*)
	begin
		f_next_addr = 0;
		f_next_addr[(AW-1):NCA-1] = r_addr[(AW-1):NCA-1] + 1'b1;
	end

	wire	[NRA-1:0]	f_next_row, f_this_row;
	wire	[1:0]	f_next_bank, f_this_bank;
	assign	f_next_row  = f_next_addr[(AW-1):(NCA+1)];
	assign	f_next_bank = f_next_addr[NCA:NCA-1];
	assign	f_this_bank = r_bs;
	assign	f_this_row  = r_row;

	always @(*)
	if (o_ram_cs_n==1'b0) casez(f_cmd)
	`F_MODE_SET:       begin end
	`F_BANK_PRECHARGE: begin end
	`F_PRECHARGE_ALL:  begin end
	`F_BANK_ACTIVATE:  begin end
	`F_WRITE:          begin end
	`F_READ:           begin end
	`F_REFRESH:        begin end
	default: assert(f_cmd[3:0] == `F_NOOP_S);
	endcase

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!maintenance_mode))
	casez(f_cmd)
	`F_BANK_ACTIVATE:	begin
		</span><span class="tlx_comments">// Can only activate de-activated banks
		</span><span class="tlx_untouched">assert(bank_active[o_ram_bs][1:0] == 0);
		</span><span class="tlx_comments">// Need to activate the right bank
		</span><span class="tlx_untouched">if (o_ram_bs == $past(f_this_bank))
			assert($past(f_this_row)==o_ram_addr);
		else if (o_ram_bs != 0)
		begin
			assert(o_ram_bs == $past(f_next_bank));
			assert($past(f_this_row)==o_ram_addr);
		end else begin
			assert(o_ram_bs == $past(f_next_bank));
			assert($past(f_next_row)==o_ram_addr);
		end end
	`F_BANK_PRECHARGE:	begin
		</span><span class="tlx_comments">// Can only precharge (de-active) a fully active bank
		</span><span class="tlx_untouched">assert(bank_active[o_ram_bs] == 3'b011);
		end
	`F_PRECHARGE_ALL:	begin
		</span><span class="tlx_comments">// If pre-charging all, one of the banks must be active and in
		// need of a pre-charge
		</span><span class="tlx_untouched">assert(
			(bank_active[0] == 3'b011)
			||(bank_active[1] == 3'b011)
			||(bank_active[2] == 3'b011)
			||(bank_active[3] == 3'b011) );
		end
	`F_WRITE:	begin
		assert($past(r_we));
		assert(bank_active[o_ram_bs] == 3'b111);
		assert(bank_row[o_ram_bs] == $past(f_this_row));
		assert(o_ram_bs == $past(f_this_bank));
		assert(o_ram_addr[0] == 1'b0);
		end
	`F_READ:	begin
		assert(!$past(r_we));
		assert(bank_active[o_ram_bs] == 3'b111);
		assert(bank_row[o_ram_bs] == $past(f_this_row));
		assert(o_ram_bs == $past(f_this_bank));
		assert(o_ram_addr[0] == 1'b0);
		end
	`F_REFRESH:	begin
		</span><span class="tlx_comments">// When giving a reset command, *all* banks must be inactive
		</span><span class="tlx_untouched">assert( (bank_active[0] == 3'h0)
			&amp;&amp;(bank_active[1] == 3'h0)
			&amp;&amp;(bank_active[2] == 3'h0)
			&amp;&amp;(bank_active[3] == 3'h0) );
		end
	default: assert((o_ram_cs_n)||(f_cmd[3:0] == `F_NOOP_S));
	endcase

	integer	f_k;
	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode)))
	begin
		for(f_k=0; f_k&lt;4; f_k=f_k+1)
			if (((f_cmd[3:0] != `F_BANK_ACTIVATE_S))
		 			||(o_ram_bs != f_k[1:0]))
				assert($stable(bank_row[f_k[1:0]]));
	end

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode))
		&amp;&amp;($past(f_cmd) != `F_READ)
		&amp;&amp;($past(f_cmd) != `F_WRITE) )
	begin
		if (($past(r_pending))&amp;&amp;($past(i_wb_cyc)))
			assert($stable(f_pending));
	end

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!maintenance_mode))
		if ((r_pending)&amp;&amp;(f_cmd != `F_READ)&amp;&amp;(f_cmd != `F_WRITE))
			assert(o_wb_stall);

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode)))
	casez($past(f_cmd))
	`F_BANK_ACTIVATE: begin
		assert(bank_active[$past(o_ram_bs)] == 3'b110);
		assert(bank_row[$past(o_ram_bs)] == $past(o_ram_addr));
		end
	`F_BANK_PRECHARGE: begin
		assert(bank_active[$past(o_ram_bs)] == 3'b001);
		end
	`F_PRECHARGE_ALL: begin
		assert(bank_active[0][2] == 1'b0);
		assert(bank_active[1][2] == 1'b0);
		assert(bank_active[2][2] == 1'b0);
		assert(bank_active[3][2] == 1'b0);
		end
	</span><span class="tlx_comments">// `F_WRITE:
	// `F_READ:
	</span><span class="tlx_untouched">`F_REFRESH: begin
		assert(r_barrell_ack == 0);
	end
	default: begin end
	endcase

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode)))
	begin
		assert(bank_active[0][1:0] == $past(bank_active[0][2:1]));
		assert(bank_active[1][1:0] == $past(bank_active[1][2:1]));
		assert(bank_active[2][1:0] == $past(bank_active[2][2:1]));
		assert(bank_active[3][1:0] == $past(bank_active[3][2:1]));
	end

	always @(*)
`ifdef	VERIFIC
	if (in_refresh)
`else
	if ((in_refresh)||(maintenance_mode))
`endif
	begin
		assert(bank_active[0] == 0);
		assert(bank_active[1] == 0);
		assert(bank_active[2] == 0);
		assert(bank_active[3] == 0);
	end

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(o_wb_ack)))
		assert(!o_wb_ack);

	reg	[3:0]	f_acks_pending;
	always @(*)
	begin
		f_acks_pending = 0;
		for(f_k=0; f_k&lt;RDLY; f_k = f_k + 1)
		if (r_barrell_ack[f_k])
			f_acks_pending = f_acks_pending + 1'b1;
	end

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(i_wb_cyc)))
		assert(r_barrell_ack == 0);


	wire	f_ispending;
	assign	f_ispending = (r_pending)&amp;&amp;((f_cmd != `F_READ)&amp;&amp;(f_cmd != `F_WRITE));
	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(i_wb_cyc))
		assert(f_outstanding == (f_ispending ? 1'b1:1'b0) + f_acks_pending);

</span><span class="tlx_comments">//	always @(posedge i_clk)
//	if (!i_wb_stb)
//	begin
//		restrict($stable(i_wb_we));
//		restrict($stable(i_wb_addr));
//		restrict($stable(i_wb_data));
//		if ((i_wb_stb)&amp;&amp;(!i_wb_we))
//			restrict(i_wb_data == 0);
//	end
//	always @(posedge i_clk)
//	if ((f_past_valid)&amp;&amp;(!$past(i_wb_stb))&amp;&amp;(i_wb_stb))
//		restrict(!$past(i_wb_cyc));

</span><span class="tlx_untouched">`ifdef	SHADOW_MEMORY
	reg	[15:0]		f_shadow_memory	[0:((1&lt;&lt;26)-1)];
	reg	[13+13-1:0]	f_shadow_addr;
	always @(*)
		f_shadow_addr &lt;= { bank_row[o_ram_bs], o_ram_addr[8:0] };
	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(f_past_valid,4)
			&amp;&amp;(!$past(maintenance_mode,4)))
		if (f_cmd == `F_WRITE)
		begin
			f_shadow_memory[f_shadow_addr] &lt;= o_ram_data;
			assert(o_ram_dmod==`DMOD_PUTOUTPUT);
			assert(o_ram_addr[0] == 1'b0);
		end else if ($past(f_cmd)== `F_WRITE)
		begin
			f_shadow_memory[f_shadow_addr[26-1:1], 1'b1}] &lt;= data;
			assert(o_ram_dmod==`DMOD_PUTOUTPUT);
		end else if ($past(f_cmd,4)==`F_READ)
		begin
			assert($past(o_ram_dmod)==`DMOD_GETINPUT);
			assert(o_ram_dmod==`DMOD_GETINPUT);
			assume(o_wb_data[31:16] == f_shadow_memory[$past(f_shadow_addr,4)]);
			assume(o_wb_data[15: 0] == f_shadow_memory[{ $past(f_shadow_addr[25:1],4), 1'b1}]);
			assert(r_barrell_ack[0]);
		end
`endif
	always @(posedge i_clk)
	if (startup_hold)
		assert(m_state == `RAM_POWER_UP);

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(m_state != `RAM_SET_MODE)
			&amp;&amp;($past(m_state) != `RAM_POWER_UP)
			&amp;&amp;($past(maintenance_clocks)!=0))
		assert(m_state == $past(m_state));

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(m_state)== `RAM_POWER_UP))
		assert((m_state == `RAM_POWER_UP)
			||(m_state == `RAM_SET_MODE));

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(m_state)== `RAM_SET_MODE))
		assert((m_state == `RAM_SET_MODE)
			||(m_state == `RAM_INITIAL_REFRESH));

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(m_state)== `RAM_INITIAL_REFRESH))
		assert((m_state == `RAM_INITIAL_REFRESH)
			||(m_state == `RAM_OPERATIONAL));

	always @(posedge i_clk)
	assert((m_state == `RAM_POWER_UP)
		||(m_state == `RAM_INITIAL_REFRESH)
		||(m_state == `RAM_SET_MODE));

	always @(posedge i_clk)
	if (maintenance_mode)
		assert(clocks_til_idle ==0);
	always @(posedge i_clk)
	if (maintenance_clocks_zero)
		assert(maintenance_clocks == 0);

	always @(posedge i_clk)
	if (maintenance_clocks == 0)
		assert(maintenance_clocks_zero);

	always @(posedge i_clk)
	if (maintenance_clocks != 0)
		assert(!maintenance_clocks_zero);

	always @(posedge i_clk)
	if (!maintenance_mode)
		assert(m_state == `RAM_INITIAL_REFRESH);

	always @(posedge i_clk)
	if (m_state == `RAM_INITIAL_REFRESH)
		assert(maintenance_clocks &lt;= 4'hc);

	always @(posedge i_clk)
	if (m_state == `RAM_SET_MODE)
		assert(maintenance_clocks &lt;= 4'h3);

	always @(*)
	assert( (m_state == `RAM_POWER_UP)
		||(m_state == `RAM_INITIAL_REFRESH)
		||(m_state == `RAM_SET_MODE));
		</span><span class="tlx_comments">// ||(m_state == `RAM_OPERATIONAL) );

	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(startup_hold))
	begin
		assert(o_ram_cke);
		assert(o_ram_cs_n);
		assert(o_ram_ras_n);
		assert(o_ram_cas_n);
		assert(o_ram_we_n);
		assert(o_ram_dqm);
	end
`endif
endmodule

   </span><span class="tlx_comments">// =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
</span><span class="tlx_structure">\TLV
   </span><span class="tlx_comments">//NCA=9, NRA=13, AW=(NCA+NRA+2)-1, DW=32;
   </span><span class="tlx_logic">$reset = *reset;
   $i_wb_cyc = *i_wb_cyc;
   $i_wb_stb = *i_wb_stb;
   $i_wb_we = *i_wb_we;
   $o_wb_stall = *o_wb_stall;
   $o_wb_data[31:0] = *o_wb_data;
   $o_ram_cke = *o_ram_cke;
   $o_ram_cs_n = *o_ram_cs_n;
   $o_ram_ras_n =*o_ram_ras_n;
   $o_ram_cas_n = *o_ram_cas_n;
   $o_ram_we_n = *o_ram_cas_n;
   $o_ram_we_n = *o_ram_we_n;
   $o_ram_bs[1:0] = *o_ram_bs;
   $o_ram_addr[12:0] = *o_ram_addr;
   $o_ram_dmod = *o_ram_dmod;
   $i_ram_data[15:0] = *i_ram_data;
   $o_ram_data[15:0] = *o_ram_data;
   $o_ram_dqm[1:0] = *o_ram_dqm;
   $o_debug[31:0] = *o_debug;
   $i_wb_cyc = *i_wb_cyc;
   $i_wb_stb = *i_wb_stb;
   $i_wb_we = *i_wb_we;
   $i_wb_addr[23:0] = *i_wb_addr;
   $i_wb_data[31:0] = *i_wb_data;
   $i_wb_sel = *i_wb_sel;
   $o_wb_ack = *o_wb_ack;
   $o_wb_stall = *o_wb_stall;
   $o_wb_data[31:0] = *o_wb_data; 
    
         
   </span><span class="tlx_comments">//...

   // Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">*passed = *cyc_cnt &gt; 40;
   *failed = 1'b0;
</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
////////////////////////////////////////////////////////////////////////////////
//
// Filename: 	wbsdram.v
//
// Project:	ArrowZip, a demonstration of the Arrow MAX1000 FPGA board
//
// Purpose:	Provide 32-bit wishbone access to the SDRAM memory on a MAX1000
//		board.  Specifically, on each access, the controller will
//	activate an appropriate bank of RAM (the SDRAM has four banks), and
//	then issue the read/write command.  In the case of walking off the
//	bank, the controller will activate the next bank before you get to it.
//	Upon concluding any wishbone access, all banks will be precharged and
//	returned to idle.
//
//	This particular implementation represents a second generation version
//	because my first version was too complex.  To speed things up, this
//	version includes an extra wait state where the wishbone inputs are
//	clocked into a flip flop before any action is taken on them.
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2015-2019, Gisselquist Technology, LLC
//
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of  the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// &lt;http://www.gnu.org/licenses/&gt; for a copy.
//
// License:	GPL, v3, as defined and found on www.gnu.org,
//		http://www.gnu.org/licenses/gpl.html
//
//
////////////////////////////////////////////////////////////////////////////////
//
//
</span><span class="tlx_untouched">`default_nettype	none
</span><span class="tlx_comments">//
</span><span class="tlx_untouched">`define	DMOD_GETINPUT	1'b0
`define	DMOD_PUTOUTPUT	1'b1
`define	RAM_OPERATIONAL	2'b00
`define	RAM_POWER_UP	2'b01
`define	RAM_SET_MODE	2'b10
`define	RAM_INITIAL_REFRESH	2'b11
</span><span class="tlx_comments">//
</span><span class="tlx_untouched">module	wbsdram(i_clk,
		i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel,
			o_wb_ack, o_wb_stall, o_wb_data,
		o_ram_cs_n, o_ram_cke, o_ram_ras_n, o_ram_cas_n, o_ram_we_n,
			o_ram_bs, o_ram_addr,
			o_ram_dmod, i_ram_data, o_ram_data, o_ram_dqm,
		o_debug);
	parameter	RDLY = 6;
	localparam	NCA=9, NRA=13, AW=(NCA+NRA+2)-1, DW=32;
	localparam	[NCA-2:0] COL_THRESHOLD = -16;
	input	wire			i_clk;
	</span><span class="tlx_comments">// Wishbone
	//	inputs
	</span><span class="tlx_untouched">input	wire			i_wb_cyc, i_wb_stb, i_wb_we;
	input	wire	[(AW-1):0]	i_wb_addr;
	input	wire	[(DW-1):0]	i_wb_data;
	input	wire	[(DW/8-1):0]	i_wb_sel;
	</span><span class="tlx_comments">//	outputs
	</span><span class="tlx_untouched">output	wire		o_wb_ack;
	output	reg		o_wb_stall;
	output	wire [31:0]	o_wb_data;
	</span><span class="tlx_comments">// SDRAM control
	</span><span class="tlx_untouched">output	wire		o_ram_cke;
	output	reg		o_ram_cs_n,
				o_ram_ras_n, o_ram_cas_n, o_ram_we_n;
	output	reg	[1:0]	o_ram_bs;
	output	reg	[12:0]	o_ram_addr;
	output	reg		o_ram_dmod;
	input		[15:0]	i_ram_data;
	output	reg	[15:0]	o_ram_data;
	output	reg	[1:0]	o_ram_dqm;
	output	wire [(DW-1):0]	o_debug;


	</span><span class="tlx_comments">// Calculate some metrics

	//
	// First, do we *need* a refresh now --- i.e., must we break out of
	// whatever we are doing to issue a refresh command?
	//
	// The step size here must be such that 8192 charges may be done in
	// 64 ms.  Thus for a clock of:
	//	ClkRate(MHz)	(64ms/1000(ms/s)*ClkRate)/8192
	//	100 MHz		781
	//	 96 MHz		750
	//	 92 MHz		718
	//	 88 MHz		687
	//	 84 MHz		656
	//	 80 MHz		625
	//
	// However, since we do two refresh cycles everytime we need a refresh,
	// this standard is close to overkill--but we'll use it anyway.  At
	// some later time we should address this, once we are entirely
	// convinced that the memory is otherwise working without failure.  Of
	// course, at that time, it may no longer be a priority ...
	//
	</span><span class="tlx_untouched">reg		need_refresh;
	reg	[9:0]	refresh_clk;
	wire	refresh_cmd;
	assign	refresh_cmd = (!o_ram_cs_n)&amp;&amp;(!o_ram_ras_n)&amp;&amp;(!o_ram_cas_n)&amp;&amp;(o_ram_we_n);
	initial	refresh_clk = 0;
	always @(posedge i_clk)
	begin
		if (refresh_cmd)
			</span><span class="tlx_comments">//refresh_clk &lt;= 10'd625; // Make suitable for 80 MHz clk
			</span><span class="tlx_untouched">refresh_clk &lt;= 10'd313; </span><span class="tlx_comments">// Make suitable for 40 MHz clk
		</span><span class="tlx_untouched">else if (|refresh_clk)
			refresh_clk &lt;= refresh_clk - 10'h1;
	end
	initial	need_refresh = 1'b0;
	always @(posedge i_clk)
		need_refresh &lt;= (refresh_clk == 10'h00)&amp;&amp;(!refresh_cmd);

	reg	in_refresh;
	reg	[2:0]	in_refresh_clk;
	initial	in_refresh_clk = 3'h0;
	always @(posedge i_clk)
		if (refresh_cmd)
			in_refresh_clk &lt;= 3'h6;
		else if (|in_refresh_clk)
			in_refresh_clk &lt;= in_refresh_clk - 3'h1;
	initial	in_refresh = 0;
	always @(posedge i_clk)
		in_refresh &lt;= (in_refresh_clk != 3'h0)||(refresh_cmd);
`ifdef	FORMAL
	always @(posedge i_clk)
		if (in_refresh)
			assert((refresh_cmd)||($past(in_refresh_clk) &lt;= 3'h6));
	always @(posedge i_clk)
		if (in_refresh)
			assert(refresh_clk==10'd619+{{(7){1'b0}},in_refresh_clk});
`endif


	reg	[2:0]		bank_active	[0:3];
	reg	[(RDLY-1):0]	r_barrell_ack;
	reg			r_pending;
	reg			r_we;
	reg	[(AW-1):0]	r_addr;
	reg	[31:0]		r_data;
	reg	[3:0]		r_sel;
	reg	[(AW-NCA-2):0]	bank_row	[0:3];


	</span><span class="tlx_comments">//
	// Second, do we *need* a precharge now --- must be break out of
	// whatever we are doing to issue a precharge command?
	//
	// Keep in mind, the number of clocks to wait has to be reduced by
	// the amount of time it may take us to go into a precharge state.
	// You may also notice that the precharge requirement is tighter
	// than this one, so ... perhaps this isn't as required?
	//

	</span><span class="tlx_untouched">reg	[2:0]	clocks_til_idle;
	reg	[1:0]	m_state;
	wire		bus_cyc;
	assign	bus_cyc  = ((i_wb_cyc)&amp;&amp;(i_wb_stb)&amp;&amp;(!o_wb_stall));
	reg	nxt_dmod;

	</span><span class="tlx_comments">// Pre-process pending operations
	</span><span class="tlx_untouched">wire	pending;
	initial	r_pending = 1'b0;
	reg	[(AW-1):0]	fwd_addr;
	initial	r_addr = 0;
	initial	fwd_addr = { {(AW-(NCA)){1'b0}}, 1'b1, {(NCA-1){1'b0}} };
	always @(posedge i_clk)
	begin
		fwd_addr[NCA-2:0] &lt;= 0;
		if (bus_cyc)
		begin
			r_pending &lt;= 1'b1;
			r_we      &lt;= i_wb_we;
			r_addr    &lt;= i_wb_addr;
			r_data    &lt;= i_wb_data;
			r_sel     &lt;= i_wb_sel;
			fwd_addr[AW-1:NCA-1]&lt;=i_wb_addr[(AW-1):(NCA-1)] + 1'b1;
		end else if ((!o_ram_cs_n)&amp;&amp;(o_ram_ras_n)&amp;&amp;(!o_ram_cas_n))
			r_pending &lt;= 1'b0;
		else if (!i_wb_cyc)
			r_pending &lt;= 1'b0;
	end

`ifdef	FORMAL
	always @(*)
		assert(fwd_addr[AW-1:NCA-1] == r_addr[(AW-1):(NCA-1)] + 1'b1);
	always @(*)
		assert(fwd_addr[NCA-3:0] == 0);
`endif

	wire	[1:0]	wb_bs, r_bs, fwd_bs;	</span><span class="tlx_comments">// Bank select
	</span><span class="tlx_untouched">assign	wb_bs = i_wb_addr[NCA:NCA-1];
	assign	r_bs  =    r_addr[NCA:NCA-1];
	assign fwd_bs =  fwd_addr[NCA:NCA-1];
	wire	[NRA-1:0]	wb_row, r_row, fwd_row;
	assign	wb_row = i_wb_addr[AW-1:NCA+1];
	assign	 r_row =    r_addr[AW-1:NCA+1];
	assign fwd_row =  fwd_addr[AW-1:NCA+1];

	reg	r_bank_valid;
	initial	r_bank_valid = 1'b0;
	always @(posedge i_clk)
		if (bus_cyc)
			r_bank_valid &lt;=((bank_active[wb_bs][2])
					&amp;&amp;(bank_row[wb_bs] == wb_row));
		else
			r_bank_valid &lt;= ((bank_active[r_bs][2])
				&amp;&amp;(bank_row[r_bs] == r_row));

	reg	fwd_bank_valid;
	initial	fwd_bank_valid = 0;
	always @(posedge i_clk)
		fwd_bank_valid &lt;= ((bank_active[fwd_bs][2])
				&amp;&amp;(bank_row[fwd_bs] == fwd_row));

	assign	pending = (r_pending)&amp;&amp;(o_wb_stall);

	</span><span class="tlx_comments">//
	//
	// Maintenance mode (i.e. startup) wires and logic
	</span><span class="tlx_untouched">reg	maintenance_mode;
	reg	m_ram_cs_n, m_ram_ras_n, m_ram_cas_n, m_ram_we_n, m_ram_dmod;
	reg	[(NRA-1):0]	m_ram_addr;
	</span><span class="tlx_comments">//
	//
	//

	// Address MAP:
	//	22-bits bits in, 23-bits out
	//
	//	22 1111 1111 1100 0000 0000
	//	10 9876 5432 1098 7654 3210
	//	rr rrrr rrrr rrBB cccc cccc 0
	//	                  8765 4321 0
	//
	</span><span class="tlx_untouched">initial r_barrell_ack = 0;
	initial	clocks_til_idle = 3'h0;
	initial o_wb_stall = 1'b1;
	initial	o_ram_dmod = `DMOD_GETINPUT;
	initial	nxt_dmod = `DMOD_GETINPUT;
	initial o_ram_cs_n  = 1'b0;
	initial o_ram_ras_n = 1'b1;
	initial o_ram_cas_n = 1'b1;
	initial o_ram_we_n  = 1'b1;
	initial	o_ram_dqm   = 2'b11;
	assign	o_ram_cke   = 1'b1;
	initial bank_active[0] = 3'b000;
	initial bank_active[1] = 3'b000;
	initial bank_active[2] = 3'b000;
	initial bank_active[3] = 3'b000;
	always @(posedge i_clk)
	if (maintenance_mode)
	begin
		bank_active[0] &lt;= 0;
		bank_active[1] &lt;= 0;
		bank_active[2] &lt;= 0;
		bank_active[3] &lt;= 0;
		r_barrell_ack[(RDLY-1):0] &lt;= 0;
		o_wb_stall  &lt;= 1'b1;
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">o_ram_cs_n  &lt;= m_ram_cs_n;
		o_ram_ras_n &lt;= m_ram_ras_n;
		o_ram_cas_n &lt;= m_ram_cas_n;
		o_ram_we_n  &lt;= m_ram_we_n;
		o_ram_dmod  &lt;= m_ram_dmod;
		o_ram_addr  &lt;= m_ram_addr;
		o_ram_bs    &lt;= 2'b00;
		nxt_dmod &lt;= `DMOD_GETINPUT;
	end else begin
		o_wb_stall &lt;= (r_pending)||(bus_cyc);
		if (!i_wb_cyc)
			r_barrell_ack &lt;= 0;
		else
			r_barrell_ack &lt;= r_barrell_ack &gt;&gt; 1;
		nxt_dmod &lt;= `DMOD_GETINPUT;
		o_ram_dmod &lt;= nxt_dmod;

		</span><span class="tlx_comments">//
		// We assume that, whatever state the bank is in, that it
		// continues in that state and set up a series of shift
		// registers to contain that information.  If it will not
		// continue in that state, all that therefore needs to be
		// done is to set bank_active[?][2] below.
		//
		</span><span class="tlx_untouched">bank_active[0] &lt;= { bank_active[0][2], bank_active[0][2:1] };
		bank_active[1] &lt;= { bank_active[1][2], bank_active[1][2:1] };
		bank_active[2] &lt;= { bank_active[2][2], bank_active[2][2:1] };
		bank_active[3] &lt;= { bank_active[3][2], bank_active[3][2:1] };
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">o_ram_cs_n &lt;= (!i_wb_cyc);
		</span><span class="tlx_comments">// o_ram_cke  &lt;= 1'b1;
		</span><span class="tlx_untouched">if (|clocks_til_idle[2:0])
			clocks_til_idle[2:0] &lt;= clocks_til_idle[2:0] - 3'h1;

		</span><span class="tlx_comments">// Default command is a
		//	NOOP if (i_wb_cyc)
		//	Device deselect if (!i_wb_cyc)
		// o_ram_cs_n  &lt;= (!i_wb_cyc) above, NOOP
		</span><span class="tlx_untouched">o_ram_ras_n &lt;= 1'b1;
		o_ram_cas_n &lt;= 1'b1;
		o_ram_we_n  &lt;= 1'b1;

		</span><span class="tlx_comments">// o_ram_data &lt;= r_data[15:0];

		</span><span class="tlx_untouched">if (nxt_dmod)
			;
		else
		if ((!i_wb_cyc)||(need_refresh))
		begin </span><span class="tlx_comments">// Issue a precharge all command (if any banks are open),
		// otherwise an autorefresh command
			</span><span class="tlx_untouched">if ((bank_active[0][2:1]==2'b10)
					||(bank_active[1][2:1]==2'b10)
					||(bank_active[2][2:1]==2'b10)
					||(bank_active[3][2:1]==2'b10)
				||(|clocks_til_idle[2:0]))
			begin
				</span><span class="tlx_comments">// Do nothing this clock
				// Can't precharge a bank immediately after
				// activating it
			</span><span class="tlx_untouched">end else if (bank_active[0][2]
				||(bank_active[1][2])
				||(bank_active[2][2])
				||(bank_active[3][2]))
			begin  </span><span class="tlx_comments">// Close all active banks
				</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
				o_ram_ras_n &lt;= 1'b0;
				o_ram_cas_n &lt;= 1'b1;
				o_ram_we_n  &lt;= 1'b0;
				o_ram_addr[10] &lt;= 1'b1;
				bank_active[0][2] &lt;= 1'b0;
				bank_active[1][2] &lt;= 1'b0;
				bank_active[2][2] &lt;= 1'b0;
				bank_active[3][2] &lt;= 1'b0;
			end else if ((|bank_active[0])
					||(|bank_active[1])
					||(|bank_active[2])
					||(|bank_active[3]))
				</span><span class="tlx_comments">// Can't precharge yet, the bus is still busy
			</span><span class="tlx_untouched">begin end else if ((!in_refresh)&amp;&amp;((refresh_clk[9:8]==2'b00)||(need_refresh)))
			begin </span><span class="tlx_comments">// Send autorefresh command
				</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
				o_ram_ras_n &lt;= 1'b0;
				o_ram_cas_n &lt;= 1'b0;
				o_ram_we_n  &lt;= 1'b1;
			end </span><span class="tlx_comments">// Else just send NOOP's, the default command
		</span><span class="tlx_untouched">end else if (in_refresh)
		begin
			</span><span class="tlx_comments">// NOOPS only here, until we are out of refresh
		</span><span class="tlx_untouched">end else if ((pending)&amp;&amp;(!r_bank_valid)&amp;&amp;(bank_active[r_bs]==3'h0))
		begin </span><span class="tlx_comments">// Need to activate the requested bank
			</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
			o_ram_ras_n &lt;= 1'b0;
			o_ram_cas_n &lt;= 1'b1;
			o_ram_we_n  &lt;= 1'b1;
			o_ram_addr  &lt;= r_row;
			o_ram_bs    &lt;= r_bs;
			</span><span class="tlx_comments">// clocks_til_idle[2:0] &lt;= 1;
			</span><span class="tlx_untouched">bank_active[r_bs][2] &lt;= 1'b1;
			bank_row[r_bs] &lt;= r_row;
			</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">end else if ((pending)&amp;&amp;(!r_bank_valid)
				&amp;&amp;(bank_active[r_bs]==3'b111))
		begin </span><span class="tlx_comments">// Need to close an active bank
			</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
			o_ram_ras_n &lt;= 1'b0;
			o_ram_cas_n &lt;= 1'b1;
			o_ram_we_n  &lt;= 1'b0;
			</span><span class="tlx_comments">// o_ram_addr  &lt;= r_addr[(AW-1):(NCA+2)];
			</span><span class="tlx_untouched">o_ram_addr[10]&lt;= 1'b0;
			o_ram_bs    &lt;= r_bs;
			</span><span class="tlx_comments">// clocks_til_idle[2:0] &lt;= 1;
			</span><span class="tlx_untouched">bank_active[r_bs][2] &lt;= 1'b0;
			</span><span class="tlx_comments">// bank_row[r_bs] &lt;= r_row;
		</span><span class="tlx_untouched">end else if ((pending)&amp;&amp;(!r_we)
				&amp;&amp;(bank_active[r_bs][2])
				&amp;&amp;(r_bank_valid)
				&amp;&amp;(clocks_til_idle[2:0] &lt; 4))
		begin </span><span class="tlx_comments">// Issue the read command
			</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
			o_ram_ras_n &lt;= 1'b1;
			o_ram_cas_n &lt;= 1'b0;
			o_ram_we_n  &lt;= 1'b1;
			o_ram_addr  &lt;= { 4'h0, r_addr[NCA-2:0], 1'b0 };
			o_ram_bs    &lt;= r_bs;
			clocks_til_idle[2:0] &lt;= 4;

			o_wb_stall &lt;= 1'b0;
			r_barrell_ack[(RDLY-1)] &lt;= 1'b1;
		end else if ((pending)&amp;&amp;(r_we)
			&amp;&amp;(bank_active[r_bs][2])
			&amp;&amp;(r_bank_valid)
			&amp;&amp;(clocks_til_idle[2:0] == 0))
		begin </span><span class="tlx_comments">// Issue the write command
			</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
			o_ram_ras_n &lt;= 1'b1;
			o_ram_cas_n &lt;= 1'b0;
			o_ram_we_n  &lt;= 1'b0;
			o_ram_addr  &lt;= { 4'h0, r_addr[NCA-2:0], 1'b0 };
			o_ram_bs    &lt;= r_bs;
			clocks_til_idle[2:0] &lt;= 3'h1;

			o_wb_stall &lt;= 1'b0;
			r_barrell_ack[1] &lt;= 1'b1;
			</span><span class="tlx_comments">// o_ram_data &lt;= r_data[31:16];
			//
			</span><span class="tlx_untouched">o_ram_dmod &lt;= `DMOD_PUTOUTPUT;
			nxt_dmod &lt;= `DMOD_PUTOUTPUT;
		end else if ((r_pending)&amp;&amp;(r_addr[(NCA-2):0] &gt;= COL_THRESHOLD)
				&amp;&amp;(!fwd_bank_valid))
		begin
			</span><span class="tlx_comments">// Do I need to close the next bank I'll need?
			</span><span class="tlx_untouched">if (bank_active[fwd_bs][2:1]==2'b11)
			begin </span><span class="tlx_comments">// Need to close the bank first
				</span><span class="tlx_untouched">o_ram_cs_n &lt;= 1'b0;
				o_ram_ras_n &lt;= 1'b0;
				o_ram_cas_n &lt;= 1'b1;
				o_ram_we_n  &lt;= 1'b0;
				o_ram_addr[10] &lt;= 1'b0;
				o_ram_bs       &lt;= fwd_bs;
				bank_active[fwd_bs][2] &lt;= 1'b0;
			end else if (bank_active[fwd_bs]==0)
			begin
				</span><span class="tlx_comments">// Need to (pre-)activate the next bank
				</span><span class="tlx_untouched">o_ram_cs_n  &lt;= 1'b0;
				o_ram_ras_n &lt;= 1'b0;
				o_ram_cas_n &lt;= 1'b1;
				o_ram_we_n  &lt;= 1'b1;
				o_ram_addr  &lt;= fwd_row;
				o_ram_bs    &lt;= fwd_bs;
				</span><span class="tlx_comments">// clocks_til_idle[3:0] &lt;= 1;
				</span><span class="tlx_untouched">bank_active[fwd_bs] &lt;= 3'h4;
				bank_row[fwd_bs] &lt;= fwd_row;
			end
		end
		if (!i_wb_cyc)
			r_barrell_ack &lt;= 0;
	end

	reg		startup_hold;
	reg	[15:0]	startup_idle;
	initial	startup_idle = 16'd20500;
	initial	startup_hold = 1'b1;
	always @(posedge i_clk)
		if (|startup_idle)
			startup_idle &lt;= startup_idle - 1'b1;
	always @(posedge i_clk)
		startup_hold &lt;= |startup_idle;
`ifdef	FORMAL
	always @(*)
		if (startup_hold)
			assert(maintenance_mode);
	always @(*)
		if (|startup_idle)
			assert(startup_hold);
`endif

	reg	[3:0]	maintenance_clocks;
	reg		maintenance_clocks_zero;
	initial	maintenance_mode = 1'b1;
	initial	maintenance_clocks = 4'hf;
	initial	maintenance_clocks_zero = 1'b0;
	initial	m_ram_addr  = { 3'b000, 1'b0, 2'b00, 3'b010, 1'b0, 3'b001 };
	initial	m_state = `RAM_POWER_UP;
	initial	m_ram_cs_n  = 1'b1;
	initial	m_ram_ras_n = 1'b1;
	initial	m_ram_cas_n = 1'b1;
	initial	m_ram_we_n  = 1'b1;
	initial	m_ram_dmod  = `DMOD_GETINPUT;
	always @(posedge i_clk)
	begin
		if (!maintenance_clocks_zero)
		begin
			maintenance_clocks &lt;= maintenance_clocks - 4'h1;
			maintenance_clocks_zero &lt;= (maintenance_clocks == 4'h1);
		end
		</span><span class="tlx_comments">// The only time the RAM address matters is when we set
		// the mode.  At other times, addr[10] matters, but the rest
		// is ignored.  Hence ... we'll set it to a constant.
		</span><span class="tlx_untouched">m_ram_addr  &lt;= { 3'b000, 1'b0, 2'b00, 3'b010, 1'b0, 3'b001 };
		if (m_state == `RAM_POWER_UP)
		begin
			</span><span class="tlx_comments">// All signals must be held in NOOP state during powerup
			// m_ram_cke &lt;= 1'b1;
			</span><span class="tlx_untouched">m_ram_cs_n  &lt;= 1'b1;
			m_ram_ras_n &lt;= 1'b1;
			m_ram_cas_n &lt;= 1'b1;
			m_ram_we_n  &lt;= 1'b1;
			m_ram_dmod  &lt;= `DMOD_GETINPUT;
			if (!startup_hold)
			begin
				m_state &lt;= `RAM_SET_MODE;
				maintenance_clocks &lt;= 4'h3;
				maintenance_clocks_zero &lt;= 1'b0;
				</span><span class="tlx_comments">// Precharge all cmd
				</span><span class="tlx_untouched">m_ram_cs_n  &lt;= 1'b0;
				m_ram_ras_n &lt;= 1'b0;
				m_ram_cas_n &lt;= 1'b1;
				m_ram_we_n  &lt;= 1'b0;
				m_ram_addr[10] &lt;= 1'b1;
			end
		end else if (m_state == `RAM_SET_MODE)
		begin
			</span><span class="tlx_comments">// Wait
			</span><span class="tlx_untouched">m_ram_cs_n     &lt;= 1'b1;
			m_ram_cs_n     &lt;= 1'b1;
			m_ram_ras_n    &lt;= 1'b1;
			m_ram_cas_n    &lt;= 1'b1;
			m_ram_we_n     &lt;= 1'b1;
			m_ram_addr[10] &lt;= 1'b1;

			if (maintenance_clocks_zero)
			begin
				</span><span class="tlx_comments">// Set mode cycle
				</span><span class="tlx_untouched">m_ram_cs_n  &lt;= 1'b0;
				m_ram_ras_n &lt;= 1'b0;
				m_ram_cas_n &lt;= 1'b0;
				m_ram_we_n  &lt;= 1'b0;
				m_ram_dmod  &lt;= `DMOD_GETINPUT;
				m_ram_addr[10] &lt;= 1'b0;

				m_state &lt;= `RAM_INITIAL_REFRESH;
				maintenance_clocks &lt;= 4'hc;
				maintenance_clocks_zero &lt;= 1'b0;
			end
		end else if (m_state == `RAM_INITIAL_REFRESH)
		begin
			</span><span class="tlx_comments">// Refresh command
			</span><span class="tlx_untouched">if (maintenance_clocks &gt; 4'ha)
				</span><span class="tlx_comments">// Wait two clocks first
				</span><span class="tlx_untouched">m_ram_cs_n &lt;= 1'b1;
			else if (maintenance_clocks &gt; 4'h2)
				m_ram_cs_n  &lt;= 1'b0;
			else
				m_ram_cs_n &lt;= 1'b1;
			m_ram_ras_n &lt;= 1'b0;
			m_ram_cas_n &lt;= 1'b0;
			m_ram_we_n  &lt;= 1'b1;
			m_ram_dmod  &lt;= `DMOD_GETINPUT;
			</span><span class="tlx_comments">// m_ram_addr  &lt;= { 3'b000, 1'b0, 2'b00, 3'b010, 1'b0, 3'b001 };
			</span><span class="tlx_untouched">if (maintenance_clocks_zero)
				maintenance_mode &lt;= 1'b0;
		end
	end

	always @(posedge i_clk)
	if (nxt_dmod)
		o_ram_data &lt;= r_data[15:0];
	else
		o_ram_data &lt;= r_data[31:16];

	always @(posedge i_clk)
	if (maintenance_mode)
		o_ram_dqm &lt;= 2'b11;
	else if (r_we)
	begin
		if (nxt_dmod)
			o_ram_dqm &lt;= ~r_sel[1:0];
		else
			o_ram_dqm &lt;= ~r_sel[3:2];
	end else
		o_ram_dqm &lt;= 2'b00;

`ifdef	VERILATOR
	</span><span class="tlx_comments">// While I hate to build something that works one way under Verilator
	// and another way in practice, this really isn't that.  The problem
	// \/erilator is having is resolved in toplevel.v---one file that
	// \/erilator doesn't implement.  In toplevel.v, there's not only a
	// single clocked latch but two taking place.  Here, we replicate one
	// of those.  The second takes place (somehow) within the sdramsim.cpp
	// file.
	</span><span class="tlx_untouched">reg	[15:0]	ram_data, last_ram_data;
	always @(posedge i_clk)
		ram_data &lt;= i_ram_data;
	always @(posedge i_clk)
		last_ram_data &lt;= ram_data;
	assign	o_wb_data = { last_ram_data, ram_data };
`else
	reg	[15:0]	last_ram_data;
	always @(posedge i_clk)
		last_ram_data &lt;= i_ram_data;
	assign	o_wb_data = { last_ram_data, i_ram_data };
`endif
	assign	o_wb_ack  = r_barrell_ack[0];

	</span><span class="tlx_comments">//
	// The following outputs are not necessary for the functionality of
	// the SDRAM, but they can be used to feed an external &quot;scope&quot; to
	// get an idea of what the internals of this SDRAM are doing.
	//
	// Just be aware of the r_we: it is set based upon the currently pending
	// transaction, or (if none is pending) based upon the last transaction.
	// If you want to capture the first value &quot;written&quot; to the device,
	// you'll need to write a nothing value to the device to set r_we.
	// The first value &quot;written&quot; to the device can be caught in the next
	// interaction after that.
	//
	</span><span class="tlx_untouched">reg	trigger;
	always @(posedge i_clk)
		trigger &lt;= ((o_wb_data[15:0]==o_wb_data[31:16])
			&amp;&amp;(o_wb_ack)&amp;&amp;(!i_wb_we));


	assign	o_debug = { i_wb_cyc, i_wb_stb, i_wb_we, o_wb_ack, o_wb_stall, </span><span class="tlx_comments">// 5
		</span><span class="tlx_untouched">o_ram_cs_n, o_ram_ras_n, o_ram_cas_n, o_ram_we_n, o_ram_bs,</span><span class="tlx_comments">//6
			</span><span class="tlx_untouched">o_ram_dmod, r_pending, 				</span><span class="tlx_comments">//  2
			</span><span class="tlx_untouched">trigger,					</span><span class="tlx_comments">//  1
			</span><span class="tlx_untouched">o_ram_addr[9:0],				</span><span class="tlx_comments">// 10 more
			</span><span class="tlx_untouched">(r_we) ? { o_ram_data[7:0] }			</span><span class="tlx_comments">//  8 values
				</span><span class="tlx_untouched">: { o_wb_data[23:20], o_wb_data[3:0] }
			</span><span class="tlx_comments">// i_ram_data[7:0]
			 </span><span class="tlx_untouched">};

	</span><span class="tlx_comments">// Make Verilator happy
	// verilator lint_off UNUSED
	</span><span class="tlx_untouched">wire	[NCA-1:0]	unused;
	assign	unused = { fwd_addr[NCA-1:0] };
	</span><span class="tlx_comments">// verilator lint_on  UNUSED
</span><span class="tlx_untouched">`ifdef	FORMAL
	localparam	REFRESH_CLOCKS = 6;
	localparam	ACTIVATE_CLOCKS = 6;

	</span><span class="tlx_comments">// This device is 32MB, assert such
	</span><span class="tlx_untouched">always @(*)
		assert(AW == 23);
	always @(*)
		assert(NRA+NCA+2 == AW+1);

	wire	[(5-1):0]	f_nreqs, f_nacks, f_outstanding;
	reg	f_past_valid;
	wire	f_reset;

	always @(*)
		if (o_ram_dmod)
			assume(i_ram_data == o_ram_data);

	initial	f_past_valid = 1'b0;
	always @(posedge i_clk)
		f_past_valid &lt;= 1'b1;

	assign	f_reset = !f_past_valid;

	always @(*)
		if (o_ram_dmod)
			assert(i_ram_data == o_ram_data);

	</span><span class="tlx_comments">// Properties
	// 1. Wishbone
	</span><span class="tlx_untouched">fwb_slave #( .AW(AW), .DW(DW),
			.F_MAX_STALL(ACTIVATE_CLOCKS + REFRESH_CLOCKS
					+ ACTIVATE_CLOCKS + RDLY
					+ACTIVATE_CLOCKS),
			.F_MAX_ACK_DELAY(REFRESH_CLOCKS
				+ ACTIVATE_CLOCKS
				+ ACTIVATE_CLOCKS
				+ ACTIVATE_CLOCKS+RDLY),
			.F_LGDEPTH(5))
		fwb(i_clk, f_reset,
			i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr,
				i_wb_data, i_wb_sel,
			o_wb_ack, o_wb_stall, o_wb_data, 1'b0,
			f_nreqs, f_nacks, f_outstanding);

	</span><span class="tlx_comments">// 2. Proper startup ...
	// 3. Operation
	//   4. Refresh
	//   4. SDRAM request == WB request
	//

	// Once we leave maintenance mode (i.e. startup sequence), we *cannot*
	// go back into it.
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode)))
		assert(!maintenance_mode);

	</span><span class="tlx_comments">// On the very first clock, we must always start up in maintenance mode
	</span><span class="tlx_untouched">always @(posedge i_clk)
		if (!f_past_valid)
			assert(maintenance_mode);

	</span><span class="tlx_comments">// Just to make things simpler, assume no accesses to the core during
	// maintenance mode.  Such accesses might violate our minimum
	// acknowledgement time criteria for the wishbone above
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(maintenance_mode))
		assume(!i_wb_stb);

	</span><span class="tlx_comments">// Likewise, assert that there are *NO* outstanding transactions in
	// this maintenance mode
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(maintenance_mode))
		assert(f_outstanding == 0);

	</span><span class="tlx_comments">// ... and that while we are in maintenance mode, any incoming request
	// is stalled.  This guarantees that our assumptions above are kept
	// valid.
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(maintenance_mode))
		assume(o_wb_stall);

	</span><span class="tlx_comments">// If there are no attempts to access memory while in maintenance
	// mode, then there should never be any pending operations upon
	// completion of maintenance mode
	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(maintenance_mode))
		assert(!r_pending);

	wire	[(2+AW+DW+DW/8-1):0]	f_pending, f_request;
	assign	f_pending = { r_pending, r_we, r_addr, r_data, r_sel };
	assign	f_request = {  i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(r_pending))&amp;&amp;($past(i_wb_cyc))
			&amp;&amp;(($past(o_ram_cs_n))
			||(!$past(o_ram_ras_n))
			||($past(o_ram_cas_n))) )
		assert($stable(f_pending));

	wire	[4:0]	f_cmd;
	assign	f_cmd = { o_ram_addr[10],
			o_ram_cs_n, o_ram_ras_n, o_ram_cas_n, o_ram_we_n };

`define	F_MODE_SET		5'b?0000
`define	F_BANK_PRECHARGE	5'b00010
`define	F_PRECHARGE_ALL		5'b10010
`define	F_BANK_ACTIVATE		5'b?0011
`define	F_WRITE			5'b00100
`define	F_READ			5'b00101
`define	F_REFRESH		5'b?0001
`define	F_NOOP			5'b?0111

`define	F_BANK_ACTIVATE_S	4'b0011
`define	F_REFRESH_S		4'b0001
`define	F_NOOP_S		4'b0111

	reg	[(AW-1):0]	f_next_addr;
	always @(*)
	begin
		f_next_addr = 0;
		f_next_addr[(AW-1):NCA-1] = r_addr[(AW-1):NCA-1] + 1'b1;
	end

	wire	[NRA-1:0]	f_next_row, f_this_row;
	wire	[1:0]	f_next_bank, f_this_bank;
	assign	f_next_row  = f_next_addr[(AW-1):(NCA+1)];
	assign	f_next_bank = f_next_addr[NCA:NCA-1];
	assign	f_this_bank = r_bs;
	assign	f_this_row  = r_row;

	always @(*)
	if (o_ram_cs_n==1'b0) casez(f_cmd)
	`F_MODE_SET:       begin end
	`F_BANK_PRECHARGE: begin end
	`F_PRECHARGE_ALL:  begin end
	`F_BANK_ACTIVATE:  begin end
	`F_WRITE:          begin end
	`F_READ:           begin end
	`F_REFRESH:        begin end
	default: assert(f_cmd[3:0] == `F_NOOP_S);
	endcase

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!maintenance_mode))
	casez(f_cmd)
	`F_BANK_ACTIVATE:	begin
		</span><span class="tlx_comments">// Can only activate de-activated banks
		</span><span class="tlx_untouched">assert(bank_active[o_ram_bs][1:0] == 0);
		</span><span class="tlx_comments">// Need to activate the right bank
		</span><span class="tlx_untouched">if (o_ram_bs == $past(f_this_bank))
			assert($past(f_this_row)==o_ram_addr);
		else if (o_ram_bs != 0)
		begin
			assert(o_ram_bs == $past(f_next_bank));
			assert($past(f_this_row)==o_ram_addr);
		end else begin
			assert(o_ram_bs == $past(f_next_bank));
			assert($past(f_next_row)==o_ram_addr);
		end end
	`F_BANK_PRECHARGE:	begin
		</span><span class="tlx_comments">// Can only precharge (de-active) a fully active bank
		</span><span class="tlx_untouched">assert(bank_active[o_ram_bs] == 3'b011);
		end
	`F_PRECHARGE_ALL:	begin
		</span><span class="tlx_comments">// If pre-charging all, one of the banks must be active and in
		// need of a pre-charge
		</span><span class="tlx_untouched">assert(
			(bank_active[0] == 3'b011)
			||(bank_active[1] == 3'b011)
			||(bank_active[2] == 3'b011)
			||(bank_active[3] == 3'b011) );
		end
	`F_WRITE:	begin
		assert($past(r_we));
		assert(bank_active[o_ram_bs] == 3'b111);
		assert(bank_row[o_ram_bs] == $past(f_this_row));
		assert(o_ram_bs == $past(f_this_bank));
		assert(o_ram_addr[0] == 1'b0);
		end
	`F_READ:	begin
		assert(!$past(r_we));
		assert(bank_active[o_ram_bs] == 3'b111);
		assert(bank_row[o_ram_bs] == $past(f_this_row));
		assert(o_ram_bs == $past(f_this_bank));
		assert(o_ram_addr[0] == 1'b0);
		end
	`F_REFRESH:	begin
		</span><span class="tlx_comments">// When giving a reset command, *all* banks must be inactive
		</span><span class="tlx_untouched">assert( (bank_active[0] == 3'h0)
			&amp;&amp;(bank_active[1] == 3'h0)
			&amp;&amp;(bank_active[2] == 3'h0)
			&amp;&amp;(bank_active[3] == 3'h0) );
		end
	default: assert((o_ram_cs_n)||(f_cmd[3:0] == `F_NOOP_S));
	endcase

	integer	f_k;
	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode)))
	begin
		for(f_k=0; f_k&lt;4; f_k=f_k+1)
			if (((f_cmd[3:0] != `F_BANK_ACTIVATE_S))
		 			||(o_ram_bs != f_k[1:0]))
				assert($stable(bank_row[f_k[1:0]]));
	end

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode))
		&amp;&amp;($past(f_cmd) != `F_READ)
		&amp;&amp;($past(f_cmd) != `F_WRITE) )
	begin
		if (($past(r_pending))&amp;&amp;($past(i_wb_cyc)))
			assert($stable(f_pending));
	end

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!maintenance_mode))
		if ((r_pending)&amp;&amp;(f_cmd != `F_READ)&amp;&amp;(f_cmd != `F_WRITE))
			assert(o_wb_stall);

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode)))
	casez($past(f_cmd))
	`F_BANK_ACTIVATE: begin
		assert(bank_active[$past(o_ram_bs)] == 3'b110);
		assert(bank_row[$past(o_ram_bs)] == $past(o_ram_addr));
		end
	`F_BANK_PRECHARGE: begin
		assert(bank_active[$past(o_ram_bs)] == 3'b001);
		end
	`F_PRECHARGE_ALL: begin
		assert(bank_active[0][2] == 1'b0);
		assert(bank_active[1][2] == 1'b0);
		assert(bank_active[2][2] == 1'b0);
		assert(bank_active[3][2] == 1'b0);
		end
	</span><span class="tlx_comments">// `F_WRITE:
	// `F_READ:
	</span><span class="tlx_untouched">`F_REFRESH: begin
		assert(r_barrell_ack == 0);
	end
	default: begin end
	endcase

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(maintenance_mode)))
	begin
		assert(bank_active[0][1:0] == $past(bank_active[0][2:1]));
		assert(bank_active[1][1:0] == $past(bank_active[1][2:1]));
		assert(bank_active[2][1:0] == $past(bank_active[2][2:1]));
		assert(bank_active[3][1:0] == $past(bank_active[3][2:1]));
	end

	always @(*)
`ifdef	VERIFIC
	if (in_refresh)
`else
	if ((in_refresh)||(maintenance_mode))
`endif
	begin
		assert(bank_active[0] == 0);
		assert(bank_active[1] == 0);
		assert(bank_active[2] == 0);
		assert(bank_active[3] == 0);
	end

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(o_wb_ack)))
		assert(!o_wb_ack);

	reg	[3:0]	f_acks_pending;
	always @(*)
	begin
		f_acks_pending = 0;
		for(f_k=0; f_k&lt;RDLY; f_k = f_k + 1)
		if (r_barrell_ack[f_k])
			f_acks_pending = f_acks_pending + 1'b1;
	end

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(i_wb_cyc)))
		assert(r_barrell_ack == 0);


	wire	f_ispending;
	assign	f_ispending = (r_pending)&amp;&amp;((f_cmd != `F_READ)&amp;&amp;(f_cmd != `F_WRITE));
	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(i_wb_cyc))
		assert(f_outstanding == (f_ispending ? 1'b1:1'b0) + f_acks_pending);

</span><span class="tlx_comments">//	always @(posedge i_clk)
//	if (!i_wb_stb)
//	begin
//		restrict($stable(i_wb_we));
//		restrict($stable(i_wb_addr));
//		restrict($stable(i_wb_data));
//		if ((i_wb_stb)&amp;&amp;(!i_wb_we))
//			restrict(i_wb_data == 0);
//	end
//	always @(posedge i_clk)
//	if ((f_past_valid)&amp;&amp;(!$past(i_wb_stb))&amp;&amp;(i_wb_stb))
//		restrict(!$past(i_wb_cyc));

</span><span class="tlx_untouched">`ifdef	SHADOW_MEMORY
	reg	[15:0]		f_shadow_memory	[0:((1&lt;&lt;26)-1)];
	reg	[13+13-1:0]	f_shadow_addr;
	always @(*)
		f_shadow_addr &lt;= { bank_row[o_ram_bs], o_ram_addr[8:0] };
	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(f_past_valid,4)
			&amp;&amp;(!$past(maintenance_mode,4)))
		if (f_cmd == `F_WRITE)
		begin
			f_shadow_memory[f_shadow_addr] &lt;= o_ram_data;
			assert(o_ram_dmod==`DMOD_PUTOUTPUT);
			assert(o_ram_addr[0] == 1'b0);
		end else if ($past(f_cmd)== `F_WRITE)
		begin
			f_shadow_memory[f_shadow_addr[26-1:1], 1'b1}] &lt;= data;
			assert(o_ram_dmod==`DMOD_PUTOUTPUT);
		end else if ($past(f_cmd,4)==`F_READ)
		begin
			assert($past(o_ram_dmod)==`DMOD_GETINPUT);
			assert(o_ram_dmod==`DMOD_GETINPUT);
			assume(o_wb_data[31:16] == f_shadow_memory[$past(f_shadow_addr,4)]);
			assume(o_wb_data[15: 0] == f_shadow_memory[{ $past(f_shadow_addr[25:1],4), 1'b1}]);
			assert(r_barrell_ack[0]);
		end
`endif
	always @(posedge i_clk)
	if (startup_hold)
		assert(m_state == `RAM_POWER_UP);

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(m_state != `RAM_SET_MODE)
			&amp;&amp;($past(m_state) != `RAM_POWER_UP)
			&amp;&amp;($past(maintenance_clocks)!=0))
		assert(m_state == $past(m_state));

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(m_state)== `RAM_POWER_UP))
		assert((m_state == `RAM_POWER_UP)
			||(m_state == `RAM_SET_MODE));

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(m_state)== `RAM_SET_MODE))
		assert((m_state == `RAM_SET_MODE)
			||(m_state == `RAM_INITIAL_REFRESH));

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(m_state)== `RAM_INITIAL_REFRESH))
		assert((m_state == `RAM_INITIAL_REFRESH)
			||(m_state == `RAM_OPERATIONAL));

	always @(posedge i_clk)
	assert((m_state == `RAM_POWER_UP)
		||(m_state == `RAM_INITIAL_REFRESH)
		||(m_state == `RAM_SET_MODE));

	always @(posedge i_clk)
	if (maintenance_mode)
		assert(clocks_til_idle ==0);
	always @(posedge i_clk)
	if (maintenance_clocks_zero)
		assert(maintenance_clocks == 0);

	always @(posedge i_clk)
	if (maintenance_clocks == 0)
		assert(maintenance_clocks_zero);

	always @(posedge i_clk)
	if (maintenance_clocks != 0)
		assert(!maintenance_clocks_zero);

	always @(posedge i_clk)
	if (!maintenance_mode)
		assert(m_state == `RAM_INITIAL_REFRESH);

	always @(posedge i_clk)
	if (m_state == `RAM_INITIAL_REFRESH)
		assert(maintenance_clocks &lt;= 4'hc);

	always @(posedge i_clk)
	if (m_state == `RAM_SET_MODE)
		assert(maintenance_clocks &lt;= 4'h3);

	always @(*)
	assert( (m_state == `RAM_POWER_UP)
		||(m_state == `RAM_INITIAL_REFRESH)
		||(m_state == `RAM_SET_MODE));
		</span><span class="tlx_comments">// ||(m_state == `RAM_OPERATIONAL) );

	</span><span class="tlx_untouched">always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(startup_hold))
	begin
		assert(o_ram_cke);
		assert(o_ram_cs_n);
		assert(o_ram_ras_n);
		assert(o_ram_cas_n);
		assert(o_ram_we_n);
		assert(o_ram_dqm);
	end
`endif
endmodule

   </span><span class="tlx_comments">// =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   //NCA=9, NRA=13, AW=(NCA+NRA+2)-1, DW=32;
   </span><span class="tlx_logic">assign L0_reset_a0 = reset;
   assign L0_i_wb_cyc_a0 = i_wb_cyc;
   assign L0_i_wb_stb_a0 = i_wb_stb;
   assign L0_i_wb_we_a0 = i_wb_we;
   assign L0_o_wb_stall_a0 = o_wb_stall;
   assign L0_o_wb_data_a0[31:0] = o_wb_data;
   assign L0_o_ram_cke_a0 = o_ram_cke;
   assign L0_o_ram_cs_n_a0 = o_ram_cs_n;
   L0_o_ram_ras_n_a0 =o_ram_ras_n;
   assign L0_o_ram_cas_n_a0 = o_ram_cas_n;
   assign L0_o_ram_we_n_a0 = o_ram_cas_n;
   assign L0_o_ram_we_n_a0 = o_ram_we_n;
   assign L0_o_ram_bs_a0[1:0] = o_ram_bs;
   assign L0_o_ram_addr_a0[12:0] = o_ram_addr;
   assign L0_o_ram_dmod_a0 = o_ram_dmod;
   assign L0_i_ram_data_a0[15:0] = i_ram_data;
   assign L0_o_ram_data_a0[15:0] = o_ram_data;
   assign L0_o_ram_dqm_a0[1:0] = o_ram_dqm;
   assign L0_o_debug_a0[31:0] = o_debug;
   assign L0_i_wb_cyc_a0 = i_wb_cyc;
   assign L0_i_wb_stb_a0 = i_wb_stb;
   assign L0_i_wb_we_a0 = i_wb_we;
   assign L0_i_wb_addr_a0[23:0] = i_wb_addr;
   assign L0_i_wb_data_a0[31:0] = i_wb_data;
   assign L0_i_wb_sel_a0 = i_wb_sel;
   assign L0_o_wb_ack_a0 = o_wb_ack;
   assign L0_o_wb_stall_a0 = o_wb_stall;
   assign L0_o_wb_data_a0[31:0] = o_wb_data; 
    
         
   </span><span class="tlx_comments">//...

   // Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">assign passed = cyc_cnt &gt; 40;
   assign failed = 1'b0; </span><span class="tlx_structure">endgenerate
</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

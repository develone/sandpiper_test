//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta

`include "sp_default.vh" //_\source warp-v_mini_4-stage.tlv 5
//_\SV
   // Include WARP-V.
   // Included URL: "./warp-v.tlv"
//_\SV
module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
//_\source warp-v_mini_4-stage.tlv 9
`include "warp-v_mini_4-stage_gen.sv" //_\TLV
   //_\source ./warpv.tlv 3556   // Instantiated from warp-v_mini_4-stage.tlv, 11 as: m4+warpv()
      // =================
      //
      //    THE MODEL
      //
      // =================
      
   
      //_\source ./warpv.tlv 2814   // Instantiated from warp-v_mini_4-stage.tlv, 3564 as: m4+cpu(/top)
         // Generated logic
         //_\source <builtin> 1   // Instantiated from warp-v_mini_4-stage.tlv, 2816 as: m4+indirect(M4_isa['_gen'])
            //_\source ./warpv.tlv 1021   // Instantiated from built-in definition.
               // No M4-generated code for mini.
            //_\end_source
         //_\end_source
      
         // Instruction memory and fetch of $raw.
         //_\source <builtin> 1   // Instantiated from warp-v_mini_4-stage.tlv, 2819 as: m4+indirect(M4_IMEM_MACRO_NAME, M4_PROG_NAME)
            //_\source ./warpv.tlv 1012   // Instantiated from built-in definition.
               //_\source <builtin> 1   // Instantiated from warp-v_mini_4-stage.tlv, 1013 as: m4+indirect(['mini_']cnt10['_prog'])
                  //_\source ./warpv.tlv 971   // Instantiated from built-in definition.
                     /*SV_plus*/
                        
                        
                        // The program in an instruction memory.
                        logic [39:0] instrs [0:13-1];
                        
                        // /=====================\
                        // | Count to 10 Program |
                        // \=====================/
                        //
                        // (The program I wrote in the language I created in the CPU I wrote in a language I created.)
                        
                        // Add 1,2,3,...,9 (in that order).
                        // Store incremental results in memory locations 1..9. (1, 3, 6, 10, ..., 45)
                        //
                        // Regs:
                        // b: cnt
                        // c: nine
                        // d: out
                        // e: tmp
                        // f: offset
                        // g: store addr
                        
                        assign instrs = '{
                           "g=0~0", //     store_addr = 0
                           "b=0~1", //     cnt = 1
                           "c=1~1", //     nine = 9
                           "d=0~0", //     out = 0
                           "f=0-6", //     offset = -6
                           "d=d+b", //  -> out += cnt
                           "b=b+1", //     cnt ++
                           "g=g+1", //     store_addr++
                           
                           "0=d;g",  //    store out at store_addr, 
                           "e=c-b", //     tmp = nine - cnt
                           "p=f?e", //     branch back if tmp >= 0
                           "e=0)c", //     load the final value into tmp
                           "P=0-1"  //     TERMINATE by jumping to -1
                        }; 
                  //_\end_source
               //_\end_source
               //_\source ./warpv.tlv 3641   // Instantiated from warp-v_mini_4-stage.tlv, 1014 as: m4+instrs_for_viz()
                  
                  
                     
                        
                        
                        
                        
                        
                           
                              
                              
                              
                        
                           
                        
                        
                           
                           
                           
                           
                           
                           
                  
               //_\end_source
               //_|fetch
                  //_/instr
                     //_@0
                        //_?$fetch
                           assign FETCH_Instr_raw_a0[39:0] = instrs[FETCH_Instr_Pc_a0[3:0]];
            //_\end_source
         //_\end_source
      
      
         // /=========\
         // | The CPU |
         // \=========/
      
         //_|fetch
            //_/instr
               
               
               // Provide a longer reset to cover the pipeline depth.
               //_@-1
                  assign FETCH_Instr_soft_reset_n1 = (1'b0) || reset;
                  assign FETCH_Instr_Cnt_n2[7:0] = FETCH_Instr_soft_reset_n1   ? 8'b0 :       // reset
                               FETCH_Instr_Cnt_n1 == 8'hFF ? 8'hFF :      // max out to avoid wrapping
                                               FETCH_Instr_Cnt_n1 + 8'b1; // increment
                  assign FETCH_Instr_reset_n1 = FETCH_Instr_soft_reset_n1 || FETCH_Instr_Cnt_n1 < 10;
               //_@0
                  assign FETCH_Instr_fetch_a0 = ! FETCH_Instr_reset_a0 && ! FETCH_Instr_NoFetch_a0;
                  // (M4_IMEM_MACRO_NAME instantiation produces ?$fetch$raw.)
               //_@0
                  
                  // ========
                  // Overview
                  // ========
                  
                  // Terminology:
                  //
                  // Instruction: An instruction, as viewed by the CPU pipeline (i.e. ld and returning_ld are separate instructions,
                  //              and the returning_ld and the instruction it clobbers are one in the same).
                  // ISA Instruction: An instruction, as defined by the ISA.
                  // Good-Path (vs. Bad-Path): On the proper flow of execution of the program, excluding aborted instructions.
                  // Path (of an instruction): The sequence of instructions that led to a particular instruction.
                  // Current Path: The sequence of instructions fetched by next-PC logic that are not known to be bad-path.
                  // Redirect: Adjust the PC from the predicted next-PC.
                  // Redirect Shadow: Between the instruction causing the redirect and the redirect target instruction.
                  // Bubbles: The cycles in the redirect shadow.
                  // Commit: Results are made visible to subsequent instructions.
                  // Abort: Do not commit. All aborts are also redirects and put the instruction on bad path. Non-aborting
                  //        redirects do not mark the triggering instruction as bad-path. Aborts mask future redirects on the
                  //        aborted instruction.
                  // Retire: Commit results of an ISA instruction.
                  
                  // Control flow:
                  //
                  // Redirects include (earliest to latest):
                  //   o Returning load: (aborting) A returning load clobbers an instruction and takes its slot, resulting in a
                  //                     one-cycle redirect to repeat the clobbered instruction.
                  //   o Predict-taken branch: A predicted-taken branch must determine the target before it can redirect the PC.
                  //                           (This might be followed up by a mispredition.)
                  //   o Replay: (aborting) Replay the same instruction (because a source register is pending (awaiting a long-latency/2nd issuing instruction))
                  //   o Jump: A jump instruction.
                  //   o Mispredicted branch: A branch condition was mispredicted.
                  //   o Aborting traps: (aborting) illegal instructions, others?
                  //   o Non-aborting traps: misaligned PC target
                  
                  // ==============
                  // Redirect Logic
                  // ==============
                                  
                  // PC logic will redirect the PC for conditions on current-path instructions. PC logic keeps track of which
                  // instructions are on the current path with a $GoodPathMask. $GoodPathMask[n] of an instruction indicates
                  // whether the instruction n instructions prior to this instruction is on its path.
                  //
                  //                 $GoodPathMask for Redir'edX => {o,X,o,o,y,y,o,o} == {1,1,1,1,0,0,1,1}
                  // Waterfall View: |
                  //                 V
                  // 0)       oooooooo                  Good-path
                  // 1) InstX  ooooooXo  (Non-aborting) Good-path
                  // 2)         ooooooxx
                  // 3) InstY    ooYyyxxx  (Aborting)
                  // 4) InstZ     ooyyxZxx
                  // 5) Redir'edY  oyyxxxxx
                  // 6) TargetY     ooxxxxxx
                  // 7) Redir'edX    oxxxxxxx
                  // 8) TargetX       oooooooo          Good-path
                  // 9) Not redir'edZ  oooooooo         Good-path
                  //
                  // Above depicts a waterfall diagram where three triggering redirection conditions X, Y, and Z are detected on three different
                  // instructions. A trigger in the 1st depicted stage, M4_NEXT_PC_STAGE, results in a zero-bubble redirect so it would be
                  // a condition that is factored directly into the next-PC logic of the triggering instruction, and it would have
                  // no impact on the $GoodPathMask.
                  //
                  // Waveform View:
                  //
                  //   Inst 0123456789
                  //        ---------- /
                  // GPM[7]        ooxxxxxxoo
                  // GPM[6]       oXxxxxxxoo
                  // GPM[5]      oooxZxxxoo
                  // GPM[4]     oooyxxxxoo
                  // GPM[3]    oooyyxxxoo
                  // GPM[2]   oooYyyxxoo
                  // GPM[1]  oooooyoxoo
                  // GPM[0] oooooooooo
                  //          /
                  //         Triggers for InstY
                  //
                  // In the waveform view, the mask shifts up each cycle, as instructions age, and trigger conditions mask instructions
                  // in the shadow, down to the redirect target (GPM[0]).
                  //
                  // Terminology:
                  //   Triggering instruction: The instruction on which the condition is detected.
                  //   Redirected instruction: The instruction whose next PC is redirected.
                  //   Redirection target instruction: The first new-path instruction resulting from the redirection.
                  //
                  // Above, Y redirects first, though it is for a later instruction than X. The redirections for X and Y are taken
                  // because their instructions are on the path of the redirected instructions. Z is not on the path of its
                  // potentially-redirected instruction, so no redirection happens.
                  //
                  // For simultaneous conditions on different instructions, the PC must redirect to the earlier instruction's
                  // redirect target, so later-stage redirects take priority in the PC-mux.
                  //
                  // Aborting redirects result in the aborting instruction being marked as bad-path. Aborted instructions will
                  // not commit. Subsequent redirect conditions on aborting instructions are ignored. (For conditions within the
                  // same stage, this is accomplished by the PC-mux prioritization.)
                  
                  
                  // Macros are defined elsewhere based on the ordered set of conditions that generate code here.
                  
                  // Redirect Shadow
                  // A mask of stages ahead of this one (older) in which instructions are on the path of this instruction.
                  // Index 1 is ahead by 1, etc.
                  // In the example above, $GoodPathMask for Redir'edX == {0,0,0,0,1,1,0,0}
                  //     (Looking up in the waterfall diagram from its first "o", in reverse order {o,X,o,o,y,y,o,o}.)
                  // The LSB is fetch-valid. It only exists for m4_prev_instr_valid_through macro.
                  assign FETCH_Instr_next_good_path_mask_a0[3+1:0] =
                     // Shift up and mask w/ redirect conditions.
                     {FETCH_Instr_GoodPathMask_a0[3:0]
                      // & terms for each condition (order doesn't matter since masks are the same within a cycle)
                       & ((FETCH_Instr_second_issue_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_NoFetch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_replay_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{1{1'b1}}, {3{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_mispred_branch_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_non_pipelined_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{1{1'b1}}, {3{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{0{1'b1}}, {4{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_non_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3 || FETCH_Instr_aborting_trap_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{1{1'b1}}, {3{1'b0}}} : {4{1'b1}}),
                      1'b1}; // Shift in 1'b1 (fetch-valid).
                  
                  assign FETCH_Instr_GoodPathMask_n1[3+1:0] =
                     FETCH_Instr_reset_n1 ? 5'b0 :  // All bad-path (through self) on reset (next mask based on next reset).
                     FETCH_Instr_next_good_path_mask_a0;
                  
                  
                  
                  
                  
                     
                      
                      
                  
                     
                     
                  
                  
                  
                  // A returning load clobbers the instruction.
                  // (Could do this with lower latency. Right now it goes through memory pipeline $ANY, and
                  //  it is non-speculative. Both could easily be fixed.)
                  assign FETCH_Instr_second_issue_ld_a0 = MEM_Data_valid_ld_a4 && 1'b1;
                  assign FETCH_Instr_second_issue_a0 = FETCH_Instr_second_issue_ld_a0  ;
                  // Recirculate returning load or the div_mul_result from /orig_inst scope
                  
                  //_?$second_issue_ld
                     // This scope holds the original load for a returning load.
                     //_/orig_load_inst
                        assign {FETCH_Instr_OrigLoadInst_dest_reg_a0[2:0], FETCH_Instr_OrigLoadInst_ld_value_a0[11:0]} = {MEM_Data_dest_reg_a4, MEM_Data_ld_value_a4};
                        for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_OrigLoadInst_Src logic L1_dummy_a0; //_/src
                           assign {L1_dummy_a0} = {L1_MEM_Data_Src[src].L1_dummy_a4}; end
                  //_?$second_issue
                     //_/orig_inst
                        // pull values from /orig_load_inst or /hold_inst depending on which second issue
                        assign {FETCH_Instr_OrigInst_dest_reg_a0[2:0], FETCH_Instr_OrigInst_ld_value_a0[11:0]} = FETCH_Instr_second_issue_ld_a0 ? {FETCH_Instr_OrigLoadInst_dest_reg_a0, FETCH_Instr_OrigLoadInst_ld_value_a0} :   {FETCH_Instr_OrigLoadInst_dest_reg_a0, FETCH_Instr_OrigLoadInst_ld_value_a0};
                        for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_OrigInst_Src logic L1_dummy_a0, L1_dummy_a1, L1_dummy_a2, L1_dummy_a3; //_/src
                           assign {L1_dummy_a0} = FETCH_Instr_second_issue_ld_a0 ? {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0} :   {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0}; end
                  
                  // Next PC
                  assign FETCH_Instr_pc_inc_a0[9:0] = FETCH_Instr_Pc_a0 + 10'b1;
                  // Current parsing does not allow concatenated state on left-hand-side, so, first, a non-state expression.
                  assign {FETCH_Instr_next_pc_a0[9:0], FETCH_Instr_next_no_fetch_a0} =
                     FETCH_Instr_reset_a0 ? {10'b0, 1'b0} :
                     // ? : terms for each condition (order does matter)
                     (FETCH_Instr_non_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3 || FETCH_Instr_aborting_trap_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_trap_target_a3, 1'b0} : (FETCH_Instr_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_trap_target_a3,1'b0} : (FETCH_Instr_non_pipelined_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_Pc_a3,1'b1} : (FETCH_Instr_mispred_branch_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_branch_redir_pc_a2,1'b0} : (FETCH_Instr_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_jump_target_a2,1'b0} : (FETCH_Instr_replay_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_Pc_a2,1'b0} : (FETCH_Instr_NoFetch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_Pc_a0,1'b1} : (FETCH_Instr_second_issue_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_second_issue_ld_a0 ? FETCH_Instr_Pc_a0 : FETCH_Instr_pc_inc_a0,1'b0} :         
                                ({FETCH_Instr_pc_inc_a0, 1'b0});
                  // Then as state.
                  assign FETCH_Instr_Pc_n1[9:0] = FETCH_Instr_next_pc_a0;
                  assign FETCH_Instr_NoFetch_n1 = FETCH_Instr_next_no_fetch_a0;
               
               //_@1
      
                  // ======
                  // DECODE
                  // ======
      
                  // Decode of the fetched instruction
                  assign FETCH_Instr_valid_decode_a1 = FETCH_Instr_fetch_a1;  // Always decode if we fetch.
                  assign FETCH_Instr_valid_decode_branch_a1 = FETCH_Instr_valid_decode_a1 && FETCH_Instr_branch_a1;
                  // A load that will return later.
                  //$split_ld = $spec_ld && 1'b['']M4_INJECT_RETURNING_LD;
                  //_\source <builtin> 1   // Instantiated from warp-v_mini_4-stage.tlv, 3013 as: m4+indirect(M4_isa['_decode'])
                     //_\source ./warpv.tlv 1035   // Instantiated from built-in definition.
                        // Characters
                        assign FETCH_Instr_dest_char_a1[7:0] = FETCH_Instr_raw_a1[39:32];
                        for (src = 1; src <= 2; src++) begin : L1_FETCH_Instr_Src logic [7:0] L1_char_a1; //_/src
                           assign L1_char_a1[7:0] = (src == 1) ? FETCH_Instr_raw_a1[23:16] : FETCH_Instr_raw_a1[7:0]; end
                        assign FETCH_Instr_op_char_a1[7:0] = FETCH_Instr_raw_a1[15:8];
                     
                        // Dest
                        assign FETCH_Instr_dest_is_reg_a1 = (FETCH_Instr_dest_char_a1 >= "a" && FETCH_Instr_dest_char_a1 <= "h") || FETCH_Instr_second_issue_a1;
                        assign FETCH_Instr_dest_reg_valid_a1 = FETCH_Instr_dest_is_reg_a1;
                        assign FETCH_Instr_fetch_instr_dest_reg_a1[7:0] = FETCH_Instr_dest_char_a1 - "a";
                        assign FETCH_Instr_dest_reg_a1[2:0] = FETCH_Instr_second_issue_a1 ? FETCH_Instr_OrigInst_dest_reg_a1 : FETCH_Instr_fetch_instr_dest_reg_a1[2:0];
                        assign FETCH_Instr_jump_a1 = FETCH_Instr_dest_char_a1 == "P";
                        assign FETCH_Instr_branch_a1 = FETCH_Instr_dest_char_a1 == "p";
                        assign FETCH_Instr_no_dest_a1 = FETCH_Instr_dest_char_a1 == "0";
                        assign FETCH_Instr_write_pc_a1 = FETCH_Instr_jump_a1 || FETCH_Instr_branch_a1;
                        assign FETCH_Instr_div_mul_a1 = 1'b0;
                        assign FETCH_Instr_dest_valid_a1 = FETCH_Instr_write_pc_a1 || FETCH_Instr_dest_is_reg_a1;
                        assign FETCH_Instr_illegal_dest_a1 = !(FETCH_Instr_dest_is_reg_a1 || 
                                          ((FETCH_Instr_branch_a1 || FETCH_Instr_jump_a1 || FETCH_Instr_no_dest_a1) && ! FETCH_Instr_ld_a1));  // Load must have reg dest.
                     
                        for (src = 1; src <= 2; src++) begin : L1b_FETCH_Instr_Src logic [7:0] L1_imm_tmp_a1; logic [11:0] L1_imm_value_a1; logic L1_is_imm_a1; logic L1_is_reg_a1; logic [2:0] L1_reg_a1; logic [7:0] L1_reg_tmp_a1; //_/src
                           // Src1
                           assign L1_is_reg_a1 = L1_FETCH_Instr_Src[src].L1_char_a1 >= "a" && L1_FETCH_Instr_Src[src].L1_char_a1 <= "h";
                           assign L1_reg_tmp_a1[7:0] = L1_FETCH_Instr_Src[src].L1_char_a1 - "a";
                           assign L1_reg_a1[2:0] = L1_reg_tmp_a1[2:0];
                           assign L1_is_imm_a1 = L1_FETCH_Instr_Src[src].L1_char_a1 >= "0" && L1_FETCH_Instr_Src[src].L1_char_a1 < "8";
                           assign L1_imm_tmp_a1[7:0] = L1_FETCH_Instr_Src[src].L1_char_a1 - "0";
                           assign L1_imm_value_a1[11:0] = {9'b0, L1_imm_tmp_a1[2:0]};
                           assign FETCH_Instr_Src_illegal_a1[src] = !(L1_is_reg_a1 || L1_is_imm_a1); end
                     
                        // Opcode:
                        //_/op
                           assign FETCH_Instr_Op_char_a1[7:0] = FETCH_Instr_op_char_a1;
                           // Arithmetic
                           assign FETCH_Instr_Op_add_a1 = FETCH_Instr_Op_char_a1 == "+";
                           assign FETCH_Instr_Op_sub_a1 = FETCH_Instr_Op_char_a1 == "-";
                           assign FETCH_Instr_Op_mul_a1 = FETCH_Instr_Op_char_a1 == "*";
                           assign FETCH_Instr_Op_div_a1 = FETCH_Instr_Op_char_a1 == "/";
                           // Compare and bool (w/ 1 bit rslt)
                           assign FETCH_Instr_Op_eq_a1 = FETCH_Instr_Op_char_a1 == "=";
                           assign FETCH_Instr_Op_ne_a1 = FETCH_Instr_Op_char_a1 == "!";
                           assign FETCH_Instr_Op_lt_a1 = FETCH_Instr_Op_char_a1 == "<";
                           assign FETCH_Instr_Op_gt_a1 = FETCH_Instr_Op_char_a1 == ">";
                           assign FETCH_Instr_Op_le_a1 = FETCH_Instr_Op_char_a1 == "[";
                           assign FETCH_Instr_Op_ge_a1 = FETCH_Instr_Op_char_a1 == "]";
                           assign FETCH_Instr_Op_and_a1 = FETCH_Instr_Op_char_a1 == "&";
                           assign FETCH_Instr_Op_or_a1 = FETCH_Instr_Op_char_a1 == "|";
                           // Wide Immediate
                           assign FETCH_Instr_Op_wide_imm_a1 = FETCH_Instr_Op_char_a1 == "~";
                           assign FETCH_Instr_Op_combine_a1 = FETCH_Instr_Op_char_a1 == ",";
                           // Conditional
                           assign FETCH_Instr_Op_conditional_a1 = FETCH_Instr_Op_char_a1 == "?";
                           // Memory
                           assign FETCH_Instr_Op_ld_a1 = FETCH_Instr_Op_char_a1 == ")";
                           assign FETCH_Instr_Op_st_a1 = FETCH_Instr_Op_char_a1 == "(";
                           // Opcode classes:
                           assign FETCH_Instr_Op_arith_a1 = FETCH_Instr_Op_add_a1 || FETCH_Instr_Op_sub_a1 || FETCH_Instr_Op_mul_a1 || FETCH_Instr_Op_div_a1;
                           assign FETCH_Instr_Op_compare_a1 = FETCH_Instr_Op_eq_a1 || FETCH_Instr_Op_ne_a1 || FETCH_Instr_Op_lt_a1 || FETCH_Instr_Op_gt_a1 || FETCH_Instr_Op_le_a1 || FETCH_Instr_Op_ge_a1;
                           assign FETCH_Instr_Op_bitwise_a1 = FETCH_Instr_Op_and_a1 || FETCH_Instr_Op_or_a1;
                           assign FETCH_Instr_Op_full_a1 = FETCH_Instr_Op_arith_a1 || FETCH_Instr_Op_bitwise_a1 || FETCH_Instr_Op_wide_imm_a1 || FETCH_Instr_Op_combine_a1 || FETCH_Instr_Op_conditional_a1;
                           //$op3 = $compare || $full;
                           assign FETCH_Instr_Op_mem_a1 = FETCH_Instr_Op_ld_a1 || FETCH_Instr_Op_st_a1;
                           assign FETCH_Instr_Op_illegal_a1 = !(FETCH_Instr_Op_compare_a1 || FETCH_Instr_Op_full_a1 || FETCH_Instr_Op_mem_a1);
                        assign FETCH_Instr_op_compare_a1 = FETCH_Instr_Op_compare_a1;
                        assign FETCH_Instr_op_full_a1 = FETCH_Instr_Op_full_a1;
                        assign FETCH_Instr_ld_a1 = FETCH_Instr_Op_ld_a1;
                        assign FETCH_Instr_spec_ld_a1 = FETCH_Instr_ld_a1;
                        assign FETCH_Instr_st_a1 = FETCH_Instr_Op_st_a1;
                        assign FETCH_Instr_illegal_a1 = FETCH_Instr_illegal_dest_a1 || (| FETCH_Instr_Src_illegal_a1) || FETCH_Instr_Op_illegal_a1;
                     
                        // Branch instructions with a condition (that might be worth predicting).
                        //$branch_predict = $branch && /op$conditional;
                        assign FETCH_Instr_conditional_branch_a1 = FETCH_Instr_branch_a1;  // All branches (any instruction with "p" dest) is conditional (where condition is that result != 0).
                     //_\end_source
                  //_\end_source
               //_\source <builtin> 1   // Instantiated from warp-v_mini_4-stage.tlv, 3014 as: m4+indirect(['branch_pred_']M4_BRANCH_PRED)
                  //_\source ./warpv.tlv 2528   // Instantiated from built-in definition.
                     //_@1
                        assign FETCH_Instr_pred_taken_a1 = 1'b0;
                  //_\end_source
               //_\end_source
               
               //_@1
                  // Pending value to write to dest reg. Loads (not replaced by returning ld) write pending.
                  assign FETCH_Instr_reg_wr_pending_a1 = FETCH_Instr_ld_a1 && ! FETCH_Instr_second_issue_a1 && 1'b1;
                  `BOGUS_USE(FETCH_Instr_reg_wr_pending_a1)  // Not used if no bypass and no pending.
                  
                  // ======
                  // Reg Rd
                  // ======
                  
                  // Obtain source register values and pending bit for source registers. Bypass up to 3
                  // stages.
                  // It is not necessary to bypass pending, as we could delay the replay, but we implement
                  // bypass for performance.
                  // Pending has an additional read for the dest register as we need to replay for write-after-write
                  // hazard as well as write-after-read. To replay for dest write with the same timing, we must also
                  // bypass the dest reg's pending bit.
                  //_/regs
                  for (src = 1; src <= 2; src++) begin : L1c_FETCH_Instr_Src logic L1_dummy_a1, L1_dummy_a2, L1_dummy_a3; logic L1_is_reg_condition_a1; logic L1_pending_a1; logic [11:0] L1_reg_value_a1; //_/src
                     assign L1_is_reg_condition_a1 = L1b_FETCH_Instr_Src[src].L1_is_reg_a1 && FETCH_Instr_valid_decode_a1;  // Note: $is_reg can be set for RISC-V sr0.
                     //_?$is_reg_condition
                        assign {L1_reg_value_a1[11:0], L1_pending_a1} =
                           
                           // Bypass stages. Both register and pending are bypassed.
                           // Bypassed registers must be from instructions that are good-path as of this instruction or are 2nd issuing.
                           (FETCH_Instr_dest_reg_valid_a2 && (FETCH_Instr_GoodPathMask_a1[1] || FETCH_Instr_second_issue_a2) && (FETCH_Instr_dest_reg_a2 == L1b_FETCH_Instr_Src[src].L1_reg_a1)) ? {FETCH_Instr_rslt_a2, FETCH_Instr_reg_wr_pending_a2} :
                           (FETCH_Instr_dest_reg_valid_a3 && (FETCH_Instr_GoodPathMask_a1[2] || FETCH_Instr_second_issue_a3) && (FETCH_Instr_dest_reg_a3 == L1b_FETCH_Instr_Src[src].L1_reg_a1)) ? {FETCH_Instr_rslt_a3, FETCH_Instr_reg_wr_pending_a3} :
                           
                           {FETCH_Instr_Regs_value_a3[L1b_FETCH_Instr_Src[src].L1_reg_a1], FETCH_Instr_Regs_pending_a3[L1b_FETCH_Instr_Src[src].L1_reg_a1]};
                     // Replay if this source register is pending.
                     assign FETCH_Instr_Src_replay_a1[src] = L1_is_reg_condition_a1 && L1_pending_a1;
                     assign L1_dummy_a1 = 1'b0; end  // Dummy signal to pull through $ANY expressions when not building verification harness (since SandPiper currently complains about empty $ANY).
                  // Also replay for pending dest reg to keep writes in order. Bypass dest reg pending to support this.
                  assign FETCH_Instr_is_dest_condition_a1 = FETCH_Instr_dest_reg_valid_a1 && FETCH_Instr_valid_decode_a1;  // Note, $dest_reg_valid is 0 for RISC-V sr0.
                  //_?$is_dest_condition
                     assign FETCH_Instr_dest_pending_a1 =
                        
                        // Bypass stages. Both register and pending are bypassed.
                        (FETCH_Instr_dest_reg_valid_a2 && (FETCH_Instr_GoodPathMask_a1[1] || FETCH_Instr_second_issue_a2) && (FETCH_Instr_dest_reg_a2 == FETCH_Instr_dest_reg_a1)) ? FETCH_Instr_reg_wr_pending_a2 :
                        (FETCH_Instr_dest_reg_valid_a3 && (FETCH_Instr_GoodPathMask_a1[2] || FETCH_Instr_second_issue_a3) && (FETCH_Instr_dest_reg_a3 == FETCH_Instr_dest_reg_a1)) ? FETCH_Instr_reg_wr_pending_a3 :
                        
                        FETCH_Instr_Regs_pending_a3[FETCH_Instr_dest_reg_a1];
                  // Combine replay conditions for pending source or dest registers.
                  assign FETCH_Instr_replay_int_a1 = | FETCH_Instr_Src_replay_a1 || (FETCH_Instr_is_dest_condition_a1 && FETCH_Instr_dest_pending_a1);
                  
                  
                  
                  
                  
                  
                  
                  
                  
                     
                     
                        
                           
                           
                           
                           
                           
                           
                           
                     
                     
      
                  
                  
                  
                     
                        
                        
                        
                        
                        
                        
                  
                  
                  
                  assign FETCH_Instr_replay_a1 = FETCH_Instr_replay_int_a1 ;
               
               // =======
               // Execute
               // =======
               //_\source <builtin> 1   // Instantiated from warp-v_mini_4-stage.tlv, 3099 as: m4+indirect(M4_isa['_exe'], @M4_EXECUTE_STAGE, @M4_RESULT_STAGE)
                  //_\source ./warpv.tlv 1113   // Instantiated from built-in definition.
                     //_@1
                        for (src = 1; src <= 2; src++) begin : L1d_FETCH_Instr_Src logic L1_valid_a1; logic [11:0] L1_value_a1, L1_value_a2; //_/src
                           assign L1_valid_a1 = FETCH_Instr_valid_decode_a1 && (L1b_FETCH_Instr_Src[src].L1_is_reg_a1 || L1b_FETCH_Instr_Src[src].L1_is_imm_a1);
                           //_?$valid
                              assign L1_value_a1[11:0] = L1b_FETCH_Instr_Src[src].L1_is_reg_a1 ? L1c_FETCH_Instr_Src[src].L1_reg_value_a1 :
                                                                L1b_FETCH_Instr_Src[src].L1_imm_value_a1; end
                     // Note that some result muxing is performed in @2, and the rest in @2.
                     //_@2
                        //_?$op_compare
                           assign FETCH_Instr_compare_rslt_a2 =
                              FETCH_Instr_Op_eq_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 == L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_ne_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 != L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_lt_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 < L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_gt_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 > L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_le_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 <= L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_ge_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 >= L1d_FETCH_Instr_Src[2].L1_value_a2 :
                                       1'b0;
                        //_?$op_full
                           assign FETCH_Instr_op_full_rslt_a2[11:0] =
                              FETCH_Instr_Op_add_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 + L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_sub_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 - L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_mul_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 * L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_div_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 * L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_and_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 & L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_or_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 | L1d_FETCH_Instr_Src[2].L1_value_a2 :
                              FETCH_Instr_Op_wide_imm_a2 ? {6'b0, L1d_FETCH_Instr_Src[1].L1_value_a2[2:0], L1d_FETCH_Instr_Src[2].L1_value_a2[2:0]} :
                              FETCH_Instr_Op_combine_a2 ? {L1d_FETCH_Instr_Src[1].L1_value_a2[5:0], L1d_FETCH_Instr_Src[2].L1_value_a2[5:0]} :
                              FETCH_Instr_Op_conditional_a2 ? (L1d_FETCH_Instr_Src[2].L1_value_a2[11] ? 12'b0 : L1d_FETCH_Instr_Src[1].L1_value_a2) :
                                                12'b0;
                        //_?$valid_st
                           assign FETCH_Instr_st_value_a2[11:0] = L1d_FETCH_Instr_Src[1].L1_value_a2;
                  
                        assign FETCH_Instr_valid_ld_st_a2 = FETCH_Instr_valid_ld_a2 || FETCH_Instr_valid_st_a2;
                        //_?$valid_ld_st
                           assign FETCH_Instr_addr_a2[11:0] = FETCH_Instr_ld_a2 ? (L1d_FETCH_Instr_Src[1].L1_value_a2 + L1d_FETCH_Instr_Src[2].L1_value_a2) : L1d_FETCH_Instr_Src[2].L1_value_a2;
                        // Always predict taken; mispredict if jump or unconditioned branch or
                        //   conditioned branch with positive condition.
                        //_?$branch
                           assign FETCH_Instr_taken_a2 = FETCH_Instr_rslt_a2 != 12'b0;
                        assign FETCH_Instr_st_mask_a2[0:0] = 1'b1;
                        assign FETCH_Instr_non_aborting_isa_trap_a2 = 1'b0;
                        assign FETCH_Instr_aborting_isa_trap_a2 = 1'b0;
                     //_@2
                        //_?$dest_valid
                           assign FETCH_Instr_rslt_a2[11:0] =
                              FETCH_Instr_second_issue_a2 ? FETCH_Instr_OrigInst_ld_value_a2 :  // (Only loads are issued twice.)
                              FETCH_Instr_st_a2 ? L1d_FETCH_Instr_Src[1].L1_value_a2 :
                              FETCH_Instr_op_full_a2 ? FETCH_Instr_op_full_rslt_a2 :
                              FETCH_Instr_op_compare_a2 ? {12{FETCH_Instr_compare_rslt_a2}} :
                                    12'b0;
                           
                        // Jump (Dest = "P") and Branch (Dest = "p") Targets.
                        //_?$jump
                           assign FETCH_Instr_jump_target_a2[9:0] = FETCH_Instr_rslt_a2[9:0];
                     //_@2
                        //_?$branch
                           assign FETCH_Instr_branch_target_a2[9:0] = FETCH_Instr_Pc_a2 + 10'b1 + FETCH_Instr_rslt_a2[9:0];
                  //_\end_source
               //_\end_source
               
               //_@1
                  
               //_@2
      
                  // =======
                  // Control
                  // =======
                  
                  // Execute stage redirect conditions.
                  assign FETCH_Instr_non_pipelined_a2 = FETCH_Instr_div_mul_a2 ;
                  assign FETCH_Instr_replay_trap_a2 = 1'b0;
                  assign FETCH_Instr_aborting_trap_a2 = FETCH_Instr_replay_trap_a2 || FETCH_Instr_illegal_a2 || FETCH_Instr_aborting_isa_trap_a2;
                  assign FETCH_Instr_non_aborting_trap_a2 = FETCH_Instr_non_aborting_isa_trap_a2;
                  assign FETCH_Instr_mispred_branch_a2 = FETCH_Instr_branch_a2 && ! (FETCH_Instr_conditional_branch_a2 && (FETCH_Instr_taken_a2 == FETCH_Instr_pred_taken_a2));
                  //_?$valid_decode_branch
                     assign FETCH_Instr_branch_redir_pc_a2[9:0] =
                        // If fallthrough predictor, branch mispred always redirects taken, otherwise PC+1 for not-taken.
                        
                        FETCH_Instr_branch_target_a2;
      
                  assign FETCH_Instr_trap_target_a2[9:0] = FETCH_Instr_replay_trap_a2 ? FETCH_Instr_Pc_a2 : {10{1'b1}};  // TODO: What should this be? Using ones to terminate test for now.
                  
                  // Determine whether the instruction should commit it's result.
                  //
                  // Abort: Instruction triggers a condition causing a no-commit.
                  // Commit: Ultimate decision to commit results of this instruction, considering aborts and
                  //         prior-instruction redirects (good-path)
                  //
                  // Treatment of loads:
                  //    Loads will commit. They write a garbage value and "pending" to the register file.
                  //    Returning loads clobber an instruction. This instruction is $abort'ed (as is the
                  //    returning load, since they are one in the same). Returning load must explicitly
                  //    write results.
                  //
                  
                  assign FETCH_Instr_abort_a2 = 1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2 || FETCH_Instr_aborting_trap_a2;  // Note that register bypass logic requires that abort conditions also redirect.
                  // $commit = m4_prev_instr_valid_through(M4_MAX_REDIRECT_BUBBLES + 1), where +1 accounts for this
                  // instruction's redirects. However, to meet timing, we consider this instruction separately, so,
                  // commit if valid as of the latest redirect from prior instructions and not abort of this instruction.
                  
                  // Normal case:
                  assign FETCH_Instr_commit_a2 = (! FETCH_Instr_reset_a2 && FETCH_Instr_next_good_path_mask_a0[3]) && ! FETCH_Instr_abort_a2;
                  
                  
                  // Conditions that commit results.
                  assign FETCH_Instr_valid_dest_reg_valid_a2 = (FETCH_Instr_dest_reg_valid_a2 && FETCH_Instr_commit_a2) || (FETCH_Instr_second_issue_a2  );
      
                  
                  
                  
                  assign FETCH_Instr_valid_ld_a2 = FETCH_Instr_ld_a2 && FETCH_Instr_commit_a2;
                  assign FETCH_Instr_valid_st_a2 = FETCH_Instr_st_a2 && FETCH_Instr_commit_a2;
      
         //_\source ./warpv.tlv 2464   // Instantiated from warp-v_mini_4-stage.tlv, 3158 as: m4+fixed_latency_fake_memory(/top, 0)
            // This macro assumes little-endian.
            
            //_|fetch
               //_/instr
                  // ====
                  // Load
                  // ====
                  //_@3
                     for (bank = 0; bank <= 1-1; bank++) begin : L1_FETCH_Instr_Bank logic [11:0] L1_addr_a3; logic [(12 / 1) - 1 : 0] L1_ld_value_a3; logic L1_spec_ld_a3; logic [0:0] L1_st_mask_a3; logic [11:0] L1_st_value_a3; logic L1_valid_st_a3; logic [(12 / 1) - 1 : 0] L1_Mem_Value_a3 [31:0]; //_/bank
                        assign {L1_addr_a3[11:0], L1_spec_ld_a3, L1_st_mask_a3[0:0], L1_st_value_a3[11:0], L1_valid_st_a3} = {FETCH_Instr_addr_a3, FETCH_Instr_spec_ld_a3, FETCH_Instr_st_mask_a3, FETCH_Instr_st_value_a3, FETCH_Instr_valid_st_a3}; // Find signal from outside of /bank.
                        //_/mem
                        //_?$spec_ld
                           assign L1_ld_value_a3[(12 / 1) - 1 : 0] = L1_Mem_Value_a3[L1_addr_a3[4 + 0 : 0]];
                  
                        // Array writes are not currently permitted to use assignment
                        // syntax, so \always_comb is used, and this must be outside of
                        // when conditions, so we need to use if. <<1 because no <= support
                        // in this context. (This limitation will be lifted.)
         
                        // =====
                        // Store
                        // =====
         
                        /*SV_plus*/
                           always @ (posedge clk) begin
                              if (L1_valid_st_a3 && L1_st_mask_a3[bank])
                                 L1_Mem_Value_a3[L1_addr_a3[4 + 0 : 0]][(12 / 1) - 1 : 0] <= L1_st_value_a3[(bank + 1) * (12 / 1) - 1: bank * (12 / 1)];
                           end end
                     // Combine $ld_value per bank, assuming little-endian.
                     //$ld_value[M4_WORD_RANGE] = /bank[*]$ld_value;
                     // Unfortunately formal verification tools can't handle multiple packed dimensions produced by the expression above, so we
                     // build the concatination.
                     assign FETCH_Instr_ld_value_a3[11:0] = {L1_FETCH_Instr_Bank[0].L1_ld_value_a3};
         
            // Return loads in |mem pipeline. We just hook up the |mem pipeline to the |fetch pipeline w/ the
            // right alignment.
            //_|mem
               //_/data
                  //_@3
                     assign {MEM_Data_dest_reg_a3[2:0], MEM_Data_ld_value_a3[11:0], MEM_Data_valid_ld_a3} = {FETCH_Instr_dest_reg_a3, FETCH_Instr_ld_value_a3, FETCH_Instr_valid_ld_a3};
                     for (src = 1; src <= 2; src++) begin : L1_MEM_Data_Src logic L1_dummy_a3, L1_dummy_a4; //_/src
                        assign {L1_dummy_a3} = {L1c_FETCH_Instr_Src[src].L1_dummy_a3}; end
         //_\end_source
         //_|fetch
            //_/instr
               //_@3
                  // =========
                  // Reg Write
                  // =========
      
                  assign FETCH_Instr_reg_write_a3 = FETCH_Instr_reset_a3 ? 1'b0 : FETCH_Instr_valid_dest_reg_valid_a3;
                  /*SV_plus*/
                     always @ (posedge clk) begin
                        if (FETCH_Instr_reg_write_a3)
                           FETCH_Instr_Regs_value_a3[FETCH_Instr_dest_reg_a3][11:0] <= FETCH_Instr_rslt_a3;
                     end
                  
                  // Write $pending along with $value, but coded differently because it must be reset.
                  for (regs = 0; regs <= 7; regs++) begin : L1b_FETCH_Instr_Regs //_/regs
                     assign FETCH_Instr_Regs_pending_a2[regs] = ! FETCH_Instr_reset_a3 && (((regs == FETCH_Instr_dest_reg_a3) && FETCH_Instr_valid_dest_reg_valid_a3) ? FETCH_Instr_reg_wr_pending_a3 : FETCH_Instr_Regs_pending_a3[regs]); end
                   
                  
                  
                  
                  
                  
                     
                        
                           
                     
                  
                  
                  
                     
                    
                  
                  
               //_@3
                  `BOGUS_USE(L1_FETCH_Instr_OrigInst_Src[2].L1_dummy_a3) // To pull $dummy through $ANY expressions, avoiding empty expressions.
      //_\end_source
      
      
      
   endgenerate //_\end_source
//_\SV
   endmodule

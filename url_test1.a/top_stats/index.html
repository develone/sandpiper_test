<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 286, 2418, 0, 58, 4112, 84, 0, 0, 'opacity: 0.1', 6585, 'opacity: 0.1', 6256, 'opacity: 0.1'],
      ['top.sv', 0, 286, 7174, 2578, 0, 5429, 0, 0, 0, 'opacity: 0.1', 7758, 'opacity: 0.1', 7040, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 419, 2209, 269, 0, 500, 6541, 'opacity: 0.1', 2230, 'opacity: 0.1', 5739, 'opacity: 0.1'],
      ['SV Total', 0, 286, 7174, 2997, 2209, 5698, 0, 500, 6541, 'opacity: 0.1', 9988, 'opacity: 0.1', 12779, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar port;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0,
      L0_reset_a1;

</span><span class="tlx_comments">// For /port|rg$dest.
</span><span class="tlx_declarations">logic [1:0] Port_RG_dest_a1 [3:0],
            Port_RG_dest_a2 [3:0];

</span><span class="tlx_comments">// For /port|rg$pass_on.
</span><span class="tlx_declarations">logic Port_RG_pass_on_a1 [3:0],
      Port_RG_pass_on_a2 [3:0];

</span><span class="tlx_comments">// For /port|rg/trans$cyc_cnt.
</span><span class="tlx_declarations">logic Port_RG_Trans_cyc_cnt_a1 [3:0] </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */</span><span class="tlx_declarations">,
      Port_RG_Trans_cyc_cnt_a2 [3:0] </span><span class="tlx_comments">/* verilator lint_restore */</span><span class="tlx_declarations">;

</span><span class="tlx_comments">// For /port|rg/trans$data.
</span><span class="tlx_declarations">logic [7:0] Port_RG_Trans_data_a1 [3:0] </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */</span><span class="tlx_declarations">,
            Port_RG_Trans_data_a2 [3:0] </span><span class="tlx_comments">/* verilator lint_restore */</span><span class="tlx_declarations">;

</span><span class="tlx_comments">// For /port|rg/trans$sender.
</span><span class="tlx_declarations">logic [1:0] Port_RG_Trans_sender_a1 [3:0] </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */</span><span class="tlx_declarations">,
            Port_RG_Trans_sender_a2 [3:0] </span><span class="tlx_comments">/* verilator lint_restore */</span><span class="tlx_declarations">;

</span><span class="tlx_comments">// For /tb/port|passed$passed.
</span><span class="tlx_declarations">logic [3:0] Tb_Port_PASSED_passed_a1;

</span><span class="tlx_comments">// For /tb|count$CycCount.
</span><span class="tlx_declarations">logic [15:0] Tb_COUNT_CycCount_a0,
             Tb_COUNT_CycCount_a1;

</span><span class="tlx_comments">
//
// Scope: /port[3:0]
//

//
// Scope: /port|rg
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_Port_RG_valid_a2 [3:0];

</span><span class="tlx_comments">//
// Scope: /port|ring_out
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_Port_RING_OUT_trans_valid_a2 [3:0];

</span><span class="tlx_comments">//
// Scope: /tb
//

//
// Scope: /tb/port[3:0]
//

//
// Scope: /tb/port|receive2
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_Tb_Port_RECEIVE2_avail_a1 [3:0];

</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">
   // For $reset.
   </span><span class="tlx_staging">always_ff @(posedge clk) L0_reset_a1 &lt;= L0_reset_a0;


   </span><span class="tlx_comments">//
   // Scope: /port[3:0]
   //
   </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1gen_Port
</span><span class="tlx_comments">
      //
      // Scope: |fifo_in
      //

         // For $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1e_Port[port].L1_FIFO_IN_reset_a2 &lt;= L1e_Port[port].L1_FIFO_IN_reset_a1;



      </span><span class="tlx_comments">//
      // Scope: |rg
      //

         // For $dest.
         </span><span class="tlx_staging">always_ff @(posedge clk) Port_RG_dest_a2[port][1:0] &lt;= Port_RG_dest_a1[port][1:0];

         </span><span class="tlx_comments">// For $pass_on.
         </span><span class="tlx_staging">always_ff @(posedge clk) Port_RG_pass_on_a2[port] &lt;= Port_RG_pass_on_a1[port];


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clkP_Port_RG_valid_a2[port]) Port_RG_Trans_cyc_cnt_a2[port] &lt;= Port_RG_Trans_cyc_cnt_a1[port];

            </span><span class="tlx_comments">// For $data.
            </span><span class="tlx_staging">always_ff @(posedge clkP_Port_RG_valid_a2[port]) Port_RG_Trans_data_a2[port][7:0] &lt;= Port_RG_Trans_data_a1[port][7:0];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_Port_RG_valid_a2[port]) Port_RG_Trans_sender_a2[port][1:0] &lt;= Port_RG_Trans_sender_a1[port][1:0];




      </span><span class="tlx_comments">//
      // Scope: |ring_out
      //

         // For $trans_valid.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1b_Port[port].L1_RING_OUT_trans_valid_a2 &lt;= L1b_Port[port].L1_RING_OUT_trans_valid_a1;


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $data.
            </span><span class="tlx_staging">always_ff @(posedge clkP_Port_RING_OUT_trans_valid_a2[port]) L1b_Port[port].L1_RING_OUT_Trans_data_a2[7:0] &lt;= L1b_Port[port].L1_RING_OUT_Trans_data_a1[7:0];



   </span><span class="tlx_structure">end

   </span><span class="tlx_comments">//
   // Scope: /tb
   //


      //
      // Scope: /port[3:0]
      //
      </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1gen_Tb_Port
</span><span class="tlx_comments">
         //
         // Scope: |receive2
         //

            // For $OutstandingPackets.
            </span><span class="tlx_staging">always_ff @(posedge clk) L1_Tb_Port[port].L1_RECEIVE2_OutstandingPackets_a1[16-1:0] &lt;= L1_Tb_Port[port].L1_RECEIVE2_OutstandingPackets_a0[16-1:0];

            </span><span class="tlx_comments">// For $avail.
            </span><span class="tlx_staging">always_ff @(posedge clk) L1_Tb_Port[port].L1_RECEIVE2_avail_a1 &lt;= L1_Tb_Port[port].L1_RECEIVE2_avail_a0;

            </span><span class="tlx_comments">// For $reset.
            </span><span class="tlx_staging">always_ff @(posedge clk) L1_Tb_Port[port].L1_RECEIVE2_reset_a1 &lt;= L1_Tb_Port[port].L1_RECEIVE2_reset_a0;


            </span><span class="tlx_comments">//
            // Scope: /trans
            //

               // For $cyc_cnt.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_cyc_cnt_a1 &lt;= L1_Tb_Port[port].L1_RECEIVE2_Trans_cyc_cnt_a0;

               </span><span class="tlx_comments">// For $dest.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_dest_a1[1:0] &lt;= L1_Tb_Port[port].L1_RECEIVE2_Trans_dest_a0[1:0];

               </span><span class="tlx_comments">// For $request.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_request_a1 &lt;= L1_Tb_Port[port].L1_RECEIVE2_Trans_request_a0;

               </span><span class="tlx_comments">// For $response.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_response_a1 &lt;= L1_Tb_Port[port].L1_RECEIVE2_Trans_response_a0;

               </span><span class="tlx_comments">// For $response_debug.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_response_debug_a1 &lt;= L1_Tb_Port[port].L1_RECEIVE2_Trans_response_debug_a0;

               </span><span class="tlx_comments">// For $sender.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_sender_a1 &lt;= L1_Tb_Port[port].L1_RECEIVE2_Trans_sender_a0;



      </span><span class="tlx_structure">end

      </span><span class="tlx_comments">//
      // Scope: |count
      //

         // For $CycCount.
         </span><span class="tlx_staging">always_ff @(posedge clk) Tb_COUNT_CycCount_a1[15:0] &lt;= Tb_COUNT_CycCount_a0[15:0];





</span><span class="tlx_structure">endgenerate



</span><span class="tlx_comments">//
// Gated clocks.
//

</span><span class="tlx_structure">generate

</span><span class="tlx_comments">

   //
   // Scope: /port[3:0]
   //
   </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1clk_Port
</span><span class="tlx_comments">
      //
      // Scope: |rg
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_Port_RG_valid_a2(clkP_Port_RG_valid_a2[port], clk, 1'b1, L1b_Port[port].L1_RG_valid_a1, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |ring_out
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_Port_RING_OUT_trans_valid_a2(clkP_Port_RING_OUT_trans_valid_a2[port], clk, 1'b1, L1b_Port[port].L1_RING_OUT_trans_valid_a1, 1'b0);

   </span><span class="tlx_structure">end

   </span><span class="tlx_comments">//
   // Scope: /tb
   //


      //
      // Scope: /port[3:0]
      //
      </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1clk_Tb_Port
</span><span class="tlx_comments">
         //
         // Scope: |receive2
         //

</span><span class="tlx_gating">            clk_gate gen_clkP_Tb_Port_RECEIVE2_avail_a1(clkP_Tb_Port_RECEIVE2_avail_a1[port], clk, 1'b1, L1_Tb_Port[port].L1_RECEIVE2_avail_a0, 1'b0);

      </span><span class="tlx_structure">end



endgenerate



</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      </span><span class="tlx_comments">//
      // Scope: /port[3:0]
      //
      </span><span class="tlx_instrumentation">for (port = 0; port &lt;= 3; port++) begin : \/port 
</span><span class="tlx_comments">
         //
         // Scope: |fifo_in
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|fifo_in 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_Port[port].L1_FIFO_IN_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1e_Port[port].L1_FIFO_IN_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_Port[port].L1_FIFO_IN_blocked_a1;
            logic  \@1$out_blocked ;
            assign \@1$out_blocked = L1_Port[port].L1_FIFO_IN_out_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1e_Port[port].L1_FIFO_IN_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_Port[port].L1_FIFO_IN_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /fifo
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/fifo 
               logic [$clog2(4)-1:0] \@1$cnt ;
               assign \@1$cnt = L1_Port[port].L1_FIFO_IN_Fifo_cnt_a1;
            end

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1e_Port[port].L1_FIFO_IN_Trans_cyc_cnt_a1;
               logic [7:0] \@1$data ;
               assign \@1$data = L1c_Port[port].L1_FIFO_IN_Trans_data_a1;
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1e_Port[port].L1_FIFO_IN_Trans_dest_a1;
               logic  \@1$response_debug ;
               assign \@1$response_debug = L1e_Port[port].L1_FIFO_IN_Trans_response_debug_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1e_Port[port].L1_FIFO_IN_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |rg
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|rg 
            logic [1:0] \@1$dest ;
            assign \@1$dest = Port_RG_dest_a1[port];
            logic  \@1$pass_on ;
            assign \@1$pass_on = Port_RG_pass_on_a1[port];
            logic  \@1$passed_on ;
            assign \@1$passed_on = L1b_Port[port].L1_RG_passed_on_a1;
            logic  \@1$valid ;
            assign \@1$valid = L1b_Port[port].L1_RG_valid_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = Port_RG_Trans_cyc_cnt_a1[port];
               logic [7:0] \@1$data ;
               assign \@1$data = Port_RG_Trans_data_a1[port];
               logic [1:0] \@1$sender ;
               assign \@1$sender = Port_RG_Trans_sender_a1[port];
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |ring_in
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|ring_in 
            logic  \@1$accepted ;
            assign \@1$accepted = L1b_Port[port].L1_RING_IN_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_Port[port].L1_RING_IN_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1b_Port[port].L1_RING_IN_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_Port[port].L1_RING_IN_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1b_Port[port].L1_RING_IN_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1_Port[port].L1_RING_IN_Trans_cyc_cnt_a1;
               logic [7:0] \@1$data ;
               assign \@1$data = L1_Port[port].L1_RING_IN_Trans_data_a1;
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_Port[port].L1_RING_IN_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_Port[port].L1_RING_IN_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |ring_out
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|ring_out 
            logic  \@1$accepted ;
            assign \@1$accepted = L1d_Port[port].L1_RING_OUT_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1b_Port[port].L1_RING_OUT_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1e_Port[port].L1_RING_OUT_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1b_Port[port].L1_RING_OUT_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1d_Port[port].L1_RING_OUT_reset_in_a1;
            logic  \@1$trans_valid ;
            assign \@1$trans_valid = L1b_Port[port].L1_RING_OUT_trans_valid_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1b_Port[port].L1_RING_OUT_Trans_cyc_cnt_a1;
               logic [7:0] \@1$data ;
               assign \@1$data = L1b_Port[port].L1_RING_OUT_Trans_data_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1b_Port[port].L1_RING_OUT_Trans_sender_a1;
            end
         end
      end

      </span><span class="tlx_comments">//
      // Scope: /tb
      //
      </span><span class="tlx_instrumentation">if (1) begin : \/tb 
</span><span class="tlx_comments">
         //
         // Scope: /port[3:0]
         //
         </span><span class="tlx_instrumentation">for (port = 0; port &lt;= 3; port++) begin : \/port 
</span><span class="tlx_comments">
            //
            // Scope: |passed
            //
            </span><span class="tlx_instrumentation">if (1) begin : \|passed 
               logic  \@1$passed ;
               assign \@1$passed = Tb_Port_PASSED_passed_a1[port];
            end

            </span><span class="tlx_comments">//
            // Scope: |receive1
            //
            </span><span class="tlx_instrumentation">if (1) begin : \|receive1 
               logic  \@1$accepted ;
               assign \@1$accepted = L1_Tb_Port[port].L1_RECEIVE1_accepted_a1;
               logic  \@1$avail ;
               assign \@1$avail = L1_Tb_Port[port].L1_RECEIVE1_avail_a1;
               logic  \@1$blocked ;
               assign \@1$blocked = L1_Tb_Port[port].L1_RECEIVE1_blocked_a1;
               logic  \@1$reset ;
               assign \@1$reset = L1_Tb_Port[port].L1_RECEIVE1_reset_a1;
               logic  \@1$reset_in ;
               assign \@1$reset_in = L1_Tb_Port[port].L1_RECEIVE1_reset_in_a1;

               </span><span class="tlx_comments">//
               // Scope: /trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_Port[port].L1_RECEIVE1_Trans_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_Port[port].L1_RECEIVE1_Trans_dest_a1;
                  logic  \@1$request ;
                  assign \@1$request = L1_Tb_Port[port].L1_RECEIVE1_Trans_request_a1;
                  logic  \@1$response ;
                  assign \@1$response = L1_Tb_Port[port].L1_RECEIVE1_Trans_response_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_Port[port].L1_RECEIVE1_Trans_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_Port[port].L1_RECEIVE1_Trans_sender_a1;
               end
            end

            </span><span class="tlx_comments">//
            // Scope: |receive2
            //
            </span><span class="tlx_instrumentation">if (1) begin : \|receive2 
               logic [16-1:0] \@0$OutstandingPackets ;
               assign \@0$OutstandingPackets = L1_Tb_Port[port].L1_RECEIVE2_OutstandingPackets_a0;
               logic  \@1$accepted ;
               assign \@1$accepted = L1_Tb_Port[port].L1_RECEIVE2_accepted_a1;
               logic  \@0$avail ;
               assign \@0$avail = L1_Tb_Port[port].L1_RECEIVE2_avail_a0;
               logic  \@1$blocked ;
               assign \@1$blocked = L1_Tb_Port[port].L1_RECEIVE2_blocked_a1;
               logic  \@1$generated_request ;
               assign \@1$generated_request = L1_Tb_Port[port].L1_RECEIVE2_generated_request_a1;
               logic  \@1$recirc ;
               assign \@1$recirc = L1_Tb_Port[port].L1_RECEIVE2_recirc_a1;
               logic  \@0$reset ;
               assign \@0$reset = L1_Tb_Port[port].L1_RECEIVE2_reset_a0;
               logic  \@1$valid_request ;
               assign \@1$valid_request = L1_Tb_Port[port].L1_RECEIVE2_valid_request_a1;
               logic  \@1$valid_response ;
               assign \@1$valid_response = L1_Tb_Port[port].L1_RECEIVE2_valid_response_a1;

               </span><span class="tlx_comments">//
               // Scope: /trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                  logic  \@0$cyc_cnt ;
                  assign \@0$cyc_cnt = L1_Tb_Port[port].L1_RECEIVE2_Trans_cyc_cnt_a0;
                  logic [1:0] \@0$dest ;
                  assign \@0$dest = L1_Tb_Port[port].L1_RECEIVE2_Trans_dest_a0;
                  logic  \@0$request ;
                  assign \@0$request = L1_Tb_Port[port].L1_RECEIVE2_Trans_request_a0;
                  logic  \@0$response ;
                  assign \@0$response = L1_Tb_Port[port].L1_RECEIVE2_Trans_response_a0;
                  logic  \@0$response_debug ;
                  assign \@0$response_debug = L1_Tb_Port[port].L1_RECEIVE2_Trans_response_debug_a0;
                  logic  \@0$sender ;
                  assign \@0$sender = L1_Tb_Port[port].L1_RECEIVE2_Trans_sender_a0;
               end
            end

            </span><span class="tlx_comments">//
            // Scope: |send
            //
            </span><span class="tlx_instrumentation">if (1) begin : \|send 
               logic  \@1$avail ;
               assign \@1$avail = L1_Tb_Port[port].L1_SEND_avail_a1;
               logic  \@1$reset ;
               assign \@1$reset = L1_Tb_Port[port].L1_SEND_reset_a1;
               logic  \@1$valid_in ;
               assign \@1$valid_in = L1_Tb_Port[port].L1_SEND_valid_in_a1;

               </span><span class="tlx_comments">//
               // Scope: /gen_trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/gen_trans 
                  logic [15:0] \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_Port[port].L1_SEND_GenTrans_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_Port[port].L1_SEND_GenTrans_dest_a1;
                  logic [1:0] \@1$dest_tmp ;
                  assign \@1$dest_tmp = L1_Tb_Port[port].L1_SEND_GenTrans_dest_tmp_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_Port[port].L1_SEND_GenTrans_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_Port[port].L1_SEND_GenTrans_sender_a1;
               end

               </span><span class="tlx_comments">//
               // Scope: /trans_out
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans_out 
                  logic [15:0] \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_Port[port].L1_SEND_TransOut_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_Port[port].L1_SEND_TransOut_dest_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_Port[port].L1_SEND_TransOut_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_Port[port].L1_SEND_TransOut_sender_a1;
               end
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |count
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|count 
            logic [15:0] \@0$CycCount ;
            assign \@0$CycCount = Tb_COUNT_CycCount_a0;
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
</span><span class="tlx_comments">/*
Copyright (c) 2018, Steve Hoover
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Included URL: &quot;https://raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/fundamentals_lib/fundamentals_lib.tlv&quot;
// Included URL: &quot;https://raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot;
</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */

</span><span class="tlx_structure">\TLV
   
   </span><span class="tlx_logic">$reset = *reset;
   
      </span><span class="tlx_comments">// Defines constants for /port[3:0].
   
   
   //-------------
   // DUT
   // ------------
   
   // DUT Flow (FIFO and ring)
   </span><span class="tlx_structure">/port[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]   </span><span class="tlx_comments">// (becomes /port[3:0])
      </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 774   </span><span class="tlx_comments">// Instantiated from top.tlv, 50 as: m4+simple_bypass_fifo_v2(/port, |fifo_in, @1, |ring_in, @1, 4, 100, /trans)
         </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 775 as: m4+flow_interface(/port, [' |fifo_in, @1'], [' |ring_in, @1'], )
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |fifo_in, @1'], )
               // Avail/Blocked Input:
               </span><span class="tlx_structure">|fifo_in
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">$reset_in = $reset;
                     `BOGUS_USE($accepted $reset_in)
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 50 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |fifo_in, @1))), m4_quote(m4_shift(_resets)))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
            \source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |ring_in, @1'])
               // Avail/Blocked Output:
               </span><span class="tlx_structure">|ring_in
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 50 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |ring_in, @1))))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
         \end_source
         |fifo_in
            /trans
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$out_blocked = </span><span class="tlx_structure">/port|ring_in</span><span class="tlx_logic">&gt;&gt;0$blocked;
               $blocked = (</span><span class="tlx_structure">/port|fifo_in/fifo</span><span class="tlx_logic">&gt;&gt;0$cnt &gt;= 4) &amp;&amp; $out_blocked;
               </span><span class="tlx_structure">/fifo
                  </span><span class="tlx_logic">simple_bypass_fifo #(.WIDTH(100), .DEPTH(4))
                     fifo(.clk(clk), .reset(</span><span class="tlx_structure">|fifo_in</span><span class="tlx_logic">$reset_in),
                          .push(</span><span class="tlx_structure">|fifo_in</span><span class="tlx_logic">$accepted),
                          .data_in(</span><span class="tlx_structure">|fifo_in/trans</span><span class="tlx_logic">$ANY),
                          .pop(</span><span class="tlx_structure">|fifo_in</span><span class="tlx_logic">$accepted),
                          .data_out(</span><span class="tlx_structure">/port|ring_in/trans</span><span class="tlx_logic">&gt;&gt;0$$ANY),
                          .cnt($$cnt[\$clog2(4)-1:0]));
         </span><span class="tlx_structure">|ring_in
            /trans
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">/port|fifo_in/fifo</span><span class="tlx_logic">&gt;&gt;0$cnt != '0 || </span><span class="tlx_structure">/port|fifo_in</span><span class="tlx_logic">&gt;&gt;0$avail;
               $reset = </span><span class="tlx_structure">/port|fifo_in</span><span class="tlx_logic">&gt;&gt;0$reset_in;
      </span><span class="tlx_structure">\end_source
   \source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 1017   </span><span class="tlx_comments">// Instantiated from top.tlv, 51 as: m4+simple_ring(/port, |ring_in, @1, |ring_out, @1, /top&lt;&gt;0$reset, |rg, /trans)
      
      
      
      
      
      
      // Logic
      </span><span class="tlx_structure">/port[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
         \source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 1026 as: m4+flow_interface(/port, [' |ring_in, @1'], [' |ring_out, @1'], /top&lt;&gt;0$reset)
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |ring_in, @1'], /top&lt;&gt;0$reset)
               // Avail/Blocked Input:
               </span><span class="tlx_structure">|ring_in
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">$reset_in =  </span><span class="tlx_structure">/top</span><span class="tlx_logic">&lt;&gt;0$reset;
                     `BOGUS_USE($accepted $reset_in)
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 51 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |ring_in, @1))), m4_quote(m4_shift(_resets)))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
            \source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |ring_out, @1'])
               // Avail/Blocked Output:
               </span><span class="tlx_structure">|ring_out
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 51 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |ring_out, @1))))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
         \end_source
         |default
            </span><span class="tlx_staging">@0
               </span><span class="tlx_structure">\SV_plus
                  </span><span class="tlx_logic">int prev_hop = (port + 4 - 1) % 4;
         </span><span class="tlx_structure">|ring_in
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/port|rg</span><span class="tlx_logic">&lt;&gt;0$passed_on;
         </span><span class="tlx_structure">|rg
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$passed_on = </span><span class="tlx_structure">/port[</span><span class="tlx_logic">prev_hop</span><span class="tlx_structure">]|rg</span><span class="tlx_logic">&gt;&gt;1$pass_on;
               $valid = ! </span><span class="tlx_structure">/port|ring_in</span><span class="tlx_logic">&lt;&gt;0$reset_in &amp;&amp;
                        ($passed_on || </span><span class="tlx_structure">/port|ring_in</span><span class="tlx_logic">&lt;&gt;0$avail);
               $pass_on = $valid &amp;&amp; ! </span><span class="tlx_structure">/port|ring_out</span><span class="tlx_logic">&gt;&gt;0$trans_valid;
               $dest[1:0] =
                  $passed_on
                     ? </span><span class="tlx_structure">/port[</span><span class="tlx_logic">prev_hop</span><span class="tlx_structure">]|rg</span><span class="tlx_logic">&gt;&gt;1$dest
                     : </span><span class="tlx_structure">/port|ring_in/trans</span><span class="tlx_logic">&lt;&gt;0$dest;
            </span><span class="tlx_staging">@1
               </span><span class="tlx_validity">?$valid
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY =
                       </span><span class="tlx_structure">|rg</span><span class="tlx_logic">$passed_on
                           ? </span><span class="tlx_structure">/port[</span><span class="tlx_logic">prev_hop</span><span class="tlx_structure">]|rg/trans</span><span class="tlx_logic">&gt;&gt;1$ANY
                           : </span><span class="tlx_structure">/port|ring_in/trans</span><span class="tlx_logic">&lt;&gt;0$ANY;
         </span><span class="tlx_structure">|ring_out
            </span><span class="tlx_comments">// Ring out
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">/port|rg</span><span class="tlx_logic">&gt;&gt;0$valid &amp;&amp; (</span><span class="tlx_structure">/port|rg</span><span class="tlx_logic">&gt;&gt;0$dest == #port);
               </span><span class="tlx_comments">//$blocked = 1'b0;
               </span><span class="tlx_logic">$trans_valid = $avail; </span><span class="tlx_comments">// &amp;&amp; ! $blocked;
               </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/port|ring_in</span><span class="tlx_logic">&gt;&gt;0$reset_in;
            </span><span class="tlx_validity">?$trans_valid
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/port|rg/trans</span><span class="tlx_logic">&gt;&gt;0$ANY;
      
      
      
      
      
   </span><span class="tlx_structure">\end_source
   
   </span><span class="tlx_comments">// Transaction logic.
   </span><span class="tlx_structure">/port[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
      |fifo_in
         </span><span class="tlx_staging">@1
            </span><span class="tlx_validity">?$accepted
               </span><span class="tlx_structure">/trans
                  </span><span class="tlx_logic">$data[7:0] = *cyc_cnt[7:0];
                  </span><span class="tlx_comments">// Compute parity
                  // [+] $parity = ^ {$data, $dest};
      
      </span><span class="tlx_structure">|ring_out
         </span><span class="tlx_staging">@2
            </span><span class="tlx_validity">?$trans_valid
               </span><span class="tlx_structure">/trans
                  </span><span class="tlx_logic">`BOGUS_USE($data)
               
                  </span><span class="tlx_comments">// Check parity.
                  // [+] $parity_error = $parity != ^ {$data, $dest};

   //--------------
   // Testbench
   </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 1305   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+router_testbench(/top, /port, |fifo_in, @1, |ring_out, @1, /trans, /top&lt;&gt;0$reset)
        // Otherwise we can have a cyclic reset loop through flow.
      </span><span class="tlx_structure">/port[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
         </span><span class="tlx_comments">// Define flow interface. Note that router ins are tb outs and outs are ins.
         </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 1309 as: m4+flow_interface(/port, [' |ring_out, @1'], [' |fifo_in, @1'], /top&lt;&gt;0$reset)
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |ring_out, @1'], /top&lt;&gt;0$reset)
               // Avail/Blocked Input:
               </span><span class="tlx_structure">|ring_out
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">$reset_in =  </span><span class="tlx_structure">/top</span><span class="tlx_logic">&lt;&gt;0$reset;
                     `BOGUS_USE($accepted $reset_in)
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |ring_out, @1))), m4_quote(m4_shift(_resets)))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
            \source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |fifo_in, @1'])
               // Avail/Blocked Output:
               </span><span class="tlx_structure">|fifo_in
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |fifo_in, @1))))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
         \end_source
      
      
      
   
      /tb
         |count
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$CycCount[15:0] &lt;= </span><span class="tlx_structure">/top/port[</span><span class="tlx_logic">0</span><span class="tlx_structure">]|fifo_in</span><span class="tlx_logic">&gt;&gt;1$reset
                                     ? 16'b0 :
                                       $CycCount + 1;
               </span><span class="tlx_structure">\SV_plus
                  </span><span class="tlx_logic">always_ff @(posedge clk) begin
                     \$display(&quot;Cycle: %0d&quot;, $CycCount);
                  end
         </span><span class="tlx_structure">/port[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            </span><span class="tlx_comments">// STIMULUS
            </span><span class="tlx_structure">|send
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_comments">// Generate a transaction to inject sometimes (if needed)
                  </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/port|receive2</span><span class="tlx_logic">&gt;&gt;0$reset;
                  $valid_in = </span><span class="tlx_structure">/tb|count</span><span class="tlx_logic">&lt;&gt;0$CycCount == 3;
                  </span><span class="tlx_validity">?$valid_in
                     </span><span class="tlx_structure">/gen_trans
                        </span><span class="tlx_logic">$cyc_cnt[15:0] = </span><span class="tlx_structure">/tb|count</span><span class="tlx_logic">&lt;&gt;0$CycCount;
                        $response_debug = 1'b0;  </span><span class="tlx_comments">// Not a response (for debug)
                        </span><span class="tlx_logic">$sender[1:0] = #port;
                        </span><span class="tlx_comments">//m4_rand($size, M4_PACKET_SIZE-1, 0, #m4_port) // unused
                        </span><span class="tlx_logic">$dest_tmp[1:0] = *RW_rand_vect[(0 + (port)) % 257 +: 2];
                        $dest[1:0] = $dest_tmp % 4;
                        </span><span class="tlx_comments">//$dest[M4_['']M4_PORT['']_INDEX_RANGE] = #m4_port;
                        //$packet_valid = #m4_port == 0 ? 1'b1 : 1'b0; // valid for only first port - unused
                  </span><span class="tlx_logic">$avail = $valid_in || </span><span class="tlx_structure">/port|receive2</span><span class="tlx_logic">&gt;&gt;0$valid_request;
                  </span><span class="tlx_validity">?$avail
                     </span><span class="tlx_structure">/trans_out
                        </span><span class="tlx_comments">// Loopback requests as responses or use gen_trans.
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/port|receive2</span><span class="tlx_logic">&gt;&gt;0$valid_request
                                    ? </span><span class="tlx_structure">/port|receive2/trans</span><span class="tlx_logic">&gt;&gt;0$ANY :
                                      </span><span class="tlx_structure">|send/gen_trans</span><span class="tlx_logic">$ANY;
                        
                        </span><span class="tlx_structure">\SV_plus
                           </span><span class="tlx_logic">always_ff @(posedge clk) begin
                              if (! </span><span class="tlx_structure">|send</span><span class="tlx_logic">$reset &amp;&amp; ! *reset &amp;&amp; </span><span class="tlx_structure">/top/port|fifo_in</span><span class="tlx_logic">&lt;&gt;0$accepted) begin
                                 \$display(&quot;\|send[%0d]&quot;, #port);
                                 \$display(&quot;Sender: %0d, Orig. Cyc: %0d, Dest: %0d, Resp: %0d&quot;, $sender, $cyc_cnt, $dest, $response_debug);
                              end
                           end
            </span><span class="tlx_comments">// Hook router out to |receive1 and determine transaction response routing (within the transaction).
            </span><span class="tlx_structure">|receive1
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">/top/port|ring_out</span><span class="tlx_logic">&lt;&gt;0$avail;
                  $reset = </span><span class="tlx_structure">/top/port|ring_out</span><span class="tlx_logic">&lt;&gt;0$reset_in;
                  </span><span class="tlx_validity">?$accepted
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$response_debug = 1'b1; </span><span class="tlx_comments">// Turn this around as a response.
                        </span><span class="tlx_logic">$request = $sender != #port;  </span><span class="tlx_comments">// Arrived as request?
                        </span><span class="tlx_logic">$response = $sender == #port; </span><span class="tlx_comments">// Arrived as response?
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top/port|ring_out/trans</span><span class="tlx_logic">&lt;&gt;0$ANY;
                        $dest[1:0] = $request ? $sender : $dest;
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 342   </span><span class="tlx_comments">// Instantiated from top.tlv, 1368 as: m4+bp_stage(/port, |receive1, @1, |receive2, @1, /trans)
               
               
               
               
               
               
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/port, [' |receive1, @1'], [' |receive2, @1'], )
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |receive1, @1'], )
                     // Avail/Blocked Input:
                     </span><span class="tlx_structure">|receive1
                        </span><span class="tlx_staging">@1
                           </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                           </span><span class="tlx_logic">$reset_in = $reset;
                           `BOGUS_USE($accepted $reset_in)
                     </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |receive1, @1))), m4_quote(m4_shift(_resets)))
                        
                     </span><span class="tlx_structure">\end_source
                     
                  \end_source
                  \source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |receive2, @1'])
                     // Avail/Blocked Output:
                     </span><span class="tlx_structure">|receive2
                        </span><span class="tlx_staging">@1
                           </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                     </span><span class="tlx_structure">\source /raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |receive2, @1))))
                        
                     </span><span class="tlx_structure">\end_source
                     
                  \end_source
               \end_source
               |receive2
                  </span><span class="tlx_staging">@0
                     </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/port|receive1</span><span class="tlx_logic">&gt;&gt;1$reset_in;
                     
                     $avail = $reset ? 1'b0 :
                                       (&gt;&gt;1$avail &amp;&amp; &gt;&gt;1$blocked) ||  </span><span class="tlx_comments">// Recirc'ed or
                                       // Above is recomputation of $recirc to avoid a flop.
                                       // For SELF, its in the same stage, and is redundant computation.
                                       </span><span class="tlx_structure">/port|receive1</span><span class="tlx_logic">&gt;&gt;1$avail; </span><span class="tlx_comments">// Incoming available
                     //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
                  </span><span class="tlx_staging">@0
                     </span><span class="tlx_validity">?$avail  </span><span class="tlx_comments">// Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                              // place of recirculation.
                        </span><span class="tlx_structure">/trans
                           </span><span class="tlx_logic">$ANY =
                              </span><span class="tlx_structure">|receive2</span><span class="tlx_logic">&gt;&gt;1$recirc ? &gt;&gt;1$ANY
                                                   : </span><span class="tlx_structure">/port|receive1/trans</span><span class="tlx_logic">&gt;&gt;1$ANY;
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$recirc = $avail &amp;&amp; $blocked;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
               </span><span class="tlx_structure">|receive1
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/port|receive2</span><span class="tlx_logic">&gt;&gt;0$recirc;
                     </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
               
               
               
               
               
               
            </span><span class="tlx_structure">\end_source
            </span><span class="tlx_comments">// A one-cycle backpressured stage to avoid 0-cycle loopback.
            </span><span class="tlx_structure">|receive2
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$valid_request = $accepted &amp;&amp; </span><span class="tlx_structure">/trans</span><span class="tlx_logic">$request;
                  $valid_response = $accepted &amp;&amp; </span><span class="tlx_structure">/trans</span><span class="tlx_logic">$response;
                  </span><span class="tlx_comments">// Block requests that cannot loopback a response .
                  </span><span class="tlx_logic">$blocked = $valid_request &amp;&amp; </span><span class="tlx_structure">/top/port|fifo_in</span><span class="tlx_logic">&gt;&gt;0$blocked;
                  $accepted = $avail &amp;&amp; ! $blocked;
                  $generated_request =   </span><span class="tlx_structure">/top/port|fifo_in</span><span class="tlx_logic">&gt;&gt;0$accepted &amp;&amp;
                                       ! </span><span class="tlx_structure">/top/port|fifo_in/trans</span><span class="tlx_logic">&gt;&gt;0$response_debug;
                  $OutstandingPackets[16-1:0] &lt;=
                       $reset ? '0 :
                         ($OutstandingPackets +
                          ($generated_request ? 16'b1 : '0) -
                          ($valid_response ? 16'b1 : '0)
                         );
            </span><span class="tlx_structure">|passed  </span><span class="tlx_comments">// Aligned to |receive2, but given a new pipeline name to provide a cleaner interface for this $passed output.
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$passed = ! </span><span class="tlx_structure">/port|receive2</span><span class="tlx_logic">&lt;&gt;0$reset &amp;&amp; </span><span class="tlx_structure">/port|receive2</span><span class="tlx_logic">&lt;&gt;0$OutstandingPackets == '0 &amp;&amp; </span><span class="tlx_structure">/tb|count</span><span class="tlx_logic">&gt;&gt;0$CycCount &gt; 12;
      </span><span class="tlx_comments">// Connect with DUT.
      </span><span class="tlx_structure">/port[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         |fifo_in
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$avail = ! $reset &amp;&amp; </span><span class="tlx_structure">/top/tb/port|send</span><span class="tlx_logic">&lt;&gt;0$avail;
               </span><span class="tlx_validity">?$avail
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top/tb/port|send/trans_out</span><span class="tlx_logic">&lt;&gt;0$ANY;
               $reset = </span><span class="tlx_structure">/top/tb/port|receive2</span><span class="tlx_logic">&gt;&gt;0$reset;
         </span><span class="tlx_structure">|ring_out
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/top/tb/port|receive1</span><span class="tlx_logic">&lt;&gt;0$blocked;
            </span><span class="tlx_structure">/trans
      
      
   \end_source
   
   
   </span><span class="tlx_logic">*passed = | </span><span class="tlx_structure">/top/tb/port[</span><span class="tlx_logic">*</span><span class="tlx_structure">]|passed</span><span class="tlx_logic">&gt;&gt;1$passed;
   *failed = *cyc_cnt &gt; 20;
   
</span><span class="tlx_structure">\SV
</span><span class="tlx_untouched">endmodule 
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
/*
Copyright (c) 2018, Steve Hoover
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Included URL: &quot;https://raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/fundamentals_lib/fundamentals_lib.tlv&quot;
// Included URL: &quot;https://raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot;
</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */

</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   
   </span><span class="tlx_logic">assign L0_reset_a0 = reset;
   
      </span><span class="tlx_comments">// Defines constants for /port[3:0].
   
   
   //-------------
   // DUT
   // ------------
   
   // DUT Flow (FIFO and ring)
   </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1_Port </span><span class="tlx_declarations">logic L1_FIFO_IN_accepted_a1; logic L1_FIFO_IN_blocked_a1; logic L1_FIFO_IN_out_blocked_a1; logic L1_FIFO_IN_reset_in_a1; logic [$clog2(4)-1:0] L1_FIFO_IN_Fifo_cnt_a1; logic L1_RING_IN_avail_a1; logic L1_RING_IN_reset_a1; logic L1_RING_IN_Trans_cyc_cnt_a1; logic [7:0] L1_RING_IN_Trans_data_a1; logic [1:0] L1_RING_IN_Trans_dest_a1; logic [1:0] L1_RING_IN_Trans_sender_a1; </span><span class="tlx_comments">//_/port   // (becomes /port[3:0])
      </span><span class="tlx_structure">`line 775 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 50 as: m4+simple_bypass_fifo_v2(/port, |fifo_in, @1, |ring_in, @1, 4, 100, /trans)
         </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 775 as: m4+flow_interface(/port, [' |fifo_in, @1'], [' |ring_in, @1'], )
            </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |fifo_in, @1'], )
               // Avail/Blocked Input:
               //_|fifo_in
                  //_@1
                     </span><span class="tlx_logic">assign L1_FIFO_IN_accepted_a1 = L1e_Port[port].L1_FIFO_IN_avail_a1 &amp;&amp; ! L1_FIFO_IN_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">assign L1_FIFO_IN_reset_in_a1 = L1e_Port[port].L1_FIFO_IN_reset_a1;
                     `BOGUS_USE(L1_FIFO_IN_accepted_a1 L1_FIFO_IN_reset_in_a1)
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 50 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |fifo_in, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
            `line 130 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |ring_in, @1'])
               // Avail/Blocked Output:
               //_|ring_in
                  //_@1
                     </span><span class="tlx_logic">`BOGUS_USE(L1_RING_IN_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 50 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |ring_in, @1))))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 776 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
         </span><span class="tlx_comments">//_|fifo_in
            //_/trans
            //_@1
               </span><span class="tlx_logic">assign L1_FIFO_IN_out_blocked_a1 = L1b_Port[port].L1_RING_IN_blocked_a1;
               assign L1_FIFO_IN_blocked_a1 = (L1_FIFO_IN_Fifo_cnt_a1 &gt;= 4) &amp;&amp; L1_FIFO_IN_out_blocked_a1;
               </span><span class="tlx_comments">//_/fifo
                  </span><span class="tlx_logic">simple_bypass_fifo #(.WIDTH(100), .DEPTH(4))
                     fifo(.clk(clk), .reset(L1_FIFO_IN_reset_in_a1),
                          .push(L1_FIFO_IN_accepted_a1),
                          .data_in({L1e_Port[port].L1_FIFO_IN_Trans_cyc_cnt_a1, L1c_Port[port].L1_FIFO_IN_Trans_data_a1, L1e_Port[port].L1_FIFO_IN_Trans_dest_a1, L1e_Port[port].L1_FIFO_IN_Trans_sender_a1}),
                          .pop(L1_FIFO_IN_accepted_a1),
                          .data_out({L1_RING_IN_Trans_cyc_cnt_a1, L1_RING_IN_Trans_data_a1[7:0], L1_RING_IN_Trans_dest_a1[1:0], L1_RING_IN_Trans_sender_a1[1:0]}),
                          .cnt(L1_FIFO_IN_Fifo_cnt_a1[$clog2(4)-1:0]));
         </span><span class="tlx_comments">//_|ring_in
            //_/trans
            //_@1
               </span><span class="tlx_logic">assign L1_RING_IN_avail_a1 = L1_FIFO_IN_Fifo_cnt_a1 != '0 || L1e_Port[port].L1_FIFO_IN_avail_a1;
               assign L1_RING_IN_reset_a1 = L1_FIFO_IN_reset_in_a1;
      </span><span class="tlx_structure">end </span><span class="tlx_comments">//_\end_source
      </span><span class="tlx_structure">`line 51 &quot;top.tlv&quot; 2
   `line 1018 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 51 as: m4+simple_ring(/port, |ring_in, @1, |ring_out, @1, /top&lt;&gt;0$reset, |rg, /trans)
      
      
      
      
      
      
      // Logic
      </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1b_Port </span><span class="tlx_declarations">logic L1_RG_passed_on_a1; logic L1_RG_valid_a1; logic L1_RING_IN_accepted_a1; logic L1_RING_IN_blocked_a1; logic L1_RING_IN_reset_in_a1; logic L1_RING_OUT_avail_a1; logic L1_RING_OUT_reset_a1; logic L1_RING_OUT_trans_valid_a1, L1_RING_OUT_trans_valid_a2; logic L1_RING_OUT_Trans_cyc_cnt_a1; logic [7:0] L1_RING_OUT_Trans_data_a1, L1_RING_OUT_Trans_data_a2; logic [1:0] L1_RING_OUT_Trans_sender_a1; </span><span class="tlx_comments">//_/port
         </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 1026 as: m4+flow_interface(/port, [' |ring_in, @1'], [' |ring_out, @1'], /top&lt;&gt;0$reset)
            </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |ring_in, @1'], /top&lt;&gt;0$reset)
               // Avail/Blocked Input:
               //_|ring_in
                  //_@1
                     </span><span class="tlx_logic">assign L1_RING_IN_accepted_a1 = L1_Port[port].L1_RING_IN_avail_a1 &amp;&amp; ! L1_RING_IN_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">assign L1_RING_IN_reset_in_a1 =  L0_reset_a1;
                     `BOGUS_USE(L1_RING_IN_accepted_a1 L1_RING_IN_reset_in_a1)
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 51 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |ring_in, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
            `line 130 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |ring_out, @1'])
               // Avail/Blocked Output:
               //_|ring_out
                  //_@1
                     </span><span class="tlx_logic">`BOGUS_USE(L1_RING_OUT_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 51 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |ring_out, @1))))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 1027 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
         </span><span class="tlx_comments">//_|default
            //_@0
               /*SV_plus*/
                  </span><span class="tlx_logic">int prev_hop = (port + 4 - 1) % 4;
         </span><span class="tlx_comments">//_|ring_in
            //_@1
               </span><span class="tlx_logic">assign L1_RING_IN_blocked_a1 = L1_RG_passed_on_a1;
         </span><span class="tlx_comments">//_|rg
            //_@1
               </span><span class="tlx_logic">assign L1_RG_passed_on_a1 = Port_RG_pass_on_a2[prev_hop];
               assign L1_RG_valid_a1 = ! L1_RING_IN_reset_in_a1 &amp;&amp;
                        (L1_RG_passed_on_a1 || L1_Port[port].L1_RING_IN_avail_a1);
               assign Port_RG_pass_on_a1[port] = L1_RG_valid_a1 &amp;&amp; ! L1_RING_OUT_trans_valid_a1;
               assign Port_RG_dest_a1[port][1:0] =
                  L1_RG_passed_on_a1
                     ? Port_RG_dest_a2[prev_hop]
                     : L1_Port[port].L1_RING_IN_Trans_dest_a1;
            </span><span class="tlx_comments">//_@1
               //_?$valid
                  //_/trans
                     </span><span class="tlx_logic">assign {Port_RG_Trans_cyc_cnt_a1[port], Port_RG_Trans_data_a1[port][7:0], Port_RG_Trans_sender_a1[port][1:0]} =
                       L1_RG_passed_on_a1
                           ? {Port_RG_Trans_cyc_cnt_a2[prev_hop], Port_RG_Trans_data_a2[prev_hop], Port_RG_Trans_sender_a2[prev_hop]}
                           : {L1_Port[port].L1_RING_IN_Trans_cyc_cnt_a1, L1_Port[port].L1_RING_IN_Trans_data_a1, L1_Port[port].L1_RING_IN_Trans_sender_a1};
         </span><span class="tlx_comments">//_|ring_out
            // Ring out
            //_@1
               </span><span class="tlx_logic">assign L1_RING_OUT_avail_a1 = L1_RG_valid_a1 &amp;&amp; (Port_RG_dest_a1[port] == port);
               </span><span class="tlx_comments">//$blocked = 1'b0;
               </span><span class="tlx_logic">assign L1_RING_OUT_trans_valid_a1 = L1_RING_OUT_avail_a1; </span><span class="tlx_comments">// &amp;&amp; ! $blocked;
               </span><span class="tlx_logic">assign L1_RING_OUT_reset_a1 = L1_RING_IN_reset_in_a1;
            </span><span class="tlx_comments">//_?$trans_valid
               //_@1
                  //_/trans
                     </span><span class="tlx_logic">assign {L1_RING_OUT_Trans_cyc_cnt_a1, L1_RING_OUT_Trans_data_a1[7:0], L1_RING_OUT_Trans_sender_a1[1:0]} = {Port_RG_Trans_cyc_cnt_a1[port], Port_RG_Trans_data_a1[port], Port_RG_Trans_sender_a1[port]}; </span><span class="tlx_structure">end
      
      
      
      
      
   </span><span class="tlx_comments">//_\end_source
   </span><span class="tlx_structure">`line 52 &quot;top.tlv&quot; 2
   
   </span><span class="tlx_comments">// Transaction logic.
   </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1c_Port </span><span class="tlx_declarations">logic [7:0] L1_FIFO_IN_Trans_data_a1; </span><span class="tlx_comments">//_/port
      //_|fifo_in
         //_@1
            //_?$accepted
               //_/trans
                  </span><span class="tlx_logic">assign L1_FIFO_IN_Trans_data_a1[7:0] = cyc_cnt[7:0];
                  </span><span class="tlx_comments">// Compute parity
                  // [+] $parity = ^ {$data, $dest};
      
      //_|ring_out
         //_@2
            //_?$trans_valid
               //_/trans
                  </span><span class="tlx_logic">`BOGUS_USE(L1b_Port[port].L1_RING_OUT_Trans_data_a2) </span><span class="tlx_structure">end
               
                  </span><span class="tlx_comments">// Check parity.
                  // [+] $parity_error = $parity != ^ {$data, $dest};

   //--------------
   // Testbench
   </span><span class="tlx_structure">`line 1306 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+router_testbench(/top, /port, |fifo_in, @1, |ring_out, @1, /trans, /top&lt;&gt;0$reset)
        // Otherwise we can have a cyclic reset loop through flow.
      </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1d_Port </span><span class="tlx_declarations">logic L1_RING_OUT_accepted_a1; logic L1_RING_OUT_reset_in_a1; </span><span class="tlx_comments">//_/port
         // Define flow interface. Note that router ins are tb outs and outs are ins.
         </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 1309 as: m4+flow_interface(/port, [' |ring_out, @1'], [' |fifo_in, @1'], /top&lt;&gt;0$reset)
            </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |ring_out, @1'], /top&lt;&gt;0$reset)
               // Avail/Blocked Input:
               //_|ring_out
                  //_@1
                     </span><span class="tlx_logic">assign L1_RING_OUT_accepted_a1 = L1b_Port[port].L1_RING_OUT_avail_a1 &amp;&amp; ! L1e_Port[port].L1_RING_OUT_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">assign L1_RING_OUT_reset_in_a1 =  L0_reset_a1;
                     `BOGUS_USE(L1_RING_OUT_accepted_a1 L1_RING_OUT_reset_in_a1)
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |ring_out, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
            `line 130 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |fifo_in, @1'])
               // Avail/Blocked Output:
               //_|fifo_in
                  //_@1
                     </span><span class="tlx_logic">`BOGUS_USE(L1e_Port[port].L1_FIFO_IN_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |fifo_in, @1))))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
         end </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 1310 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
      
      
      
   
      </span><span class="tlx_comments">//_/tb
         //_|count
            //_@1
               </span><span class="tlx_logic">assign Tb_COUNT_CycCount_a0[15:0] = L1e_Port[0].L1_FIFO_IN_reset_a2
                                     ? 16'b0 :
                                       Tb_COUNT_CycCount_a1 + 1;
               </span><span class="tlx_comments">/*SV_plus*/
                  </span><span class="tlx_logic">always_ff @(posedge clk) begin
                     $display(&quot;Cycle: %0d&quot;, Tb_COUNT_CycCount_a1);
                  end
         </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1_Tb_Port </span><span class="tlx_declarations">logic L1_RECEIVE1_accepted_a1; logic L1_RECEIVE1_avail_a1; logic L1_RECEIVE1_blocked_a1; logic L1_RECEIVE1_reset_a1; logic L1_RECEIVE1_reset_in_a1; logic L1_RECEIVE1_Trans_cyc_cnt_a1; logic [1:0] L1_RECEIVE1_Trans_dest_a1; logic L1_RECEIVE1_Trans_request_a1; logic L1_RECEIVE1_Trans_response_a1; logic L1_RECEIVE1_Trans_response_debug_a1; logic [1:0] L1_RECEIVE1_Trans_sender_a1; logic [16-1:0] L1_RECEIVE2_OutstandingPackets_a0, L1_RECEIVE2_OutstandingPackets_a1; logic L1_RECEIVE2_accepted_a1; logic L1_RECEIVE2_avail_a0, L1_RECEIVE2_avail_a1; logic L1_RECEIVE2_blocked_a1; logic L1_RECEIVE2_generated_request_a1; logic L1_RECEIVE2_recirc_a1; logic L1_RECEIVE2_reset_a0, L1_RECEIVE2_reset_a1; logic L1_RECEIVE2_valid_request_a1; logic L1_RECEIVE2_valid_response_a1; logic L1_RECEIVE2_Trans_cyc_cnt_a0, L1_RECEIVE2_Trans_cyc_cnt_a1; logic [1:0] L1_RECEIVE2_Trans_dest_a0, L1_RECEIVE2_Trans_dest_a1; logic L1_RECEIVE2_Trans_request_a0, L1_RECEIVE2_Trans_request_a1; logic L1_RECEIVE2_Trans_response_a0, L1_RECEIVE2_Trans_response_a1; logic L1_RECEIVE2_Trans_response_debug_a0, L1_RECEIVE2_Trans_response_debug_a1; logic L1_RECEIVE2_Trans_sender_a0, L1_RECEIVE2_Trans_sender_a1; logic L1_SEND_avail_a1; logic L1_SEND_reset_a1; logic L1_SEND_valid_in_a1; logic [15:0] L1_SEND_GenTrans_cyc_cnt_a1; logic [1:0] L1_SEND_GenTrans_dest_a1; logic [1:0] L1_SEND_GenTrans_dest_tmp_a1; logic L1_SEND_GenTrans_response_debug_a1; logic [1:0] L1_SEND_GenTrans_sender_a1; logic [15:0] L1_SEND_TransOut_cyc_cnt_a1; logic [1:0] L1_SEND_TransOut_dest_a1; logic L1_SEND_TransOut_response_debug_a1; logic [1:0] L1_SEND_TransOut_sender_a1; </span><span class="tlx_comments">//_/port
            // STIMULUS
            //_|send
               //_@1
                  // Generate a transaction to inject sometimes (if needed)
                  </span><span class="tlx_logic">assign L1_SEND_reset_a1 = L1_RECEIVE2_reset_a1;
                  assign L1_SEND_valid_in_a1 = Tb_COUNT_CycCount_a1 == 3;
                  </span><span class="tlx_comments">//_?$valid_in
                     //_/gen_trans
                        </span><span class="tlx_logic">assign L1_SEND_GenTrans_cyc_cnt_a1[15:0] = Tb_COUNT_CycCount_a1;
                        assign L1_SEND_GenTrans_response_debug_a1 = 1'b0;  </span><span class="tlx_comments">// Not a response (for debug)
                        </span><span class="tlx_logic">assign L1_SEND_GenTrans_sender_a1[1:0] = port;
                        </span><span class="tlx_comments">//m4_rand($size, M4_PACKET_SIZE-1, 0, #m4_port) // unused
                        </span><span class="tlx_logic">assign L1_SEND_GenTrans_dest_tmp_a1[1:0] = RW_rand_vect[(0 + (port)) % 257 +: 2];
                        assign L1_SEND_GenTrans_dest_a1[1:0] = L1_SEND_GenTrans_dest_tmp_a1 % 4;
                        </span><span class="tlx_comments">//$dest[M4_['']M4_PORT['']_INDEX_RANGE] = #m4_port;
                        //$packet_valid = #m4_port == 0 ? 1'b1 : 1'b0; // valid for only first port - unused
                  </span><span class="tlx_logic">assign L1_SEND_avail_a1 = L1_SEND_valid_in_a1 || L1_RECEIVE2_valid_request_a1;
                  </span><span class="tlx_comments">//_?$avail
                     //_/trans_out
                        // Loopback requests as responses or use gen_trans.
                        </span><span class="tlx_logic">assign {L1_SEND_TransOut_cyc_cnt_a1[15:0], L1_SEND_TransOut_dest_a1[1:0], L1_SEND_TransOut_response_debug_a1, L1_SEND_TransOut_sender_a1[1:0]} = L1_RECEIVE2_valid_request_a1
                                    ? {L1_RECEIVE2_Trans_cyc_cnt_a1, L1_RECEIVE2_Trans_dest_a1, L1_RECEIVE2_Trans_response_debug_a1, L1_RECEIVE2_Trans_sender_a1} :
                                      {L1_SEND_GenTrans_cyc_cnt_a1, L1_SEND_GenTrans_dest_a1[1:0], L1_SEND_GenTrans_response_debug_a1, L1_SEND_GenTrans_sender_a1};
                        
                        </span><span class="tlx_comments">/*SV_plus*/
                           </span><span class="tlx_logic">always_ff @(posedge clk) begin
                              if (! L1_SEND_reset_a1 &amp;&amp; ! reset &amp;&amp; L1_Port[port].L1_FIFO_IN_accepted_a1) begin
                                 $display(&quot;|send[%0d]&quot;, port);
                                 $display(&quot;Sender: %0d, Orig. Cyc: %0d, Dest: %0d, Resp: %0d&quot;, L1_SEND_TransOut_sender_a1, L1_SEND_TransOut_cyc_cnt_a1, L1_SEND_TransOut_dest_a1, L1_SEND_TransOut_response_debug_a1);
                              end
                           end
            </span><span class="tlx_comments">// Hook router out to |receive1 and determine transaction response routing (within the transaction).
            //_|receive1
               //_@1
                  </span><span class="tlx_logic">assign L1_RECEIVE1_avail_a1 = L1b_Port[port].L1_RING_OUT_avail_a1;
                  assign L1_RECEIVE1_reset_a1 = L1d_Port[port].L1_RING_OUT_reset_in_a1;
                  </span><span class="tlx_comments">//_?$accepted
                     //_/trans
                        </span><span class="tlx_logic">assign L1_RECEIVE1_Trans_response_debug_a1 = 1'b1; </span><span class="tlx_comments">// Turn this around as a response.
                        </span><span class="tlx_logic">assign L1_RECEIVE1_Trans_request_a1 = L1_RECEIVE1_Trans_sender_a1 != port;  </span><span class="tlx_comments">// Arrived as request?
                        </span><span class="tlx_logic">assign L1_RECEIVE1_Trans_response_a1 = L1_RECEIVE1_Trans_sender_a1 == port; </span><span class="tlx_comments">// Arrived as response?
                        </span><span class="tlx_logic">assign {L1_RECEIVE1_Trans_cyc_cnt_a1, L1_RECEIVE1_Trans_sender_a1[1:0]} = {L1b_Port[port].L1_RING_OUT_Trans_cyc_cnt_a1, L1b_Port[port].L1_RING_OUT_Trans_sender_a1};
                        assign L1_RECEIVE1_Trans_dest_a1[1:0] = L1_RECEIVE1_Trans_request_a1 ? L1_RECEIVE1_Trans_sender_a1 : L1_RECEIVE1_Trans_dest_a1;
            </span><span class="tlx_structure">`line 343 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 1368 as: m4+bp_stage(/port, |receive1, @1, |receive2, @1, /trans)
               
               
               
               
               
               
               </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/port, [' |receive1, @1'], [' |receive2, @1'], )
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |receive1, @1'], )
                     // Avail/Blocked Input:
                     //_|receive1
                        //_@1
                           </span><span class="tlx_logic">assign L1_RECEIVE1_accepted_a1 = L1_RECEIVE1_avail_a1 &amp;&amp; ! L1_RECEIVE1_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                           </span><span class="tlx_logic">assign L1_RECEIVE1_reset_in_a1 = L1_RECEIVE1_reset_a1;
                           `BOGUS_USE(L1_RECEIVE1_accepted_a1 L1_RECEIVE1_reset_in_a1)
                     </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |receive1, @1))), m4_quote(m4_shift(_resets)))
                        
                     //_\end_source
                     </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
                     
                  </span><span class="tlx_comments">//_\end_source
                  </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
                  `line 130 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |receive2, @1'])
                     // Avail/Blocked Output:
                     //_|receive2
                        //_@1
                           </span><span class="tlx_logic">`BOGUS_USE(L1_RECEIVE2_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                     </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 74 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |receive2, @1))))
                        
                     //_\end_source
                     </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
                     
                  </span><span class="tlx_comments">//_\end_source
                  </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 350 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
               </span><span class="tlx_comments">//_|receive2
                  //_@0
                     </span><span class="tlx_logic">assign L1_RECEIVE2_reset_a0 = L1_RECEIVE1_reset_in_a1;
                     
                     assign L1_RECEIVE2_avail_a0 = L1_RECEIVE2_reset_a0 ? 1'b0 :
                                       (L1_RECEIVE2_avail_a1 &amp;&amp; L1_RECEIVE2_blocked_a1) ||  </span><span class="tlx_comments">// Recirc'ed or
                                       // Above is recomputation of $recirc to avoid a flop.
                                       // For SELF, its in the same stage, and is redundant computation.
                                       </span><span class="tlx_logic">L1_RECEIVE1_avail_a1; </span><span class="tlx_comments">// Incoming available
                     //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
                  //_@0
                     //_?$avail  // Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                              // place of recirculation.
                        //_/trans
                           </span><span class="tlx_logic">assign {L1_RECEIVE2_Trans_cyc_cnt_a0, L1_RECEIVE2_Trans_dest_a0[1:0], L1_RECEIVE2_Trans_request_a0, L1_RECEIVE2_Trans_response_a0, L1_RECEIVE2_Trans_response_debug_a0, L1_RECEIVE2_Trans_sender_a0} =
                              L1_RECEIVE2_recirc_a1 ? {L1_RECEIVE2_Trans_cyc_cnt_a1, L1_RECEIVE2_Trans_dest_a1, L1_RECEIVE2_Trans_request_a1, L1_RECEIVE2_Trans_response_a1, L1_RECEIVE2_Trans_response_debug_a1, L1_RECEIVE2_Trans_sender_a1}
                                                   : {L1_RECEIVE1_Trans_cyc_cnt_a1, L1_RECEIVE1_Trans_dest_a1, L1_RECEIVE1_Trans_request_a1, L1_RECEIVE1_Trans_response_a1, L1_RECEIVE1_Trans_response_debug_a1, L1_RECEIVE1_Trans_sender_a1};
                  </span><span class="tlx_comments">//_@1
                     </span><span class="tlx_logic">assign L1_RECEIVE2_recirc_a1 = L1_RECEIVE2_avail_a1 &amp;&amp; L1_RECEIVE2_blocked_a1;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
               //_|receive1
                  //_@1
                     </span><span class="tlx_logic">assign L1_RECEIVE1_blocked_a1 = L1_RECEIVE2_recirc_a1;
                     </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
               
               
               
               
               
               
            //_\end_source
            </span><span class="tlx_structure">`line 1369 &quot;/raw.githubusercontent.com/develone/sandpiper_test/blob/master/url_test/pipeflow_lib/pipeflow_lib.tlv&quot; 2
            </span><span class="tlx_comments">// A one-cycle backpressured stage to avoid 0-cycle loopback.
            //_|receive2
               //_@1
                  </span><span class="tlx_logic">assign L1_RECEIVE2_valid_request_a1 = L1_RECEIVE2_accepted_a1 &amp;&amp; L1_RECEIVE2_Trans_request_a1;
                  assign L1_RECEIVE2_valid_response_a1 = L1_RECEIVE2_accepted_a1 &amp;&amp; L1_RECEIVE2_Trans_response_a1;
                  </span><span class="tlx_comments">// Block requests that cannot loopback a response .
                  </span><span class="tlx_logic">assign L1_RECEIVE2_blocked_a1 = L1_RECEIVE2_valid_request_a1 &amp;&amp; L1_Port[port].L1_FIFO_IN_blocked_a1;
                  assign L1_RECEIVE2_accepted_a1 = L1_RECEIVE2_avail_a1 &amp;&amp; ! L1_RECEIVE2_blocked_a1;
                  assign L1_RECEIVE2_generated_request_a1 =   L1_Port[port].L1_FIFO_IN_accepted_a1 &amp;&amp;
                                       ! L1e_Port[port].L1_FIFO_IN_Trans_response_debug_a1;
                  assign L1_RECEIVE2_OutstandingPackets_a0[16-1:0] =
                       L1_RECEIVE2_reset_a1 ? '0 :
                         (L1_RECEIVE2_OutstandingPackets_a1 +
                          (L1_RECEIVE2_generated_request_a1 ? 16'b1 : '0) -
                          (L1_RECEIVE2_valid_response_a1 ? 16'b1 : '0)
                         );
            </span><span class="tlx_comments">//_|passed  // Aligned to |receive2, but given a new pipeline name to provide a cleaner interface for this $passed output.
               //_@1
                  </span><span class="tlx_logic">assign Tb_Port_PASSED_passed_a1[port] = ! L1_RECEIVE2_reset_a1 &amp;&amp; L1_RECEIVE2_OutstandingPackets_a1 == '0 &amp;&amp; Tb_COUNT_CycCount_a1 &gt; 12; </span><span class="tlx_structure">end
      </span><span class="tlx_comments">// Connect with DUT.
      </span><span class="tlx_structure">for (port = 0; port &lt;= 3; port++) begin : L1e_Port </span><span class="tlx_declarations">logic L1_FIFO_IN_avail_a1; logic L1_FIFO_IN_reset_a1, L1_FIFO_IN_reset_a2; logic L1_FIFO_IN_Trans_cyc_cnt_a1; logic [1:0] L1_FIFO_IN_Trans_dest_a1; logic L1_FIFO_IN_Trans_response_debug_a1; logic [1:0] L1_FIFO_IN_Trans_sender_a1; logic L1_RING_OUT_blocked_a1; </span><span class="tlx_comments">//_/port
         //_|fifo_in
            //_@1
               </span><span class="tlx_logic">assign L1_FIFO_IN_avail_a1 = ! L1_FIFO_IN_reset_a1 &amp;&amp; L1_Tb_Port[port].L1_SEND_avail_a1;
               </span><span class="tlx_comments">//_?$avail
                  //_/trans
                     </span><span class="tlx_logic">assign {L1_FIFO_IN_Trans_cyc_cnt_a1, L1_FIFO_IN_Trans_dest_a1[1:0], L1_FIFO_IN_Trans_response_debug_a1, L1_FIFO_IN_Trans_sender_a1[1:0]} = {L1_Tb_Port[port].L1_SEND_TransOut_cyc_cnt_a1, L1_Tb_Port[port].L1_SEND_TransOut_dest_a1, L1_Tb_Port[port].L1_SEND_TransOut_response_debug_a1, L1_Tb_Port[port].L1_SEND_TransOut_sender_a1};
               assign L1_FIFO_IN_reset_a1 = L1_Tb_Port[port].L1_RECEIVE2_reset_a1;
         </span><span class="tlx_comments">//_|ring_out
            //_@1
               </span><span class="tlx_logic">assign L1_RING_OUT_blocked_a1 = L1_Tb_Port[port].L1_RECEIVE1_blocked_a1;
            </span><span class="tlx_structure">end </span><span class="tlx_comments">//_/trans
      
      
   //_\end_source
   </span><span class="tlx_structure">`line 75 &quot;top.tlv&quot; 2
   
   
   </span><span class="tlx_logic">assign passed = | Tb_Port_PASSED_passed_a1;
   assign failed = cyc_cnt &gt; 20; </span><span class="tlx_structure">endgenerate
   
</span><span class="tlx_comments">//_\SV
</span><span class="tlx_untouched">endmodule 
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

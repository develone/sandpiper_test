<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 286, 928, 0, 10, 566, 46, 0, 0, 'opacity: 0.1', 2889, 'opacity: 0.1', 1163, 'opacity: 0.1'],
      ['top.sv', 0, 286, 1264, 28, 0, 657, 0, 0, 0, 'opacity: 0.1', 3164, 'opacity: 0.1', 1255, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 647, 362, 174, 0, 0, 1930, 'opacity: 0.1', 1793, 'opacity: 0.1', 1517, 'opacity: 0.1'],
      ['SV Total', 0, 286, 1264, 675, 362, 831, 0, 0, 1930, 'opacity: 0.1', 4957, 'opacity: 0.1', 2772, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar dmem, imem, xreg;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For |cpu$dmem_addr.
</span><span class="tlx_declarations">logic CPU_dmem_addr_a4;

</span><span class="tlx_comments">// For |cpu$dmem_rd_data.
</span><span class="tlx_declarations">logic [31:0] CPU_dmem_rd_data_a4;

</span><span class="tlx_comments">// For |cpu$dmem_rd_en.
</span><span class="tlx_declarations">logic CPU_dmem_rd_en_a4;

</span><span class="tlx_comments">// For |cpu$dmem_wr_data.
</span><span class="tlx_declarations">logic CPU_dmem_wr_data_a4;

</span><span class="tlx_comments">// For |cpu$dmem_wr_en.
</span><span class="tlx_declarations">logic CPU_dmem_wr_en_a4;

</span><span class="tlx_comments">// For |cpu$imem_rd_addr.
</span><span class="tlx_declarations">logic CPU_imem_rd_addr_a1;

</span><span class="tlx_comments">// For |cpu$imem_rd_data.
</span><span class="tlx_declarations">logic [31:0] CPU_imem_rd_data_a1;

</span><span class="tlx_comments">// For |cpu$imem_rd_en.
</span><span class="tlx_declarations">logic CPU_imem_rd_en_a1;

</span><span class="tlx_comments">// For |cpu$reset.
</span><span class="tlx_declarations">logic CPU_reset_a0,
      CPU_reset_a1,
      CPU_reset_a2,
      CPU_reset_a3,
      CPU_reset_a4;

</span><span class="tlx_comments">// For |cpu$rf_rd_data1.
</span><span class="tlx_declarations">logic [31:0] CPU_rf_rd_data1_a1;

</span><span class="tlx_comments">// For |cpu$rf_rd_data2.
</span><span class="tlx_declarations">logic [31:0] CPU_rf_rd_data2_a1;

</span><span class="tlx_comments">// For |cpu$rf_rd_en1.
</span><span class="tlx_declarations">logic CPU_rf_rd_en1_a1;

</span><span class="tlx_comments">// For |cpu$rf_rd_en2.
</span><span class="tlx_declarations">logic CPU_rf_rd_en2_a1;

</span><span class="tlx_comments">// For |cpu$rf_rd_index1.
</span><span class="tlx_declarations">logic CPU_rf_rd_index1_a1;

</span><span class="tlx_comments">// For |cpu$rf_rd_index2.
</span><span class="tlx_declarations">logic CPU_rf_rd_index2_a1;

</span><span class="tlx_comments">// For |cpu$rf_wr_data.
</span><span class="tlx_declarations">logic CPU_rf_wr_data_a1;

</span><span class="tlx_comments">// For |cpu$rf_wr_en.
</span><span class="tlx_declarations">logic CPU_rf_wr_en_a1;

</span><span class="tlx_comments">// For |cpu$rf_wr_index.
</span><span class="tlx_declarations">logic CPU_rf_wr_index_a1;

</span><span class="tlx_comments">// For |cpu/dmem$value.
</span><span class="tlx_declarations">logic [31:0] CPU_Dmem_value_a4 [15:0],
             CPU_Dmem_value_a5 [15:0];

</span><span class="tlx_comments">// For |cpu/imem$instr.
</span><span class="tlx_declarations">logic [31:0] CPU_Imem_instr_a1 [7:0];

</span><span class="tlx_comments">// For |cpu/xreg$value.
</span><span class="tlx_declarations">logic [31:0] CPU_Xreg_value_a1 [31:0],
             CPU_Xreg_value_a2 [31:0];


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">

   //
   // Scope: |cpu
   //

      // For signal $dmem_addr, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_dmem_addr_a4 = 'x;

      </span><span class="tlx_comments">// For signal $dmem_rd_en, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_dmem_rd_en_a4 = 'x;

      </span><span class="tlx_comments">// For signal $dmem_wr_data, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_dmem_wr_data_a4 = 'x;

      </span><span class="tlx_comments">// For signal $dmem_wr_en, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_dmem_wr_en_a4 = 'x;

      </span><span class="tlx_comments">// For signal $imem_rd_addr, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_imem_rd_addr_a1 = 'x;

      </span><span class="tlx_comments">// For signal $imem_rd_en, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_imem_rd_en_a1 = 'x;

      </span><span class="tlx_comments">// For $reset.
      </span><span class="tlx_staging">always_ff @(posedge clk) CPU_reset_a1 &lt;= CPU_reset_a0;
      always_ff @(posedge clk) CPU_reset_a2 &lt;= CPU_reset_a1;
      always_ff @(posedge clk) CPU_reset_a3 &lt;= CPU_reset_a2;
      always_ff @(posedge clk) CPU_reset_a4 &lt;= CPU_reset_a3;

      </span><span class="tlx_comments">// For signal $rf_rd_en1, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_rf_rd_en1_a1 = 'x;

      </span><span class="tlx_comments">// For signal $rf_rd_en2, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_rf_rd_en2_a1 = 'x;

      </span><span class="tlx_comments">// For signal $rf_rd_index1, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_rf_rd_index1_a1 = 'x;

      </span><span class="tlx_comments">// For signal $rf_rd_index2, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_rf_rd_index2_a1 = 'x;

      </span><span class="tlx_comments">// For signal $rf_wr_data, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_rf_wr_data_a1 = 'x;

      </span><span class="tlx_comments">// For signal $rf_wr_en, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_rf_wr_en_a1 = 'x;

      </span><span class="tlx_comments">// For signal $rf_wr_index, which had no assignment.
      </span><span class="tlx_instrumentation">assign CPU_rf_wr_index_a1 = 'x;


      </span><span class="tlx_comments">//
      // Scope: /dmem[15:0]
      //
      </span><span class="tlx_structure">for (dmem = 0; dmem &lt;= 15; dmem++) begin : L1gen_CPU_Dmem
</span><span class="tlx_comments">         // For $value.
         </span><span class="tlx_staging">always_ff @(posedge clk) CPU_Dmem_value_a5[dmem][31:0] &lt;= CPU_Dmem_value_a4[dmem][31:0];

      </span><span class="tlx_structure">end

      </span><span class="tlx_comments">//
      // Scope: /xreg[31:0]
      //
      </span><span class="tlx_structure">for (xreg = 0; xreg &lt;= 31; xreg++) begin : L1gen_CPU_Xreg
</span><span class="tlx_comments">         // For $value.
         </span><span class="tlx_staging">always_ff @(posedge clk) CPU_Xreg_value_a2[xreg][31:0] &lt;= CPU_Xreg_value_a1[xreg][31:0];

      </span><span class="tlx_structure">end



endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS
</span><span class="tlx_comments">

      //
      // Scope: |cpu
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|cpu 
         logic  \@4$dmem_addr ;
         assign \@4$dmem_addr = CPU_dmem_addr_a4;
         logic [31:0] \@4$dmem_rd_data ;
         assign \@4$dmem_rd_data = CPU_dmem_rd_data_a4;
         logic  \@4$dmem_rd_en ;
         assign \@4$dmem_rd_en = CPU_dmem_rd_en_a4;
         logic  \@4$dmem_wr_data ;
         assign \@4$dmem_wr_data = CPU_dmem_wr_data_a4;
         logic  \@4$dmem_wr_en ;
         assign \@4$dmem_wr_en = CPU_dmem_wr_en_a4;
         logic  \@1$imem_rd_addr ;
         assign \@1$imem_rd_addr = CPU_imem_rd_addr_a1;
         logic [31:0] \@1$imem_rd_data ;
         assign \@1$imem_rd_data = CPU_imem_rd_data_a1;
         logic  \@1$imem_rd_en ;
         assign \@1$imem_rd_en = CPU_imem_rd_en_a1;
         logic  \@0$reset ;
         assign \@0$reset = CPU_reset_a0;
         logic [31:0] \@1$rf_rd_data1 ;
         assign \@1$rf_rd_data1 = CPU_rf_rd_data1_a1;
         logic [31:0] \@1$rf_rd_data2 ;
         assign \@1$rf_rd_data2 = CPU_rf_rd_data2_a1;
         logic  \@1$rf_rd_en1 ;
         assign \@1$rf_rd_en1 = CPU_rf_rd_en1_a1;
         logic  \@1$rf_rd_en2 ;
         assign \@1$rf_rd_en2 = CPU_rf_rd_en2_a1;
         logic  \@1$rf_rd_index1 ;
         assign \@1$rf_rd_index1 = CPU_rf_rd_index1_a1;
         logic  \@1$rf_rd_index2 ;
         assign \@1$rf_rd_index2 = CPU_rf_rd_index2_a1;
         logic  \@1$rf_wr_data ;
         assign \@1$rf_wr_data = CPU_rf_wr_data_a1;
         logic  \@1$rf_wr_en ;
         assign \@1$rf_wr_en = CPU_rf_wr_en_a1;
         logic  \@1$rf_wr_index ;
         assign \@1$rf_wr_index = CPU_rf_wr_index_a1;

         </span><span class="tlx_comments">//
         // Scope: /dmem[15:0]
         //
         </span><span class="tlx_instrumentation">for (dmem = 0; dmem &lt;= 15; dmem++) begin : \/dmem 
            logic [31:0] \@4$value ;
            assign \@4$value = CPU_Dmem_value_a4[dmem];
            logic  \@4$wr ;
            assign \@4$wr = L1_CPU_Dmem[dmem].L1_wr_a4;
         end

         </span><span class="tlx_comments">//
         // Scope: /imem[7:0]
         //
         </span><span class="tlx_instrumentation">for (imem = 0; imem &lt;= 7; imem++) begin : \/imem 
            logic [31:0] \@1$instr ;
            assign \@1$instr = CPU_Imem_instr_a1[imem];
         end

         </span><span class="tlx_comments">//
         // Scope: /xreg[31:0]
         //
         </span><span class="tlx_instrumentation">for (xreg = 0; xreg &lt;= 31; xreg++) begin : \/xreg 
            logic [31:0] \@1$value ;
            assign \@1$value = CPU_Xreg_value_a1[xreg];
            logic  \@1$wr ;
            assign \@1$wr = L1_CPU_Xreg[xreg].L1_wr_a1;
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
   </span><span class="tlx_comments">// This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   // Included URL: &quot;https://raw.githubusercontent.com/stevehoover/RISC-V_MYTH_Workshop/c1719d5b338896577b79ee76c2f443ca2a76e14f/tlv_lib/risc-v_shell_lib.tlv&quot;// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/warp-v_includes/2d6d36baa4d2bc62321f982f78c8fe1456641a43/risc-v_defs.tlv&quot;

</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
</span><span class="tlx_structure">\TLV

   </span><span class="tlx_comments">// /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   // Inst #0: ADD,r10,r0,r0             // Initialize r10 (a0) to 0.
   // Function:
   // Inst #1: ADD,r14,r10,r0            // Initialize sum register a4 with 0x0
   // Inst #2: ADDI,r12,r10,1010         // Store count of 10 in register a2.
   // Inst #3: ADD,r13,r10,r0            // Initialize intermediate sum register a3 with 0
   // Loop:
   // Inst #4: ADD,r14,r13,r14           // Incremental addition
   // Inst #5: ADDI,r13,r13,1            // Increment intermediate register by 1
   // Inst #6: BLT,r13,r12,1111111111000 // If a3 is less than a2, branch to label named &lt;loop&gt;
   // Inst #7: ADD,r10,r14,r0            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   

   </span><span class="tlx_structure">|cpu
      </span><span class="tlx_staging">@0
         </span><span class="tlx_logic">$reset = *reset;



      </span><span class="tlx_comments">// YOUR CODE HERE
      // ...

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">*passed = *cyc_cnt &gt; 40;
   *failed = 1'b0;
   
   </span><span class="tlx_comments">// Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   </span><span class="tlx_structure">|cpu
      \source /raw.githubusercontent.com/stevehoover/RISCVMYTHWorkshop/c1719d5b338896577b79ee76c2f443ca2a76e14f/tlvlib/riscvshelllib.tlv 16   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+imem(@1)    // Args: (read stage)
         // Instruction Memory containing program defined by m4_asm(...) instantiations.
         </span><span class="tlx_staging">@1
            </span><span class="tlx_structure">\SV_plus
               </span><span class="tlx_comments">// The program in an instruction memory.
               </span><span class="tlx_logic">logic [31:0] instrs [0:8-1];
               assign instrs = '{
                  {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd10, 7'b0110011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd14, 7'b0110011}, {12'b1010, 5'd10, 3'b000, 5'd12, 7'b0010011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd13, 7'b0110011}, {7'b0000000, 5'd14, 5'd13, 3'b000, 5'd14, 7'b0110011}, {12'b1, 5'd13, 3'b000, 5'd13, 7'b0010011}, {1'b1, 6'b111111, 5'd12, 5'd13, 3'b100, 4'b1100, 1'b1, 7'b1100011}, {7'b0000000, 5'd0, 5'd14, 3'b000, 5'd10, 7'b0110011}
               };
            </span><span class="tlx_structure">/imem[</span><span class="tlx_logic">7</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$instr[31:0] = *instrs\[#imem\];
            </span><span class="tlx_validity">?$imem_rd_en
               </span><span class="tlx_logic">$imem_rd_data[31:0] = </span><span class="tlx_structure">/imem[</span><span class="tlx_logic">$imem_rd_addr</span><span class="tlx_structure">]</span><span class="tlx_logic">$instr;
          
      </span><span class="tlx_structure">\end_source    </span><span class="tlx_comments">// Args: (read stage)
      </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/RISCVMYTHWorkshop/c1719d5b338896577b79ee76c2f443ca2a76e14f/tlvlib/riscvshelllib.tlv 33   </span><span class="tlx_comments">// Instantiated from top.tlv, 65 as: m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
         // Reg File
         </span><span class="tlx_staging">@1
            </span><span class="tlx_structure">/xreg[</span><span class="tlx_logic">31</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$wr = </span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$rf_wr_en &amp;&amp; (</span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$rf_wr_index != 5'b0) &amp;&amp; (</span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$rf_wr_index == #xreg);
               $value[31:0] = </span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$reset ?   #xreg           :
                              $wr        ?   </span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$rf_wr_data :
                                             $RETAIN;
         </span><span class="tlx_staging">@1
            </span><span class="tlx_validity">?$rf_rd_en1
               </span><span class="tlx_logic">$rf_rd_data1[31:0] = </span><span class="tlx_structure">/xreg[</span><span class="tlx_logic">$rf_rd_index1</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$value;
            </span><span class="tlx_validity">?$rf_rd_en2
               </span><span class="tlx_logic">$rf_rd_data2[31:0] = </span><span class="tlx_structure">/xreg[</span><span class="tlx_logic">$rf_rd_index2</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$value;
            `BOGUS_USE($rf_rd_data1 $rf_rd_data2) 
      </span><span class="tlx_structure">\end_source  </span><span class="tlx_comments">// Args: (read stage, write stage) - if equal, no register bypass is required
      </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/RISCVMYTHWorkshop/c1719d5b338896577b79ee76c2f443ca2a76e14f/tlvlib/riscvshelllib.tlv 50   </span><span class="tlx_comments">// Instantiated from top.tlv, 66 as: m4+dmem(@4)    // Args: (read/write stage)
         // Data Memory
         </span><span class="tlx_staging">@4
            </span><span class="tlx_structure">/dmem[</span><span class="tlx_logic">15</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$wr = </span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$dmem_wr_en &amp;&amp; (</span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$dmem_addr == #dmem);
               $value[31:0] = </span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$reset ?   #dmem :
                              $wr        ?   </span><span class="tlx_structure">|cpu</span><span class="tlx_logic">$dmem_wr_data :
                                             $RETAIN;
                                        
            </span><span class="tlx_validity">?$dmem_rd_en
               </span><span class="tlx_logic">$dmem_rd_data[31:0] = </span><span class="tlx_structure">/dmem[</span><span class="tlx_logic">$dmem_addr</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$value;
            `BOGUS_USE($dmem_rd_data)
      </span><span class="tlx_structure">\end_source    </span><span class="tlx_comments">// Args: (read/write stage)
   
   //m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   // Included URL: &quot;https://raw.githubusercontent.com/stevehoover/RISC-V_MYTH_Workshop/c1719d5b338896577b79ee76c2f443ca2a76e14f/tlv_lib/risc-v_shell_lib.tlv&quot;// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/warp-v_includes/2d6d36baa4d2bc62321f982f78c8fe1456641a43/risc-v_defs.tlv&quot;

//_\SV
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   // Inst #0: ADD,r10,r0,r0             // Initialize r10 (a0) to 0.
   // Function:
   // Inst #1: ADD,r14,r10,r0            // Initialize sum register a4 with 0x0
   // Inst #2: ADDI,r12,r10,1010         // Store count of 10 in register a2.
   // Inst #3: ADD,r13,r10,r0            // Initialize intermediate sum register a3 with 0
   // Loop:
   // Inst #4: ADD,r14,r13,r14           // Incremental addition
   // Inst #5: ADDI,r13,r13,1            // Increment intermediate register by 1
   // Inst #6: BLT,r13,r12,1111111111000 // If a3 is less than a2, branch to label named &lt;loop&gt;
   // Inst #7: ADD,r10,r14,r0            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   

   //_|cpu
      //_@0
         </span><span class="tlx_logic">assign CPU_reset_a0 = reset;



      </span><span class="tlx_comments">// YOUR CODE HERE
      // ...

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">assign passed = cyc_cnt &gt; 40;
   assign failed = 1'b0;
   
   </span><span class="tlx_comments">// Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   //_|cpu
      </span><span class="tlx_structure">`line 17 &quot;/raw.githubusercontent.com/stevehoover/RISCVMYTHWorkshop/c1719d5b338896577b79ee76c2f443ca2a76e14f/tlvlib/riscvshelllib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+imem(@1)    // Args: (read stage)
         // Instruction Memory containing program defined by m4_asm(...) instantiations.
         //_@1
            /*SV_plus*/
               // The program in an instruction memory.
               </span><span class="tlx_logic">logic [31:0] instrs [0:8-1];
               assign instrs = '{
                  {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd10, 7'b0110011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd14, 7'b0110011}, {12'b1010, 5'd10, 3'b000, 5'd12, 7'b0010011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd13, 7'b0110011}, {7'b0000000, 5'd14, 5'd13, 3'b000, 5'd14, 7'b0110011}, {12'b1, 5'd13, 3'b000, 5'd13, 7'b0010011}, {1'b1, 6'b111111, 5'd12, 5'd13, 3'b100, 4'b1100, 1'b1, 7'b1100011}, {7'b0000000, 5'd0, 5'd14, 3'b000, 5'd10, 7'b0110011}
               };
            </span><span class="tlx_structure">for (imem = 0; imem &lt;= 7; imem++) begin : L1_CPU_Imem </span><span class="tlx_comments">//_/imem
               </span><span class="tlx_logic">assign CPU_Imem_instr_a1[imem][31:0] = instrs[imem]; </span><span class="tlx_structure">end
            </span><span class="tlx_comments">//_?$imem_rd_en
               </span><span class="tlx_logic">assign CPU_imem_rd_data_a1[31:0] = CPU_Imem_instr_a1[CPU_imem_rd_addr_a1];
          
      </span><span class="tlx_comments">//_\end_source    // Args: (read stage)
      </span><span class="tlx_structure">`line 65 &quot;top.tlv&quot; 2
      `line 34 &quot;/raw.githubusercontent.com/stevehoover/RISCVMYTHWorkshop/c1719d5b338896577b79ee76c2f443ca2a76e14f/tlvlib/riscvshelllib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 65 as: m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
         // Reg File
         //_@1
            </span><span class="tlx_structure">for (xreg = 0; xreg &lt;= 31; xreg++) begin : L1_CPU_Xreg </span><span class="tlx_declarations">logic L1_wr_a1; </span><span class="tlx_comments">//_/xreg
               </span><span class="tlx_logic">assign L1_wr_a1 = CPU_rf_wr_en_a1 &amp;&amp; (CPU_rf_wr_index_a1 != 5'b0) &amp;&amp; (CPU_rf_wr_index_a1 == xreg);
               assign CPU_Xreg_value_a1[xreg][31:0] = CPU_reset_a1 ?   xreg           :
                              L1_wr_a1        ?   CPU_rf_wr_data_a1 :
                                             CPU_Xreg_value_a2[xreg][31:0]; </span><span class="tlx_structure">end
         </span><span class="tlx_comments">//_@1
            //_?$rf_rd_en1
               </span><span class="tlx_logic">assign CPU_rf_rd_data1_a1[31:0] = CPU_Xreg_value_a2[CPU_rf_rd_index1_a1];
            </span><span class="tlx_comments">//_?$rf_rd_en2
               </span><span class="tlx_logic">assign CPU_rf_rd_data2_a1[31:0] = CPU_Xreg_value_a2[CPU_rf_rd_index2_a1];
            `BOGUS_USE(CPU_rf_rd_data1_a1 CPU_rf_rd_data2_a1) 
      </span><span class="tlx_comments">//_\end_source  // Args: (read stage, write stage) - if equal, no register bypass is required
      </span><span class="tlx_structure">`line 66 &quot;top.tlv&quot; 2
      `line 51 &quot;/raw.githubusercontent.com/stevehoover/RISCVMYTHWorkshop/c1719d5b338896577b79ee76c2f443ca2a76e14f/tlvlib/riscvshelllib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 66 as: m4+dmem(@4)    // Args: (read/write stage)
         // Data Memory
         //_@4
            </span><span class="tlx_structure">for (dmem = 0; dmem &lt;= 15; dmem++) begin : L1_CPU_Dmem </span><span class="tlx_declarations">logic L1_wr_a4; </span><span class="tlx_comments">//_/dmem
               </span><span class="tlx_logic">assign L1_wr_a4 = CPU_dmem_wr_en_a4 &amp;&amp; (CPU_dmem_addr_a4 == dmem);
               assign CPU_Dmem_value_a4[dmem][31:0] = CPU_reset_a4 ?   dmem :
                              L1_wr_a4        ?   CPU_dmem_wr_data_a4 :
                                             CPU_Dmem_value_a5[dmem][31:0]; </span><span class="tlx_structure">end
                                        
            </span><span class="tlx_comments">//_?$dmem_rd_en
               </span><span class="tlx_logic">assign CPU_dmem_rd_data_a4[31:0] = CPU_Dmem_value_a5[CPU_dmem_addr_a4];
            `BOGUS_USE(CPU_dmem_rd_data_a4)
      </span><span class="tlx_structure">endgenerate </span><span class="tlx_comments">//_\end_source    // Args: (read/write stage)
      </span><span class="tlx_structure">`line 67 &quot;top.tlv&quot; 2
   
   </span><span class="tlx_comments">//m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"


genvar dmem, imem, xreg;


//
// Signals declared top-level.
//

// For |cpu$dmem_addr.
logic CPU_dmem_addr_a4;

// For |cpu$dmem_rd_data.
logic [31:0] CPU_dmem_rd_data_a4;

// For |cpu$dmem_rd_en.
logic CPU_dmem_rd_en_a4;

// For |cpu$dmem_wr_data.
logic CPU_dmem_wr_data_a4;

// For |cpu$dmem_wr_en.
logic CPU_dmem_wr_en_a4;

// For |cpu$imem_rd_addr.
logic CPU_imem_rd_addr_a1;

// For |cpu$imem_rd_data.
logic [31:0] CPU_imem_rd_data_a1;

// For |cpu$imem_rd_en.
logic CPU_imem_rd_en_a1;

// For |cpu$reset.
logic CPU_reset_a0,
      CPU_reset_a1,
      CPU_reset_a2,
      CPU_reset_a3,
      CPU_reset_a4;

// For |cpu$rf_rd_data1.
logic [31:0] CPU_rf_rd_data1_a1;

// For |cpu$rf_rd_data2.
logic [31:0] CPU_rf_rd_data2_a1;

// For |cpu$rf_rd_en1.
logic CPU_rf_rd_en1_a1;

// For |cpu$rf_rd_en2.
logic CPU_rf_rd_en2_a1;

// For |cpu$rf_rd_index1.
logic CPU_rf_rd_index1_a1;

// For |cpu$rf_rd_index2.
logic CPU_rf_rd_index2_a1;

// For |cpu$rf_wr_data.
logic CPU_rf_wr_data_a1;

// For |cpu$rf_wr_en.
logic CPU_rf_wr_en_a1;

// For |cpu$rf_wr_index.
logic CPU_rf_wr_index_a1;

// For |cpu/dmem$value.
logic [31:0] CPU_Dmem_value_a4 [15:0],
             CPU_Dmem_value_a5 [15:0];

// For |cpu/imem$instr.
logic [31:0] CPU_Imem_instr_a1 [7:0];

// For |cpu/xreg$value.
logic [31:0] CPU_Xreg_value_a1 [31:0],
             CPU_Xreg_value_a2 [31:0];



generate


   //
   // Scope: |cpu
   //

      // For signal $dmem_addr, which had no assignment.
      assign CPU_dmem_addr_a4 = 'x;

      // For signal $dmem_rd_en, which had no assignment.
      assign CPU_dmem_rd_en_a4 = 'x;

      // For signal $dmem_wr_data, which had no assignment.
      assign CPU_dmem_wr_data_a4 = 'x;

      // For signal $dmem_wr_en, which had no assignment.
      assign CPU_dmem_wr_en_a4 = 'x;

      // For signal $imem_rd_addr, which had no assignment.
      assign CPU_imem_rd_addr_a1 = 'x;

      // For signal $imem_rd_en, which had no assignment.
      assign CPU_imem_rd_en_a1 = 'x;

      // For $reset.
      always_ff @(posedge clk) CPU_reset_a1 <= CPU_reset_a0;
      always_ff @(posedge clk) CPU_reset_a2 <= CPU_reset_a1;
      always_ff @(posedge clk) CPU_reset_a3 <= CPU_reset_a2;
      always_ff @(posedge clk) CPU_reset_a4 <= CPU_reset_a3;

      // For signal $rf_rd_en1, which had no assignment.
      assign CPU_rf_rd_en1_a1 = 'x;

      // For signal $rf_rd_en2, which had no assignment.
      assign CPU_rf_rd_en2_a1 = 'x;

      // For signal $rf_rd_index1, which had no assignment.
      assign CPU_rf_rd_index1_a1 = 'x;

      // For signal $rf_rd_index2, which had no assignment.
      assign CPU_rf_rd_index2_a1 = 'x;

      // For signal $rf_wr_data, which had no assignment.
      assign CPU_rf_wr_data_a1 = 'x;

      // For signal $rf_wr_en, which had no assignment.
      assign CPU_rf_wr_en_a1 = 'x;

      // For signal $rf_wr_index, which had no assignment.
      assign CPU_rf_wr_index_a1 = 'x;


      //
      // Scope: /dmem[15:0]
      //
      for (dmem = 0; dmem <= 15; dmem++) begin : L1gen_CPU_Dmem
         // For $value.
         always_ff @(posedge clk) CPU_Dmem_value_a5[dmem][31:0] <= CPU_Dmem_value_a4[dmem][31:0];

      end

      //
      // Scope: /xreg[31:0]
      //
      for (xreg = 0; xreg <= 31; xreg++) begin : L1gen_CPU_Xreg
         // For $value.
         always_ff @(posedge clk) CPU_Xreg_value_a2[xreg][31:0] <= CPU_Xreg_value_a1[xreg][31:0];

      end



endgenerate




//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS


      //
      // Scope: |cpu
      //
      if (1) begin : \|cpu 
         logic  \@4$dmem_addr ;
         assign \@4$dmem_addr = CPU_dmem_addr_a4;
         logic [31:0] \@4$dmem_rd_data ;
         assign \@4$dmem_rd_data = CPU_dmem_rd_data_a4;
         logic  \@4$dmem_rd_en ;
         assign \@4$dmem_rd_en = CPU_dmem_rd_en_a4;
         logic  \@4$dmem_wr_data ;
         assign \@4$dmem_wr_data = CPU_dmem_wr_data_a4;
         logic  \@4$dmem_wr_en ;
         assign \@4$dmem_wr_en = CPU_dmem_wr_en_a4;
         logic  \@1$imem_rd_addr ;
         assign \@1$imem_rd_addr = CPU_imem_rd_addr_a1;
         logic [31:0] \@1$imem_rd_data ;
         assign \@1$imem_rd_data = CPU_imem_rd_data_a1;
         logic  \@1$imem_rd_en ;
         assign \@1$imem_rd_en = CPU_imem_rd_en_a1;
         logic  \@0$reset ;
         assign \@0$reset = CPU_reset_a0;
         logic [31:0] \@1$rf_rd_data1 ;
         assign \@1$rf_rd_data1 = CPU_rf_rd_data1_a1;
         logic [31:0] \@1$rf_rd_data2 ;
         assign \@1$rf_rd_data2 = CPU_rf_rd_data2_a1;
         logic  \@1$rf_rd_en1 ;
         assign \@1$rf_rd_en1 = CPU_rf_rd_en1_a1;
         logic  \@1$rf_rd_en2 ;
         assign \@1$rf_rd_en2 = CPU_rf_rd_en2_a1;
         logic  \@1$rf_rd_index1 ;
         assign \@1$rf_rd_index1 = CPU_rf_rd_index1_a1;
         logic  \@1$rf_rd_index2 ;
         assign \@1$rf_rd_index2 = CPU_rf_rd_index2_a1;
         logic  \@1$rf_wr_data ;
         assign \@1$rf_wr_data = CPU_rf_wr_data_a1;
         logic  \@1$rf_wr_en ;
         assign \@1$rf_wr_en = CPU_rf_wr_en_a1;
         logic  \@1$rf_wr_index ;
         assign \@1$rf_wr_index = CPU_rf_wr_index_a1;

         //
         // Scope: /dmem[15:0]
         //
         for (dmem = 0; dmem <= 15; dmem++) begin : \/dmem 
            logic [31:0] \@4$value ;
            assign \@4$value = CPU_Dmem_value_a4[dmem];
            logic  \@4$wr ;
            assign \@4$wr = L1_CPU_Dmem[dmem].L1_wr_a4;
         end

         //
         // Scope: /imem[7:0]
         //
         for (imem = 0; imem <= 7; imem++) begin : \/imem 
            logic [31:0] \@1$instr ;
            assign \@1$instr = CPU_Imem_instr_a1[imem];
         end

         //
         // Scope: /xreg[31:0]
         //
         for (xreg = 0; xreg <= 31; xreg++) begin : \/xreg 
            logic [31:0] \@1$value ;
            assign \@1$value = CPU_Xreg_value_a1[xreg];
            logic  \@1$wr ;
            assign \@1$wr = L1_CPU_Xreg[xreg].L1_wr_a1;
         end
      end


   end

endgenerate




generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.

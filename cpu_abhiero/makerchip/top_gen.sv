// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /usr/local/mono/sandpiper/distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"


genvar dmem, imem, xreg;


//
// Signals declared top-level.
//

// For |cpu$dmem_addr.
logic CPU_dmem_addr_a4;

// For |cpu$dmem_rd_data.
logic [31:0] CPU_dmem_rd_data_a4;

// For |cpu$dmem_rd_en.
logic CPU_dmem_rd_en_a4;

// For |cpu$dmem_wr_data.
logic CPU_dmem_wr_data_a4;

// For |cpu$dmem_wr_en.
logic CPU_dmem_wr_en_a4;

// For |cpu$imem_rd_addr.
logic CPU_imem_rd_addr_a1;

// For |cpu$imem_rd_data.
logic [31:0] CPU_imem_rd_data_a1;

// For |cpu$imem_rd_en.
logic CPU_imem_rd_en_a1;

// For |cpu$r_dmem_addr.
logic [31:0] CPU_r_dmem_addr_a3,
             CPU_r_dmem_addr_a4;

// For |cpu$r_dmem_rd_en.
logic [31:0] CPU_r_dmem_rd_en_a3,
             CPU_r_dmem_rd_en_a4;

// For |cpu$r_dmem_wr_data.
logic [31:0] CPU_r_dmem_wr_data_a3,
             CPU_r_dmem_wr_data_a4;

// For |cpu$r_dmem_wr_en.
logic [31:0] CPU_r_dmem_wr_en_a3,
             CPU_r_dmem_wr_en_a4;

// For |cpu$r_imem_rd_addr.
logic [31:0] CPU_r_imem_rd_addr_a0,
             CPU_r_imem_rd_addr_a1;

// For |cpu$r_imem_rd_en.
logic [31:0] CPU_r_imem_rd_en_a0,
             CPU_r_imem_rd_en_a1;

// For |cpu$r_rf_rd_en1.
logic [31:0] CPU_r_rf_rd_en1_a0,
             CPU_r_rf_rd_en1_a1;

// For |cpu$r_rf_rd_en2.
logic [31:0] CPU_r_rf_rd_en2_a0,
             CPU_r_rf_rd_en2_a1;

// For |cpu$r_rf_rd_index1.
logic [31:0] CPU_r_rf_rd_index1_a0,
             CPU_r_rf_rd_index1_a1;

// For |cpu$r_rf_rd_index2.
logic [31:0] CPU_r_rf_rd_index2_a0,
             CPU_r_rf_rd_index2_a1;

// For |cpu$r_rf_wr_data.
logic [31:0] CPU_r_rf_wr_data_a0,
             CPU_r_rf_wr_data_a1;

// For |cpu$r_rf_wr_en.
logic [31:0] CPU_r_rf_wr_en_a0,
             CPU_r_rf_wr_en_a1;

// For |cpu$r_rf_wr_index.
logic [31:0] CPU_r_rf_wr_index_a0,
             CPU_r_rf_wr_index_a1;

// For |cpu$reset.
logic CPU_reset_a0,
      CPU_reset_a1,
      CPU_reset_a2,
      CPU_reset_a3,
      CPU_reset_a4;

// For |cpu$rf_rd_data1.
logic [31:0] CPU_rf_rd_data1_a1;

// For |cpu$rf_rd_data2.
logic [31:0] CPU_rf_rd_data2_a1;

// For |cpu$rf_rd_en1.
logic CPU_rf_rd_en1_a1;

// For |cpu$rf_rd_en2.
logic CPU_rf_rd_en2_a1;

// For |cpu$rf_rd_index1.
logic CPU_rf_rd_index1_a1;

// For |cpu$rf_rd_index2.
logic CPU_rf_rd_index2_a1;

// For |cpu$rf_wr_data.
logic CPU_rf_wr_data_a1;

// For |cpu$rf_wr_en.
logic CPU_rf_wr_en_a1;

// For |cpu$rf_wr_index.
logic CPU_rf_wr_index_a1;

// For |cpu/dmem$value.
logic [31:0] CPU_Dmem_value_a4 [15:0],
             CPU_Dmem_value_a5 [15:0];

// For |cpu/imem$instr.
logic [31:0] CPU_Imem_instr_a1 [7:0];

// For |cpu/xreg$value.
logic [31:0] CPU_Xreg_value_a1 [31:0],
             CPU_Xreg_value_a2 [31:0];



generate


   //
   // Scope: |cpu
   //

      // For signal $dmem_addr, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_dmem_addr_a4 = CPU_r_dmem_addr_a4;
      // verilator lint_restore

      // For signal $dmem_rd_en, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_dmem_rd_en_a4 = CPU_r_dmem_rd_en_a4;
      // verilator lint_restore

      // For signal $dmem_wr_data, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_dmem_wr_data_a4 = CPU_r_dmem_wr_data_a4;
      // verilator lint_restore

      // For signal $dmem_wr_en, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_dmem_wr_en_a4 = CPU_r_dmem_wr_en_a4;
      // verilator lint_restore

      // For signal $imem_rd_addr, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_imem_rd_addr_a1 = CPU_r_imem_rd_addr_a1;
      // verilator lint_restore

      // For signal $imem_rd_en, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_imem_rd_en_a1 = CPU_r_imem_rd_en_a1;
      // verilator lint_restore

      // For random value for missing assignment.
      assign CPU_r_dmem_addr_a3[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_dmem_addr_a4[31:0] <= CPU_r_dmem_addr_a3[31:0];

      // For random value for missing assignment.
      assign CPU_r_dmem_rd_en_a3[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_dmem_rd_en_a4[31:0] <= CPU_r_dmem_rd_en_a3[31:0];

      // For random value for missing assignment.
      assign CPU_r_dmem_wr_data_a3[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_dmem_wr_data_a4[31:0] <= CPU_r_dmem_wr_data_a3[31:0];

      // For random value for missing assignment.
      assign CPU_r_dmem_wr_en_a3[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_dmem_wr_en_a4[31:0] <= CPU_r_dmem_wr_en_a3[31:0];

      // For random value for missing assignment.
      assign CPU_r_imem_rd_addr_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_imem_rd_addr_a1[31:0] <= CPU_r_imem_rd_addr_a0[31:0];

      // For random value for missing assignment.
      assign CPU_r_imem_rd_en_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_imem_rd_en_a1[31:0] <= CPU_r_imem_rd_en_a0[31:0];

      // For random value for missing assignment.
      assign CPU_r_rf_rd_en1_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_rf_rd_en1_a1[31:0] <= CPU_r_rf_rd_en1_a0[31:0];

      // For random value for missing assignment.
      assign CPU_r_rf_rd_en2_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_rf_rd_en2_a1[31:0] <= CPU_r_rf_rd_en2_a0[31:0];

      // For random value for missing assignment.
      assign CPU_r_rf_rd_index1_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_rf_rd_index1_a1[31:0] <= CPU_r_rf_rd_index1_a0[31:0];

      // For random value for missing assignment.
      assign CPU_r_rf_rd_index2_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_rf_rd_index2_a1[31:0] <= CPU_r_rf_rd_index2_a0[31:0];

      // For random value for missing assignment.
      assign CPU_r_rf_wr_data_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_rf_wr_data_a1[31:0] <= CPU_r_rf_wr_data_a0[31:0];

      // For random value for missing assignment.
      assign CPU_r_rf_wr_en_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_rf_wr_en_a1[31:0] <= CPU_r_rf_wr_en_a0[31:0];

      // For random value for missing assignment.
      assign CPU_r_rf_wr_index_a0[31:0] = $random() ^ {31'b0, clk};
      always_ff @(posedge clk) CPU_r_rf_wr_index_a1[31:0] <= CPU_r_rf_wr_index_a0[31:0];

      // For $reset.
      always_ff @(posedge clk) CPU_reset_a1 <= CPU_reset_a0;
      always_ff @(posedge clk) CPU_reset_a2 <= CPU_reset_a1;
      always_ff @(posedge clk) CPU_reset_a3 <= CPU_reset_a2;
      always_ff @(posedge clk) CPU_reset_a4 <= CPU_reset_a3;

      // For signal $rf_rd_en1, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_rf_rd_en1_a1 = CPU_r_rf_rd_en1_a1;
      // verilator lint_restore

      // For signal $rf_rd_en2, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_rf_rd_en2_a1 = CPU_r_rf_rd_en2_a1;
      // verilator lint_restore

      // For signal $rf_rd_index1, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_rf_rd_index1_a1 = CPU_r_rf_rd_index1_a1;
      // verilator lint_restore

      // For signal $rf_rd_index2, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_rf_rd_index2_a1 = CPU_r_rf_rd_index2_a1;
      // verilator lint_restore

      // For signal $rf_wr_data, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_rf_wr_data_a1 = CPU_r_rf_wr_data_a1;
      // verilator lint_restore

      // For signal $rf_wr_en, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_rf_wr_en_a1 = CPU_r_rf_wr_en_a1;
      // verilator lint_restore

      // For signal $rf_wr_index, which had no assignment.
      // Assign to a random value.
      // verilator lint_save
      // verilator lint_off WIDTH
      assign CPU_rf_wr_index_a1 = CPU_r_rf_wr_index_a1;
      // verilator lint_restore


      //
      // Scope: /dmem[15:0]
      //
      for (dmem = 0; dmem <= 15; dmem++) begin : L1gen_CPU_Dmem
         // For $value.
         always_ff @(posedge clk) CPU_Dmem_value_a5[dmem][31:0] <= CPU_Dmem_value_a4[dmem][31:0];

      end

      //
      // Scope: /xreg[31:0]
      //
      for (xreg = 0; xreg <= 31; xreg++) begin : L1gen_CPU_Xreg
         // For $value.
         always_ff @(posedge clk) CPU_Xreg_value_a2[xreg][31:0] <= CPU_Xreg_value_a1[xreg][31:0];

      end



endgenerate




//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS


      //
      // Scope: |cpu
      //
      if (1) begin : \|cpu 
         logic  \>@4$dmem_addr ;
         assign \>@4$dmem_addr = CPU_dmem_addr_a4;
         logic [31:0] \>?$dmem_rd_en@4$dmem_rd_data ;
         assign \>?$dmem_rd_en@4$dmem_rd_data = CPU_dmem_rd_data_a4;
         logic  \>@4$dmem_rd_en ;
         assign \>@4$dmem_rd_en = CPU_dmem_rd_en_a4;
         logic  \>@4$dmem_wr_data ;
         assign \>@4$dmem_wr_data = CPU_dmem_wr_data_a4;
         logic  \>@4$dmem_wr_en ;
         assign \>@4$dmem_wr_en = CPU_dmem_wr_en_a4;
         logic  \>@1$imem_rd_addr ;
         assign \>@1$imem_rd_addr = CPU_imem_rd_addr_a1;
         logic [31:0] \>?$imem_rd_en@1$imem_rd_data ;
         assign \>?$imem_rd_en@1$imem_rd_data = CPU_imem_rd_data_a1;
         logic  \>@1$imem_rd_en ;
         assign \>@1$imem_rd_en = CPU_imem_rd_en_a1;
         logic  \>@0$reset ;
         assign \>@0$reset = CPU_reset_a0;
         logic [31:0] \>?$rf_rd_en1@1$rf_rd_data1 ;
         assign \>?$rf_rd_en1@1$rf_rd_data1 = CPU_rf_rd_data1_a1;
         logic [31:0] \>?$rf_rd_en2@1$rf_rd_data2 ;
         assign \>?$rf_rd_en2@1$rf_rd_data2 = CPU_rf_rd_data2_a1;
         logic  \>@1$rf_rd_en1 ;
         assign \>@1$rf_rd_en1 = CPU_rf_rd_en1_a1;
         logic  \>@1$rf_rd_en2 ;
         assign \>@1$rf_rd_en2 = CPU_rf_rd_en2_a1;
         logic  \>@1$rf_rd_index1 ;
         assign \>@1$rf_rd_index1 = CPU_rf_rd_index1_a1;
         logic  \>@1$rf_rd_index2 ;
         assign \>@1$rf_rd_index2 = CPU_rf_rd_index2_a1;
         logic  \>@1$rf_wr_data ;
         assign \>@1$rf_wr_data = CPU_rf_wr_data_a1;
         logic  \>@1$rf_wr_en ;
         assign \>@1$rf_wr_en = CPU_rf_wr_en_a1;
         logic  \>@1$rf_wr_index ;
         assign \>@1$rf_wr_index = CPU_rf_wr_index_a1;

         //
         // Scope: /dmem[15:0]
         //
         for (dmem = 0; dmem <= 15; dmem++) begin : \/dmem 
            logic [31:0] \>>@4$value ;
            assign \>>@4$value = CPU_Dmem_value_a4[dmem];
            logic  \>>@4$wr ;
            assign \>>@4$wr = L1_CPU_Dmem[dmem].L1_wr_a4;
         end

         //
         // Scope: /imem[7:0]
         //
         for (imem = 0; imem <= 7; imem++) begin : \/imem 
            logic [31:0] \>>@1$instr ;
            assign \>>@1$instr = CPU_Imem_instr_a1[imem];
         end

         //
         // Scope: /xreg[31:0]
         //
         for (xreg = 0; xreg <= 31; xreg++) begin : \/xreg 
            logic [31:0] \>>@1$value ;
            assign \>>@1$value = CPU_Xreg_value_a1[xreg];
            logic  \>>@1$wr ;
            assign \>>@1$wr = L1_CPU_Xreg[xreg].L1_wr_a1;
         end
      end


   end

endgenerate




generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.

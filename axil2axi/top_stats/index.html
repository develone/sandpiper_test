<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 12607, 467, 0, 4, 38, 0, 0, 0, 'opacity: 0.1', 8633, 'opacity: 0.1', 3588, 'opacity: 0.1'],
      ['top.sv', 0, 12607, 626, 0, 0, 70, 0, 0, 0, 'opacity: 0.1', 8746, 'opacity: 0.1', 3611, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 708, 1865, 53, 0, 0, 466, 'opacity: 0.1', 732, 'opacity: 0.1', 925, 'opacity: 0.1'],
      ['SV Total', 0, 12607, 626, 708, 1865, 123, 0, 0, 466, 'opacity: 0.1', 9478, 'opacity: 0.1', 4536, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;





</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For |axil$S_AXI_AWADDR.
</span><span class="tlx_declarations">logic [C_AXI_ADDR_WIDTH-1:0] AXIL_S_AXI_AWADDR_a0,
                             AXIL_S_AXI_AWADDR_a1,
                             AXIL_S_AXI_AWADDR_a2,
                             AXIL_S_AXI_AWADDR_a3,
                             AXIL_S_AXI_AWADDR_a4,
                             AXIL_S_AXI_AWADDR_a5;

</span><span class="tlx_comments">// For |axil$S_AXI_AWREADY.
</span><span class="tlx_declarations">logic AXIL_S_AXI_AWREADY_a0,
      AXIL_S_AXI_AWREADY_a1,
      AXIL_S_AXI_AWREADY_a2,
      AXIL_S_AXI_AWREADY_a3,
      AXIL_S_AXI_AWREADY_a4,
      AXIL_S_AXI_AWREADY_a5;

</span><span class="tlx_comments">// For |axil$S_AXI_AWVALID.
</span><span class="tlx_declarations">logic AXIL_S_AXI_AWVALID_a0,
      AXIL_S_AXI_AWVALID_a1,
      AXIL_S_AXI_AWVALID_a2,
      AXIL_S_AXI_AWVALID_a3,
      AXIL_S_AXI_AWVALID_a4,
      AXIL_S_AXI_AWVALID_a5;

</span><span class="tlx_comments">// For |axil$S_AXI_WREADY.
</span><span class="tlx_declarations">logic AXIL_S_AXI_WREADY_a0,
      AXIL_S_AXI_WREADY_a1,
      AXIL_S_AXI_WREADY_a2,
      AXIL_S_AXI_WREADY_a3,
      AXIL_S_AXI_WREADY_a4,
      AXIL_S_AXI_WREADY_a5;

</span><span class="tlx_comments">// For |axil$S_AXI_WVALID.
</span><span class="tlx_declarations">logic AXIL_S_AXI_WVALID_a0,
      AXIL_S_AXI_WVALID_a1,
      AXIL_S_AXI_WVALID_a2,
      AXIL_S_AXI_WVALID_a3,
      AXIL_S_AXI_WVALID_a4,
      AXIL_S_AXI_WVALID_a5;

</span><span class="tlx_comments">// For |axil$reset.
</span><span class="tlx_declarations">logic AXIL_reset_a0;


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">

   //
   // Scope: |axil
   //

      // For $S_AXI_AWADDR.
      </span><span class="tlx_staging">always_ff @(posedge clk) AXIL_S_AXI_AWADDR_a1[C_AXI_ADDR_WIDTH-1:0] &lt;= AXIL_S_AXI_AWADDR_a0[C_AXI_ADDR_WIDTH-1:0];
      always_ff @(posedge clk) AXIL_S_AXI_AWADDR_a2[C_AXI_ADDR_WIDTH-1:0] &lt;= AXIL_S_AXI_AWADDR_a1[C_AXI_ADDR_WIDTH-1:0];
      always_ff @(posedge clk) AXIL_S_AXI_AWADDR_a3[C_AXI_ADDR_WIDTH-1:0] &lt;= AXIL_S_AXI_AWADDR_a2[C_AXI_ADDR_WIDTH-1:0];
      always_ff @(posedge clk) AXIL_S_AXI_AWADDR_a4[C_AXI_ADDR_WIDTH-1:0] &lt;= AXIL_S_AXI_AWADDR_a3[C_AXI_ADDR_WIDTH-1:0];
      always_ff @(posedge clk) AXIL_S_AXI_AWADDR_a5[C_AXI_ADDR_WIDTH-1:0] &lt;= AXIL_S_AXI_AWADDR_a4[C_AXI_ADDR_WIDTH-1:0];

      </span><span class="tlx_comments">// For $S_AXI_AWREADY.
      </span><span class="tlx_staging">always_ff @(posedge clk) AXIL_S_AXI_AWREADY_a1 &lt;= AXIL_S_AXI_AWREADY_a0;
      always_ff @(posedge clk) AXIL_S_AXI_AWREADY_a2 &lt;= AXIL_S_AXI_AWREADY_a1;
      always_ff @(posedge clk) AXIL_S_AXI_AWREADY_a3 &lt;= AXIL_S_AXI_AWREADY_a2;
      always_ff @(posedge clk) AXIL_S_AXI_AWREADY_a4 &lt;= AXIL_S_AXI_AWREADY_a3;
      always_ff @(posedge clk) AXIL_S_AXI_AWREADY_a5 &lt;= AXIL_S_AXI_AWREADY_a4;

      </span><span class="tlx_comments">// For $S_AXI_AWVALID.
      </span><span class="tlx_staging">always_ff @(posedge clk) AXIL_S_AXI_AWVALID_a1 &lt;= AXIL_S_AXI_AWVALID_a0;
      always_ff @(posedge clk) AXIL_S_AXI_AWVALID_a2 &lt;= AXIL_S_AXI_AWVALID_a1;
      always_ff @(posedge clk) AXIL_S_AXI_AWVALID_a3 &lt;= AXIL_S_AXI_AWVALID_a2;
      always_ff @(posedge clk) AXIL_S_AXI_AWVALID_a4 &lt;= AXIL_S_AXI_AWVALID_a3;
      always_ff @(posedge clk) AXIL_S_AXI_AWVALID_a5 &lt;= AXIL_S_AXI_AWVALID_a4;

      </span><span class="tlx_comments">// For $S_AXI_WREADY.
      </span><span class="tlx_staging">always_ff @(posedge clk) AXIL_S_AXI_WREADY_a1 &lt;= AXIL_S_AXI_WREADY_a0;
      always_ff @(posedge clk) AXIL_S_AXI_WREADY_a2 &lt;= AXIL_S_AXI_WREADY_a1;
      always_ff @(posedge clk) AXIL_S_AXI_WREADY_a3 &lt;= AXIL_S_AXI_WREADY_a2;
      always_ff @(posedge clk) AXIL_S_AXI_WREADY_a4 &lt;= AXIL_S_AXI_WREADY_a3;
      always_ff @(posedge clk) AXIL_S_AXI_WREADY_a5 &lt;= AXIL_S_AXI_WREADY_a4;

      </span><span class="tlx_comments">// For $S_AXI_WVALID.
      </span><span class="tlx_staging">always_ff @(posedge clk) AXIL_S_AXI_WVALID_a1 &lt;= AXIL_S_AXI_WVALID_a0;
      always_ff @(posedge clk) AXIL_S_AXI_WVALID_a2 &lt;= AXIL_S_AXI_WVALID_a1;
      always_ff @(posedge clk) AXIL_S_AXI_WVALID_a3 &lt;= AXIL_S_AXI_WVALID_a2;
      always_ff @(posedge clk) AXIL_S_AXI_WVALID_a4 &lt;= AXIL_S_AXI_WVALID_a3;
      always_ff @(posedge clk) AXIL_S_AXI_WVALID_a5 &lt;= AXIL_S_AXI_WVALID_a4;




</span><span class="tlx_structure">endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS
</span><span class="tlx_comments">

      //
      // Scope: |axil
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|axil 
         logic [C_AXI_ADDR_WIDTH-1:0] \@0$S_AXI_AWADDR ;
         assign \@0$S_AXI_AWADDR = AXIL_S_AXI_AWADDR_a0;
         logic  \@0$S_AXI_AWREADY ;
         assign \@0$S_AXI_AWREADY = AXIL_S_AXI_AWREADY_a0;
         logic  \@0$S_AXI_AWVALID ;
         assign \@0$S_AXI_AWVALID = AXIL_S_AXI_AWVALID_a0;
         logic  \@0$S_AXI_WREADY ;
         assign \@0$S_AXI_WREADY = AXIL_S_AXI_WREADY_a0;
         logic  \@0$S_AXI_WVALID ;
         assign \@0$S_AXI_WVALID = AXIL_S_AXI_WVALID_a0;
         logic  \@0$reset ;
         assign \@0$reset = AXIL_reset_a0;
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV

 </span><span class="tlx_comments">////////////////////////////////////////////////////////////////////////////////
//
// Filename: 	axil2axis
// {{{
// Project:	WB2AXIPSP: bus bridges and other odds and ends
//
// Purpose:	Demonstrates a simple AXI-Lite interface to drive an AXI-Stream
//		channel.  This can then be used to debug DSP processing.
//
// Registers:	This AXI-lite to AXI-Stream core supports four word-sized
//		addresses.  Byte enables are ignored.
//
//   2'b00, ADDR_SINK
//		Writes to this register will send data to the stream master,
//		with TLAST clear.  Data goes first through a FIFO.  If the
//		FIFO is full, the write will stall.  If it stalls OPT_TIMEOUT
//		cycles, the write will fail and return a bus error.
//
//		Reads from this register will return data from the stream slave,
//		but without consuming it.  Values read here may still be read
//		from the ADDR_SOURCE register later.
//
//   2'b01, ADDR_SOURCE
//		Writes to this register will send data downstream to the stream
//		master as well, but this time with TLAST set.
//
//		Reads from this register will accept a value from the stream
//		slave interface.  The read value contains TDATA.  TLAST is
//		ignored in this read.  If you want access to TLAST, you can get
//		it from the ADDR_FIFO register.
//
//		If there is no data to be read, the read will not and does not
//		stall.  It will instead return a bus error.
//
//   2'b10, ADDR_STATS
//		Since we can, we'll handle some statistics  here.  The top half
//		word contains two counters: a 4-bit counter of TLAST's issued
//		from the stream master, and a 12-bit counter of TDATA values
//		issued.  Neither counter includes data still contained in the
//		FIFO.  If the OPT_SOURCE option is clear, these values will
//		always be zero.
//
//		The second (bottom, or least-significant) halfword contains the
//		same regarding the stream slave.  If OPT_SINK is set, these
//		counters count values read from the core.  If OPT_SINK is clear,
//		so that the stream sink is not truly implemented, then TREADY
//		will be held high and the counter will just count values coming
//		into the core never going into the FIFO.
//
//   2'b11, ADDR_FIFO
//		Working with the core can be a challenge.  You want to make
//		certain that writing to the core  doesn't hang the design, and
//		that reading from the core doesn't cause a bus error.
//
//		Bits 31:16 contain the number of items in the write FIFO, and
//		bits 14:0 contain the number of items in the read FIFO.
//
//		Bit 15 contains whether or not the next item to be read is
//		the last item in a packet, i.e. with TLAST set.
//		
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2020, Gisselquist Technology, LLC
// {{{
//
// This file is part of the WB2AXIP project.
//
// The WB2AXIP project contains free software and gateware, licensed under the
// Apache License, Version 2.0 (the &quot;License&quot;).  You may not use this project,
// or this file, except in compliance with the License.  You may obtain a copy
// of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.
//
////////////////////////////////////////////////////////////////////////////////
// }}}
//
</span><span class="tlx_untouched">`default_nettype none
</span><span class="tlx_comments">//
</span><span class="tlx_untouched">module	axil2axis #(
		</span><span class="tlx_comments">// {{{
		//
		// Size of the AXI-lite bus.  These are fixed, since 1) AXI-lite
		// is fixed at a width of 32-bits by Xilinx def'n, and 2) since
		// we only ever have 4 configuration words.
		</span><span class="tlx_untouched">parameter	C_AXI_ADDR_WIDTH = 4,
		localparam	C_AXI_DATA_WIDTH = 32,
		parameter	C_AXIS_DATA_WIDTH = 16,
		</span><span class="tlx_comments">//
		// OPT_SOURCE enables the AXI stream master logic.  If not
		// enabled, M_AXI_TVALID will be held at zero, and the stream
		// master logic may be ignored.
		</span><span class="tlx_untouched">parameter [0:0] OPT_SOURCE = 1'b1,
		</span><span class="tlx_comments">//
		// OPT_SINK enables the AXI stream slave logic.  If not enabled,
		// reads will always return zero, and S_AXIS_TREADY will be
		// held high.
		</span><span class="tlx_untouched">parameter [0:0] OPT_SINK = 1'b1,
		</span><span class="tlx_comments">//
		// If OPT_SIGN_EXTEND is set, values received will be sign
		// extended to fill the full data width on read.  Otherwise
		// the most significant of any unused bits will remain clear.
		</span><span class="tlx_untouched">parameter [0:0] OPT_SIGN_EXTEND = 1'b0,
		</span><span class="tlx_comments">//
		// Data written to this core will be placed into a FIFO before
		// entering the AXI stream master.  LGFIFO is the log, based
		// two, of the number of words in this FIFO.  Similarly, data
		// consumed by AXI stream slave contained in this core will go
		// first into a read FIFO.  Reads from the core will then return
		// data from this FIFO, or a bus error if none is available.
		</span><span class="tlx_untouched">parameter 	LGFIFO = 5,
		</span><span class="tlx_comments">//
		// OPT_TIMEOUT, if non-zero, will allow writes to the stream
		// master, or reads from the stream slave, to stall the core
		// for OPT_TIMEOUT cycles for the stream to be ready.  If the
		// stream isn't ready at this time (i.e. if the write FIFO is
		// still full, or the read FIFO still empty), the result will
		// be returned as a bus error.  Likewise, if OPT_TIMEOUT==0,
		// the core will always return a bus error if ever the write
		// FIFO is full or the read FIFO empty.
		</span><span class="tlx_untouched">parameter	OPT_TIMEOUT = 5,
		</span><span class="tlx_comments">//
		// OPT_LOWPOWER sets outputs to zero if not valid.  This applies
		// to the AXI-lite bus, however, and not the AXI stream FIFOs,
		// since those don't have LOWPOWER support (currently).
		</span><span class="tlx_untouched">parameter [0:0]	OPT_LOWPOWER = 0,
		</span><span class="tlx_comments">//
		// This design currently ignores WSTRB, beyond checking that it
		// is not zero.  I see no easy way to add it.  (I'll leave that
		// to you to implement, if you wish.)
		// parameter [0:0]	OPT_WSTRB = 0,
		//
		</span><span class="tlx_untouched">localparam	ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3
		</span><span class="tlx_comments">// }}}
	</span><span class="tlx_untouched">) (
		</span><span class="tlx_comments">// {{{
		</span><span class="tlx_untouched">input	wire					S_AXI_ACLK,
		input	wire					S_AXI_ARESETN,
		</span><span class="tlx_comments">// AXI-lite signals
		// {{{
		</span><span class="tlx_untouched">input	wire					S_AXI_AWVALID,
		output	wire					S_AXI_AWREADY,
		input	wire	[C_AXI_ADDR_WIDTH-1:0]		S_AXI_AWADDR,
		input	wire	[2:0]				S_AXI_AWPROT,
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">input	wire					S_AXI_WVALID,
		output	wire					S_AXI_WREADY,
		input	wire	[C_AXI_DATA_WIDTH-1:0]		S_AXI_WDATA,
		input	wire	[C_AXI_DATA_WIDTH/8-1:0]	S_AXI_WSTRB,
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">output	wire					S_AXI_BVALID,
		input	wire					S_AXI_BREADY,
		output	wire	[1:0]				S_AXI_BRESP,
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">input	wire					S_AXI_ARVALID,
		output	wire					S_AXI_ARREADY,
		input	wire	[C_AXI_ADDR_WIDTH-1:0]		S_AXI_ARADDR,
		input	wire	[2:0]				S_AXI_ARPROT,
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">output	wire					S_AXI_RVALID,
		input	wire					S_AXI_RREADY,
		output	wire	[C_AXI_DATA_WIDTH-1:0]		S_AXI_RDATA,
		output	wire	[1:0]				S_AXI_RRESP,
		</span><span class="tlx_comments">// }}}
		// AXI stream slave (sink) signals
		// {{{
		</span><span class="tlx_untouched">input	wire				S_AXIS_TVALID,
		output	reg				S_AXIS_TREADY,
		input	wire	[C_AXIS_DATA_WIDTH-1:0]	S_AXIS_TDATA,
		input	wire				S_AXIS_TLAST,
		</span><span class="tlx_comments">// }}}
		// AXI stream master (source) signals
		// {{{
		</span><span class="tlx_untouched">output	reg				M_AXIS_TVALID,
		input	wire				M_AXIS_TREADY,
		output	reg	[C_AXIS_DATA_WIDTH-1:0]	M_AXIS_TDATA,
		output	reg				M_AXIS_TLAST
		</span><span class="tlx_comments">// }}}
		// }}}
	</span><span class="tlx_untouched">);

	localparam	[1:0]	ADDR_SINK = 2'b00,	</span><span class="tlx_comments">// Read from stream
				</span><span class="tlx_untouched">ADDR_SOURCE = 2'b01, </span><span class="tlx_comments">// Write, also sets TLAST
				</span><span class="tlx_untouched">ADDR_STATS  = 2'b10,
				ADDR_FIFO   = 2'b11;
	localparam	SW = C_AXIS_DATA_WIDTH;

	</span><span class="tlx_comments">////////////////////////////////////////////////////////////////////////
	//
	// Register/wire signal declarations
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	</span><span class="tlx_untouched">wire	i_reset = !S_AXI_ARESETN;

	wire				axil_write_ready;
	wire	[C_AXI_ADDR_WIDTH-ADDRLSB-1:0]	awskd_addr;
	</span><span class="tlx_comments">//
	</span><span class="tlx_untouched">wire	[C_AXI_DATA_WIDTH-1:0]	wskd_data;
	wire [C_AXI_DATA_WIDTH/8-1:0]	wskd_strb;
	reg				axil_bvalid, axil_berr;
	</span><span class="tlx_comments">//
	</span><span class="tlx_untouched">wire				axil_read_ready;
	wire	[C_AXI_ADDR_WIDTH-ADDRLSB-1:0]	arskd_addr;
	reg	[C_AXI_DATA_WIDTH-1:0]	axil_read_data;
	reg				axil_read_valid;

	wire			awskd_valid, wskd_valid;
	wire			wfifo_full, wfifo_write, wfifo_empty;
	wire	[LGFIFO:0]	wfifo_fill;
	reg			write_timeout;

	reg			read_timeout;
	reg			axil_rerr;
	reg	[3:0]		read_bursts_completed;
	reg	[11:0]		reads_completed;

	reg	[3:0]	write_bursts_completed;
	reg	[11:0]	writes_completed;


	</span><span class="tlx_comments">// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// AXI-lite signaling
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{

	//
	// Write signaling
	//
	// {{{
	</span><span class="tlx_untouched">skidbuffer #(.OPT_OUTREG(0),
			.OPT_LOWPOWER(OPT_LOWPOWER),
			.DW(C_AXI_ADDR_WIDTH-ADDRLSB))
	axilawskid(</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_clk(S_AXI_ACLK), .i_reset(i_reset),
		.i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY),
		.i_data(S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]),
		.o_valid(awskd_valid), .i_ready(axil_write_ready),
		.o_data(awskd_addr));

	skidbuffer #(.OPT_OUTREG(0),
			.OPT_LOWPOWER(OPT_LOWPOWER),
			.DW(C_AXI_DATA_WIDTH+C_AXI_DATA_WIDTH/8))
	axilwskid(</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_clk(S_AXI_ACLK), .i_reset(i_reset),
		.i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY),
		.i_data({ S_AXI_WDATA, S_AXI_WSTRB }),
		.o_valid(wskd_valid), .i_ready(axil_write_ready),
		.o_data({ wskd_data, wskd_strb }));

	assign	axil_write_ready = awskd_valid &amp;&amp; wskd_valid
			&amp;&amp; (!S_AXI_BVALID || S_AXI_BREADY)
			&amp;&amp; ((awskd_addr[1] != ADDR_SOURCE[1])
				|| (!wfifo_full || write_timeout));

	</span><span class="tlx_comments">//
	// Write timeout generation
	//
	// {{{
	</span><span class="tlx_untouched">generate if ((OPT_TIMEOUT &gt; 1) &amp;&amp; OPT_SOURCE)
	begin

		reg [$clog2(OPT_TIMEOUT)-1:0] write_timer;

		initial	write_timer = OPT_TIMEOUT-1;
		initial	write_timeout = 0;
		always @(posedge S_AXI_ACLK)
		if (!S_AXI_ARESETN)
		begin
			write_timer &lt;= OPT_TIMEOUT-1;
			write_timeout&lt;= 1'b0;
		end else if (!awskd_valid || !wfifo_full || !wskd_valid
				|| (awskd_addr[1] != ADDR_SOURCE[1])
				|| (S_AXI_BVALID &amp;&amp; !S_AXI_BREADY))
		begin
			write_timer &lt;= OPT_TIMEOUT-1;
			write_timeout&lt;= 1'b0;
		end else begin
			if (write_timer &gt; 0)
				write_timer &lt;= write_timer - 1;
			write_timeout &lt;= (write_timer &lt;= 1);
		end

`ifdef	FORMAL
		always @(*)
			assert(write_timer &lt;= OPT_TIMEOUT-1);
		always @(*)
			assert(write_timeout == (write_timer == 0));
`endif
	end else begin

		always @(*)
			write_timeout&lt;= 1'b1;

	end endgenerate
	</span><span class="tlx_comments">// }}}
	

	</span><span class="tlx_untouched">initial	axil_bvalid = 0;
	always @(posedge S_AXI_ACLK)
	if (i_reset)
		axil_bvalid &lt;= 0;
	else if (axil_write_ready)
		axil_bvalid &lt;= 1;
	else if (S_AXI_BREADY)
		axil_bvalid &lt;= 0;

	assign	S_AXI_BVALID = axil_bvalid;

	initial	axil_berr = 0;
	always @(posedge S_AXI_ACLK)
	if (OPT_LOWPOWER &amp;&amp; i_reset)
		axil_berr &lt;= 0;
	else if (axil_write_ready)
		axil_berr &lt;= (wfifo_full)&amp;&amp;(awskd_addr[1]==ADDR_SOURCE[1]);
	else if (OPT_LOWPOWER &amp;&amp; S_AXI_BREADY)
		axil_berr &lt;= 1'b0;

	assign	S_AXI_BRESP = { axil_berr, 1'b0 };
	</span><span class="tlx_comments">// }}}

	//
	// AXI-stream source (Write) FIFO
	//
	// {{{
	</span><span class="tlx_untouched">assign	wfifo_write = axil_write_ready &amp;&amp; awskd_addr[1]==ADDR_SOURCE[1]
			&amp;&amp; wskd_strb != 0 &amp;&amp; !wfifo_full;

	generate if (OPT_SOURCE)
	begin

		sfifo #(.BW(SW+1), .LGFLEN(LGFIFO))
		source(.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),
			.i_wr(wfifo_write),
			.i_data({awskd_addr[0]==ADDR_SOURCE[0],
					wskd_data[SW-1:0]}),
			.o_full(wfifo_full), .o_fill(wfifo_fill),
			.i_rd(M_AXIS_TREADY),
				.o_data({ M_AXIS_TLAST, M_AXIS_TDATA }),
				.o_empty(wfifo_empty));

		always @(*)
			M_AXIS_TVALID = !wfifo_empty;

	end else begin

		always @(*)
		begin
			M_AXIS_TVALID = 1'b0;
			M_AXIS_TDATA  = 0;
			M_AXIS_TLAST  = 0;
		end

		assign	wfifo_full = 1'b0;
		assign	wfifo_fill = 0;

	end endgenerate
	</span><span class="tlx_comments">// }}}

	//
	// AXI-stream consumer/sink (Read) FIFO
	//
	// {{{
	</span><span class="tlx_untouched">wire			rfifo_empty, rfifo_full, rfifo_last, read_rfifo;
	wire	[LGFIFO:0]	rfifo_fill;
	wire	[SW-1:0]	rfifo_data;

	generate if (OPT_SINK)
	begin

		sfifo #(.BW(SW+1), .LGFLEN(LGFIFO))
		sink(.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),
			.i_wr(S_AXIS_TVALID &amp;&amp; S_AXIS_TREADY),
			.i_data({S_AXIS_TLAST, S_AXIS_TDATA}),
			.o_full(rfifo_full), .o_fill(rfifo_fill),
			.i_rd(read_rfifo),
				.o_data({ rfifo_last, rfifo_data }),
				.o_empty(rfifo_empty));

		always @(*)
			S_AXIS_TREADY = !rfifo_full;
		assign	read_rfifo =(axil_read_ready &amp;&amp; arskd_addr== ADDR_SINK)
				&amp;&amp; !rfifo_empty;

	end else begin

		always @(*)
			S_AXIS_TREADY = 1'b1;

		assign rfifo_empty = 1'b1;
		assign rfifo_data  = 0;
		assign rfifo_last  = 1'b1;
		assign rfifo_fill  = 0;

	end endgenerate
	</span><span class="tlx_comments">// }}}

	//
	// Read timeout generation
	//
	// {{{
	</span><span class="tlx_untouched">generate if (OPT_SINK &amp;&amp; OPT_TIMEOUT &gt; 1)
	begin
		reg [$clog2(OPT_TIMEOUT)-1:0] read_timer;

		initial	read_timer = OPT_TIMEOUT-1;
		initial	read_timeout = 1'b0;
		always @(posedge S_AXI_ACLK)
		if (!S_AXI_ARESETN)
		begin
			read_timer &lt;= OPT_TIMEOUT-1;
			read_timeout&lt;= 1'b0;
		end else if (!arskd_valid || (S_AXI_RVALID &amp;&amp; !S_AXI_RREADY)
				||!rfifo_empty
				||(arskd_addr[1] != ADDR_SINK[1]))
		begin
			read_timer &lt;= OPT_TIMEOUT-1;
			read_timeout&lt;= 1'b0;
		end else begin
			if (read_timer &gt; 0)
				read_timer &lt;= read_timer - 1;
			read_timeout &lt;= (read_timer &lt;= 1);
		end

`ifdef	FORMAL
		always @(*)
			assert(read_timer &lt;= OPT_TIMEOUT-1);
		always @(*)
			assert(read_timeout == (read_timer == 0));
`endif
	end else begin

		always @(*)
			read_timeout = 1'b1;

	end endgenerate
	</span><span class="tlx_comments">// }}}

	//
	// Read signaling
	//
	// {{{
	</span><span class="tlx_untouched">wire	arskd_valid;

	skidbuffer #(.OPT_OUTREG(0),
			.OPT_LOWPOWER(OPT_LOWPOWER),
			.DW(C_AXI_ADDR_WIDTH-ADDRLSB))
	axilarskid(</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_clk(S_AXI_ACLK), .i_reset(i_reset),
		.i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY),
		.i_data(S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]),
		.o_valid(arskd_valid), .i_ready(axil_read_ready),
		.o_data(arskd_addr));

	assign	axil_read_ready = arskd_valid
			&amp;&amp; (!S_AXI_RVALID || S_AXI_RREADY)
			&amp;&amp; ((arskd_addr[1] != ADDR_SINK[1])
				|| (!rfifo_empty || read_timeout));

	initial	axil_read_valid = 1'b0;
	always @(posedge S_AXI_ACLK)
	if (i_reset)
		axil_read_valid &lt;= 1'b0;
	else if (axil_read_ready)
		axil_read_valid &lt;= 1'b1;
	else if (S_AXI_RREADY)
		axil_read_valid &lt;= 1'b0;

	assign	S_AXI_RVALID = axil_read_valid;

	always @(posedge S_AXI_ACLK)
	if (OPT_LOWPOWER &amp;&amp; !S_AXI_ARESETN)
		axil_rerr &lt;= 1'b0;
	else if (axil_read_ready)
		axil_rerr &lt;= rfifo_empty &amp;&amp; (arskd_addr[1] == ADDR_SINK[1]);
	else if (OPT_LOWPOWER &amp;&amp; S_AXI_RREADY)
		axil_rerr &lt;= 1'b0;

	assign	S_AXI_RRESP = { axil_rerr, 1'b0 };
	</span><span class="tlx_comments">// }}}

	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// AXI-lite register logic
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{


	//
	// Read data counting
	// {{{
	</span><span class="tlx_untouched">initial	reads_completed = 0;
	initial	read_bursts_completed = 0;
	always @(posedge S_AXI_ACLK)
	if (!S_AXI_ARESETN)
	begin
		reads_completed &lt;= 0;
		read_bursts_completed &lt;= 0;
	end else if (!OPT_SINK)
	begin
		reads_completed &lt;= reads_completed + (S_AXIS_TVALID ? 1:0);
		read_bursts_completed &lt;= read_bursts_completed
				+ ((S_AXIS_TVALID &amp;&amp; S_AXIS_TLAST) ? 1:0);
	end else if (read_rfifo &amp;&amp; !rfifo_empty)
	begin
		reads_completed &lt;= reads_completed + 1;
		read_bursts_completed &lt;= read_bursts_completed + (rfifo_last ? 1:0);
	end
	</span><span class="tlx_comments">// }}}

	//
	// Write data counting
	// {{{
	</span><span class="tlx_untouched">generate if (OPT_SOURCE)
	begin

		initial	writes_completed = 0;
		initial	write_bursts_completed = 0;
		always @(posedge S_AXI_ACLK)
		if (!S_AXI_ARESETN)
		begin
			writes_completed &lt;= 0;
			write_bursts_completed &lt;= 0;
		end else if (M_AXIS_TVALID &amp;&amp; M_AXIS_TREADY)
		begin
			writes_completed &lt;= writes_completed + 1;
			write_bursts_completed &lt;= write_bursts_completed
					+ (M_AXIS_TLAST ? 1:0);
		end

	end else begin

		always @(*)
		begin
			writes_completed = 0;
			write_bursts_completed = 0;
		end

	end endgenerate
	</span><span class="tlx_comments">// }}}

	//
	// Read data register
	// {{{
	</span><span class="tlx_untouched">initial	axil_read_data = 0;
	always @(posedge S_AXI_ACLK)
	if (OPT_LOWPOWER &amp;&amp; !S_AXI_ARESETN)
		axil_read_data &lt;= 0;
	else if (!S_AXI_RVALID || S_AXI_RREADY)
	begin
		axil_read_data &lt;= 0;
		casez(arskd_addr)
		{ ADDR_SINK[1], 1'b? }:	begin
			if (OPT_SIGN_EXTEND &amp;&amp; rfifo_data[SW-1])
				axil_read_data &lt;= -1;
			axil_read_data[SW-1:0] &lt;= rfifo_data;
			end
		ADDR_STATS: begin
			axil_read_data[31:28] &lt;= write_bursts_completed;
			axil_read_data[27:16] &lt;= writes_completed;
			axil_read_data[15:12] &lt;= read_bursts_completed;
			axil_read_data[11:0]  &lt;= reads_completed;
			end
		ADDR_FIFO:	begin
			</span><span class="tlx_comments">// FIFO information
			</span><span class="tlx_untouched">axil_read_data[16 +: LGFIFO+1] &lt;= wfifo_fill;
			axil_read_data[15] &lt;= rfifo_last;
			axil_read_data[LGFIFO:0] &lt;= rfifo_fill;
			end
		endcase

		if (OPT_LOWPOWER &amp;&amp; !axil_read_ready)
			axil_read_data &lt;= 0;
	end

	assign	S_AXI_RDATA  = axil_read_data;
	</span><span class="tlx_comments">// }}}

	// Verilator lint_off UNUSED
	</span><span class="tlx_untouched">wire	unused;
	assign	unused = &amp;{ 1'b0, S_AXI_AWPROT, S_AXI_ARPROT,
			S_AXI_ARADDR[ADDRLSB-1:0],
			S_AXI_AWADDR[ADDRLSB-1:0],
			wskd_data[C_AXI_DATA_WIDTH-1:SW] };
	</span><span class="tlx_comments">// Verilator lint_on  UNUSED
	// }}}
</span><span class="tlx_untouched">`ifdef	FORMAL
	</span><span class="tlx_comments">////////////////////////////////////////////////////////////////////////
	//
	// Formal properties used in verfiying this core
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	// {{{
	</span><span class="tlx_untouched">reg	f_past_valid;
	initial	f_past_valid = 0;
	always @(posedge S_AXI_ACLK)
		f_past_valid &lt;= 1;

	always @(*)
	if (!f_past_valid)
		assume(!S_AXI_ARESETN);
	</span><span class="tlx_comments">// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// The AXI-lite control interface
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	</span><span class="tlx_untouched">localparam	F_AXIL_LGDEPTH = 4;
	wire	[F_AXIL_LGDEPTH-1:0]	faxil_rd_outstanding,
					faxil_wr_outstanding,
					faxil_awr_outstanding;

	faxil_slave #(
		</span><span class="tlx_comments">// {{{
		</span><span class="tlx_untouched">.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),
		.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),
		.F_LGDEPTH(F_AXIL_LGDEPTH),
		.F_AXI_MAXWAIT(OPT_TIMEOUT + 2),
		.F_AXI_MAXDELAY(OPT_TIMEOUT + 2),
		.F_AXI_MAXRSTALL(2),
		.F_OPT_COVER_BURST(4)
		</span><span class="tlx_comments">// }}}
	</span><span class="tlx_untouched">) faxil(
		</span><span class="tlx_comments">// {{{
		</span><span class="tlx_untouched">.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_awvalid(S_AXI_AWVALID),
		.i_axi_awready(S_AXI_AWREADY),
		.i_axi_awaddr( S_AXI_AWADDR),
		.i_axi_awcache(4'h0),
		.i_axi_awprot( S_AXI_AWPROT),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_wvalid(S_AXI_WVALID),
		.i_axi_wready(S_AXI_WREADY),
		.i_axi_wdata( S_AXI_WDATA),
		.i_axi_wstrb( S_AXI_WSTRB),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_bvalid(S_AXI_BVALID),
		.i_axi_bready(S_AXI_BREADY),
		.i_axi_bresp( S_AXI_BRESP),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_arvalid(S_AXI_ARVALID),
		.i_axi_arready(S_AXI_ARREADY),
		.i_axi_araddr( S_AXI_ARADDR),
		.i_axi_arcache(4'h0),
		.i_axi_arprot( S_AXI_ARPROT),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_rvalid(S_AXI_RVALID),
		.i_axi_rready(S_AXI_RREADY),
		.i_axi_rdata( S_AXI_RDATA),
		.i_axi_rresp( S_AXI_RRESP),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.f_axi_rd_outstanding(faxil_rd_outstanding),
		.f_axi_wr_outstanding(faxil_wr_outstanding),
		.f_axi_awr_outstanding(faxil_awr_outstanding)
		</span><span class="tlx_comments">// }}}
		</span><span class="tlx_untouched">);

	always @(*)
	begin
		assert(faxil_awr_outstanding== (S_AXI_BVALID ? 1:0)
			+(S_AXI_AWREADY ? 0:1));

		assert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0)
			+(S_AXI_WREADY ? 0:1));

		assert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0)
			+(S_AXI_ARREADY ? 0:1));
	end
	</span><span class="tlx_comments">// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// Verifying the packet counters
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	</span><span class="tlx_untouched">reg	[11:0]	f_reads, f_writes;
	reg	[3:0]	f_read_pkts, f_write_pkts;

	</span><span class="tlx_comments">//
	// Mirror the read counter
	//
	</span><span class="tlx_untouched">initial	f_reads      = 0;
	initial	f_read_pkts  = 0;

	always @(posedge S_AXI_ACLK)
	if (!S_AXI_ARESETN)
	begin
		f_reads &lt;= 0;
		f_read_pkts &lt;= 0;
	end else if (OPT_SINK &amp;&amp; (axil_read_ready
			&amp;&amp; arskd_addr == ADDR_SINK &amp;&amp; !rfifo_empty))
	begin
		f_reads &lt;= f_reads + 1;
		f_read_pkts &lt;= f_read_pkts + (rfifo_last ? 1:0);
	end else if (!OPT_SINK &amp;&amp; S_AXIS_TVALID)
	begin
		f_reads &lt;= f_reads + 1;
		f_read_pkts &lt;= f_read_pkts + (S_AXIS_TLAST ? 1:0);
	end

	always @(*)
		assert(f_reads == reads_completed);
	always @(*)
		assert(f_read_pkts == read_bursts_completed);

	always @(*)
	if (!OPT_SINK)
		assert(S_AXIS_TREADY);

	</span><span class="tlx_comments">//
	// Mirror the write counter
	//
	</span><span class="tlx_untouched">initial	f_writes     = 0;
	initial	f_write_pkts = 0;
	always @(posedge S_AXI_ACLK)
	if (!S_AXI_ARESETN)
	begin
		f_writes &lt;= 0;
		f_write_pkts &lt;= 0;
	end else if (OPT_SOURCE &amp;&amp; M_AXIS_TVALID &amp;&amp; M_AXIS_TREADY)
	begin
		f_writes &lt;= f_writes + 1;
		f_write_pkts &lt;= f_write_pkts + (M_AXIS_TLAST ? 1:0);
	end

	always @(*)
	if (!OPT_SOURCE)
	begin
		assert(f_writes == 0);
		assert(f_write_pkts == 0);
	end

	always @(*)
	begin
		assert(f_writes == writes_completed);
		assert(f_write_pkts == write_bursts_completed);
	end
	</span><span class="tlx_comments">// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// Verify the read result
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	</span><span class="tlx_untouched">always @(posedge S_AXI_ACLK)
	if (f_past_valid &amp;&amp; $past(S_AXI_ARESETN &amp;&amp; axil_read_ready))
	begin
		assert(S_AXI_RVALID);
		case($past(arskd_addr))
		ADDR_SINK: begin
			assert(S_AXI_RDATA[SW-1:0] == $past(rfifo_data));
			if (SW &lt; C_AXI_DATA_WIDTH)
			begin
				if (OPT_SIGN_EXTEND &amp;&amp; $past(rfifo_data[SW-1]))
					assert(&amp;S_AXI_RDATA[C_AXI_DATA_WIDTH-1:SW]);
				else
					assert(S_AXI_RDATA[C_AXI_DATA_WIDTH-1:SW] == 0);
			end end
		</span><span class="tlx_comments">// 1: assert(S_AXI_RDATA == $past(r1));
		</span><span class="tlx_untouched">ADDR_STATS: begin
			assert(S_AXI_RRESP == 2'b00);
			assert(S_AXI_RDATA[31:28]
					== $past(write_bursts_completed));
			assert(S_AXI_RDATA[27:16] == $past(writes_completed));

			assert(S_AXI_RDATA[15:12]
					== $past(read_bursts_completed));
			assert(S_AXI_RDATA[11:0] == $past(reads_completed));
			end
		ADDR_FIFO: begin
			assert(S_AXI_RRESP == 2'b00);
			if (LGFIFO &lt; 16)
				assert(S_AXI_RDATA[31:16+LGFIFO+1] == 0);
			assert(S_AXI_RDATA[16+: LGFIFO+1]==$past(wfifo_fill));
			assert(S_AXI_RDATA[15] == $past(rfifo_last));
			if (LGFIFO &lt; 15)
				assert(S_AXI_RDATA[14:LGFIFO+1] == 0);
			assert(S_AXI_RDATA[ 0+: LGFIFO+1]==$past(rfifo_fill));
			end
		default: begin end
		endcase
	end

	</span><span class="tlx_comments">//
	// Check that our low-power only logic works by verifying that anytime
	// S_AXI_RVALID is inactive, then the outgoing data is also zero.
	//
	</span><span class="tlx_untouched">always @(*)
	if (OPT_LOWPOWER &amp;&amp; !S_AXI_RVALID)
		assert(S_AXI_RDATA == 0);

	</span><span class="tlx_comments">// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// The AXI-stream interfaces
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{

	// Slave/consumer properties
	</span><span class="tlx_untouched">always @(posedge S_AXI_ACLK)
	if (!f_past_valid || !$past(S_AXI_ARESETN))
	begin
		assume(!S_AXIS_TVALID);
	end else if ($past(S_AXIS_TVALID &amp;&amp; !S_AXIS_TREADY))
	begin
		assume(S_AXIS_TVALID);
		assume($stable(S_AXIS_TDATA));
		assume($stable(S_AXIS_TLAST));
	end

	</span><span class="tlx_comments">// Master/producer/source properties
	</span><span class="tlx_untouched">always @(posedge S_AXI_ACLK)
	if (!f_past_valid || !$past(S_AXI_ARESETN))
	begin
		assert(!M_AXIS_TVALID);
	end else if ($past(M_AXIS_TVALID &amp;&amp; !M_AXIS_TREADY))
	begin
		assert(M_AXIS_TVALID);
		assert($stable(M_AXIS_TDATA));
		assert($stable(M_AXIS_TLAST));
	end
	</span><span class="tlx_comments">// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Cover checks
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{

	</span><span class="tlx_untouched">always @(*)
		cover(S_AXI_ARESETN &amp;&amp; writes_completed == 16);

	always @(*)
		cover(S_AXI_ARESETN &amp;&amp; reads_completed == 16);

	always @(*)
		cover(S_AXI_ARESETN &amp;&amp; writes_completed == 16
				&amp;&amp; reads_completed == 16);

	always @(*)
		cover(S_AXI_BVALID &amp;&amp; S_AXI_BRESP != 2'b00);

	always @(*)
		cover(S_AXI_RVALID &amp;&amp; S_AXI_RRESP != 2'b00);

	</span><span class="tlx_comments">// }}}
	// }}}
</span><span class="tlx_untouched">`endif
endmodule
  </span><span class="tlx_comments">// =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
</span><span class="tlx_structure">\TLV
   |axil
      
      </span><span class="tlx_staging">@0
         </span><span class="tlx_logic">parameter C_AXI_ADDR_WIDTH = 4;
         localparam C_AXI_DATA_WIDTH = 32;
         parameter C_AXIS_DATA_WIDTH = 16;
         $reset = *reset;
         $S_AXI_AWVALID = *S_AXI_AWVALID;
         $S_AXI_AWREADY = *S_AXI_AWREADY;
         $S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:0] = *S_AXI_AWADDR;
         
         $S_AXI_WVALID = *S_AXI_WVALID;
         $S_AXI_WREADY = *S_AXI_WREADY;
         
      </span><span class="tlx_staging">@5
         </span><span class="tlx_logic">*S_AXI_AWVALID = $S_AXI_AWVALID;
         *S_AXI_AWADDR = $S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:0];
         
         *S_AXI_AWREADY = $S_AXI_AWREADY;
         *S_AXI_WVALID = $S_AXI_WVALID;
         *S_AXI_WREADY = $S_AXI_WREADY;
         
         
         
         
         
         
         
       
         

   </span><span class="tlx_comments">//...

   // Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">*passed = *cyc_cnt &gt; 40;
   *failed = 1'b0;
</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV

 ////////////////////////////////////////////////////////////////////////////////
//
// Filename: 	axil2axis
// {{{
// Project:	WB2AXIPSP: bus bridges and other odds and ends
//
// Purpose:	Demonstrates a simple AXI-Lite interface to drive an AXI-Stream
//		channel.  This can then be used to debug DSP processing.
//
// Registers:	This AXI-lite to AXI-Stream core supports four word-sized
//		addresses.  Byte enables are ignored.
//
//   2'b00, ADDR_SINK
//		Writes to this register will send data to the stream master,
//		with TLAST clear.  Data goes first through a FIFO.  If the
//		FIFO is full, the write will stall.  If it stalls OPT_TIMEOUT
//		cycles, the write will fail and return a bus error.
//
//		Reads from this register will return data from the stream slave,
//		but without consuming it.  Values read here may still be read
//		from the ADDR_SOURCE register later.
//
//   2'b01, ADDR_SOURCE
//		Writes to this register will send data downstream to the stream
//		master as well, but this time with TLAST set.
//
//		Reads from this register will accept a value from the stream
//		slave interface.  The read value contains TDATA.  TLAST is
//		ignored in this read.  If you want access to TLAST, you can get
//		it from the ADDR_FIFO register.
//
//		If there is no data to be read, the read will not and does not
//		stall.  It will instead return a bus error.
//
//   2'b10, ADDR_STATS
//		Since we can, we'll handle some statistics  here.  The top half
//		word contains two counters: a 4-bit counter of TLAST's issued
//		from the stream master, and a 12-bit counter of TDATA values
//		issued.  Neither counter includes data still contained in the
//		FIFO.  If the OPT_SOURCE option is clear, these values will
//		always be zero.
//
//		The second (bottom, or least-significant) halfword contains the
//		same regarding the stream slave.  If OPT_SINK is set, these
//		counters count values read from the core.  If OPT_SINK is clear,
//		so that the stream sink is not truly implemented, then TREADY
//		will be held high and the counter will just count values coming
//		into the core never going into the FIFO.
//
//   2'b11, ADDR_FIFO
//		Working with the core can be a challenge.  You want to make
//		certain that writing to the core  doesn't hang the design, and
//		that reading from the core doesn't cause a bus error.
//
//		Bits 31:16 contain the number of items in the write FIFO, and
//		bits 14:0 contain the number of items in the read FIFO.
//
//		Bit 15 contains whether or not the next item to be read is
//		the last item in a packet, i.e. with TLAST set.
//		
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2020, Gisselquist Technology, LLC
// {{{
//
// This file is part of the WB2AXIP project.
//
// The WB2AXIP project contains free software and gateware, licensed under the
// Apache License, Version 2.0 (the &quot;License&quot;).  You may not use this project,
// or this file, except in compliance with the License.  You may obtain a copy
// of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.
//
////////////////////////////////////////////////////////////////////////////////
// }}}
//
</span><span class="tlx_untouched">`default_nettype none
</span><span class="tlx_comments">//
</span><span class="tlx_untouched">module	axil2axis #(
		</span><span class="tlx_comments">// {{{
		//
		// Size of the AXI-lite bus.  These are fixed, since 1) AXI-lite
		// is fixed at a width of 32-bits by Xilinx def'n, and 2) since
		// we only ever have 4 configuration words.
		</span><span class="tlx_untouched">parameter	C_AXI_ADDR_WIDTH = 4,
		localparam	C_AXI_DATA_WIDTH = 32,
		parameter	C_AXIS_DATA_WIDTH = 16,
		</span><span class="tlx_comments">//
		// OPT_SOURCE enables the AXI stream master logic.  If not
		// enabled, M_AXI_TVALID will be held at zero, and the stream
		// master logic may be ignored.
		</span><span class="tlx_untouched">parameter [0:0] OPT_SOURCE = 1'b1,
		</span><span class="tlx_comments">//
		// OPT_SINK enables the AXI stream slave logic.  If not enabled,
		// reads will always return zero, and S_AXIS_TREADY will be
		// held high.
		</span><span class="tlx_untouched">parameter [0:0] OPT_SINK = 1'b1,
		</span><span class="tlx_comments">//
		// If OPT_SIGN_EXTEND is set, values received will be sign
		// extended to fill the full data width on read.  Otherwise
		// the most significant of any unused bits will remain clear.
		</span><span class="tlx_untouched">parameter [0:0] OPT_SIGN_EXTEND = 1'b0,
		</span><span class="tlx_comments">//
		// Data written to this core will be placed into a FIFO before
		// entering the AXI stream master.  LGFIFO is the log, based
		// two, of the number of words in this FIFO.  Similarly, data
		// consumed by AXI stream slave contained in this core will go
		// first into a read FIFO.  Reads from the core will then return
		// data from this FIFO, or a bus error if none is available.
		</span><span class="tlx_untouched">parameter 	LGFIFO = 5,
		</span><span class="tlx_comments">//
		// OPT_TIMEOUT, if non-zero, will allow writes to the stream
		// master, or reads from the stream slave, to stall the core
		// for OPT_TIMEOUT cycles for the stream to be ready.  If the
		// stream isn't ready at this time (i.e. if the write FIFO is
		// still full, or the read FIFO still empty), the result will
		// be returned as a bus error.  Likewise, if OPT_TIMEOUT==0,
		// the core will always return a bus error if ever the write
		// FIFO is full or the read FIFO empty.
		</span><span class="tlx_untouched">parameter	OPT_TIMEOUT = 5,
		</span><span class="tlx_comments">//
		// OPT_LOWPOWER sets outputs to zero if not valid.  This applies
		// to the AXI-lite bus, however, and not the AXI stream FIFOs,
		// since those don't have LOWPOWER support (currently).
		</span><span class="tlx_untouched">parameter [0:0]	OPT_LOWPOWER = 0,
		</span><span class="tlx_comments">//
		// This design currently ignores WSTRB, beyond checking that it
		// is not zero.  I see no easy way to add it.  (I'll leave that
		// to you to implement, if you wish.)
		// parameter [0:0]	OPT_WSTRB = 0,
		//
		</span><span class="tlx_untouched">localparam	ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3
		</span><span class="tlx_comments">// }}}
	</span><span class="tlx_untouched">) (
		</span><span class="tlx_comments">// {{{
		</span><span class="tlx_untouched">input	wire					S_AXI_ACLK,
		input	wire					S_AXI_ARESETN,
		</span><span class="tlx_comments">// AXI-lite signals
		// {{{
		</span><span class="tlx_untouched">input	wire					S_AXI_AWVALID,
		output	wire					S_AXI_AWREADY,
		input	wire	[C_AXI_ADDR_WIDTH-1:0]		S_AXI_AWADDR,
		input	wire	[2:0]				S_AXI_AWPROT,
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">input	wire					S_AXI_WVALID,
		output	wire					S_AXI_WREADY,
		input	wire	[C_AXI_DATA_WIDTH-1:0]		S_AXI_WDATA,
		input	wire	[C_AXI_DATA_WIDTH/8-1:0]	S_AXI_WSTRB,
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">output	wire					S_AXI_BVALID,
		input	wire					S_AXI_BREADY,
		output	wire	[1:0]				S_AXI_BRESP,
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">input	wire					S_AXI_ARVALID,
		output	wire					S_AXI_ARREADY,
		input	wire	[C_AXI_ADDR_WIDTH-1:0]		S_AXI_ARADDR,
		input	wire	[2:0]				S_AXI_ARPROT,
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">output	wire					S_AXI_RVALID,
		input	wire					S_AXI_RREADY,
		output	wire	[C_AXI_DATA_WIDTH-1:0]		S_AXI_RDATA,
		output	wire	[1:0]				S_AXI_RRESP,
		</span><span class="tlx_comments">// }}}
		// AXI stream slave (sink) signals
		// {{{
		</span><span class="tlx_untouched">input	wire				S_AXIS_TVALID,
		output	reg				S_AXIS_TREADY,
		input	wire	[C_AXIS_DATA_WIDTH-1:0]	S_AXIS_TDATA,
		input	wire				S_AXIS_TLAST,
		</span><span class="tlx_comments">// }}}
		// AXI stream master (source) signals
		// {{{
		</span><span class="tlx_untouched">output	reg				M_AXIS_TVALID,
		input	wire				M_AXIS_TREADY,
		output	reg	[C_AXIS_DATA_WIDTH-1:0]	M_AXIS_TDATA,
		output	reg				M_AXIS_TLAST
		</span><span class="tlx_comments">// }}}
		// }}}
	</span><span class="tlx_untouched">);

	localparam	[1:0]	ADDR_SINK = 2'b00,	</span><span class="tlx_comments">// Read from stream
				</span><span class="tlx_untouched">ADDR_SOURCE = 2'b01, </span><span class="tlx_comments">// Write, also sets TLAST
				</span><span class="tlx_untouched">ADDR_STATS  = 2'b10,
				ADDR_FIFO   = 2'b11;
	localparam	SW = C_AXIS_DATA_WIDTH;

	</span><span class="tlx_comments">////////////////////////////////////////////////////////////////////////
	//
	// Register/wire signal declarations
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	</span><span class="tlx_untouched">wire	i_reset = !S_AXI_ARESETN;

	wire				axil_write_ready;
	wire	[C_AXI_ADDR_WIDTH-ADDRLSB-1:0]	awskd_addr;
	</span><span class="tlx_comments">//
	</span><span class="tlx_untouched">wire	[C_AXI_DATA_WIDTH-1:0]	wskd_data;
	wire [C_AXI_DATA_WIDTH/8-1:0]	wskd_strb;
	reg				axil_bvalid, axil_berr;
	</span><span class="tlx_comments">//
	</span><span class="tlx_untouched">wire				axil_read_ready;
	wire	[C_AXI_ADDR_WIDTH-ADDRLSB-1:0]	arskd_addr;
	reg	[C_AXI_DATA_WIDTH-1:0]	axil_read_data;
	reg				axil_read_valid;

	wire			awskd_valid, wskd_valid;
	wire			wfifo_full, wfifo_write, wfifo_empty;
	wire	[LGFIFO:0]	wfifo_fill;
	reg			write_timeout;

	reg			read_timeout;
	reg			axil_rerr;
	reg	[3:0]		read_bursts_completed;
	reg	[11:0]		reads_completed;

	reg	[3:0]	write_bursts_completed;
	reg	[11:0]	writes_completed;


	</span><span class="tlx_comments">// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// AXI-lite signaling
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{

	//
	// Write signaling
	//
	// {{{
	</span><span class="tlx_untouched">skidbuffer #(.OPT_OUTREG(0),
			.OPT_LOWPOWER(OPT_LOWPOWER),
			.DW(C_AXI_ADDR_WIDTH-ADDRLSB))
	axilawskid(</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_clk(S_AXI_ACLK), .i_reset(i_reset),
		.i_valid(S_AXI_AWVALID), .o_ready(S_AXI_AWREADY),
		.i_data(S_AXI_AWADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]),
		.o_valid(awskd_valid), .i_ready(axil_write_ready),
		.o_data(awskd_addr));

	skidbuffer #(.OPT_OUTREG(0),
			.OPT_LOWPOWER(OPT_LOWPOWER),
			.DW(C_AXI_DATA_WIDTH+C_AXI_DATA_WIDTH/8))
	axilwskid(</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_clk(S_AXI_ACLK), .i_reset(i_reset),
		.i_valid(S_AXI_WVALID), .o_ready(S_AXI_WREADY),
		.i_data({ S_AXI_WDATA, S_AXI_WSTRB }),
		.o_valid(wskd_valid), .i_ready(axil_write_ready),
		.o_data({ wskd_data, wskd_strb }));

	assign	axil_write_ready = awskd_valid &amp;&amp; wskd_valid
			&amp;&amp; (!S_AXI_BVALID || S_AXI_BREADY)
			&amp;&amp; ((awskd_addr[1] != ADDR_SOURCE[1])
				|| (!wfifo_full || write_timeout));

	</span><span class="tlx_comments">//
	// Write timeout generation
	//
	// {{{
	</span><span class="tlx_untouched">generate if ((OPT_TIMEOUT &gt; 1) &amp;&amp; OPT_SOURCE)
	begin

		reg [$clog2(OPT_TIMEOUT)-1:0] write_timer;

		initial	write_timer = OPT_TIMEOUT-1;
		initial	write_timeout = 0;
		always @(posedge S_AXI_ACLK)
		if (!S_AXI_ARESETN)
		begin
			write_timer &lt;= OPT_TIMEOUT-1;
			write_timeout&lt;= 1'b0;
		end else if (!awskd_valid || !wfifo_full || !wskd_valid
				|| (awskd_addr[1] != ADDR_SOURCE[1])
				|| (S_AXI_BVALID &amp;&amp; !S_AXI_BREADY))
		begin
			write_timer &lt;= OPT_TIMEOUT-1;
			write_timeout&lt;= 1'b0;
		end else begin
			if (write_timer &gt; 0)
				write_timer &lt;= write_timer - 1;
			write_timeout &lt;= (write_timer &lt;= 1);
		end

`ifdef	FORMAL
		always @(*)
			assert(write_timer &lt;= OPT_TIMEOUT-1);
		always @(*)
			assert(write_timeout == (write_timer == 0));
`endif
	end else begin

		always @(*)
			write_timeout&lt;= 1'b1;

	end endgenerate
	</span><span class="tlx_comments">// }}}
	

	</span><span class="tlx_untouched">initial	axil_bvalid = 0;
	always @(posedge S_AXI_ACLK)
	if (i_reset)
		axil_bvalid &lt;= 0;
	else if (axil_write_ready)
		axil_bvalid &lt;= 1;
	else if (S_AXI_BREADY)
		axil_bvalid &lt;= 0;

	assign	S_AXI_BVALID = axil_bvalid;

	initial	axil_berr = 0;
	always @(posedge S_AXI_ACLK)
	if (OPT_LOWPOWER &amp;&amp; i_reset)
		axil_berr &lt;= 0;
	else if (axil_write_ready)
		axil_berr &lt;= (wfifo_full)&amp;&amp;(awskd_addr[1]==ADDR_SOURCE[1]);
	else if (OPT_LOWPOWER &amp;&amp; S_AXI_BREADY)
		axil_berr &lt;= 1'b0;

	assign	S_AXI_BRESP = { axil_berr, 1'b0 };
	</span><span class="tlx_comments">// }}}

	//
	// AXI-stream source (Write) FIFO
	//
	// {{{
	</span><span class="tlx_untouched">assign	wfifo_write = axil_write_ready &amp;&amp; awskd_addr[1]==ADDR_SOURCE[1]
			&amp;&amp; wskd_strb != 0 &amp;&amp; !wfifo_full;

	generate if (OPT_SOURCE)
	begin

		sfifo #(.BW(SW+1), .LGFLEN(LGFIFO))
		source(.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),
			.i_wr(wfifo_write),
			.i_data({awskd_addr[0]==ADDR_SOURCE[0],
					wskd_data[SW-1:0]}),
			.o_full(wfifo_full), .o_fill(wfifo_fill),
			.i_rd(M_AXIS_TREADY),
				.o_data({ M_AXIS_TLAST, M_AXIS_TDATA }),
				.o_empty(wfifo_empty));

		always @(*)
			M_AXIS_TVALID = !wfifo_empty;

	end else begin

		always @(*)
		begin
			M_AXIS_TVALID = 1'b0;
			M_AXIS_TDATA  = 0;
			M_AXIS_TLAST  = 0;
		end

		assign	wfifo_full = 1'b0;
		assign	wfifo_fill = 0;

	end endgenerate
	</span><span class="tlx_comments">// }}}

	//
	// AXI-stream consumer/sink (Read) FIFO
	//
	// {{{
	</span><span class="tlx_untouched">wire			rfifo_empty, rfifo_full, rfifo_last, read_rfifo;
	wire	[LGFIFO:0]	rfifo_fill;
	wire	[SW-1:0]	rfifo_data;

	generate if (OPT_SINK)
	begin

		sfifo #(.BW(SW+1), .LGFLEN(LGFIFO))
		sink(.i_clk(S_AXI_ACLK), .i_reset(!S_AXI_ARESETN),
			.i_wr(S_AXIS_TVALID &amp;&amp; S_AXIS_TREADY),
			.i_data({S_AXIS_TLAST, S_AXIS_TDATA}),
			.o_full(rfifo_full), .o_fill(rfifo_fill),
			.i_rd(read_rfifo),
				.o_data({ rfifo_last, rfifo_data }),
				.o_empty(rfifo_empty));

		always @(*)
			S_AXIS_TREADY = !rfifo_full;
		assign	read_rfifo =(axil_read_ready &amp;&amp; arskd_addr== ADDR_SINK)
				&amp;&amp; !rfifo_empty;

	end else begin

		always @(*)
			S_AXIS_TREADY = 1'b1;

		assign rfifo_empty = 1'b1;
		assign rfifo_data  = 0;
		assign rfifo_last  = 1'b1;
		assign rfifo_fill  = 0;

	end endgenerate
	</span><span class="tlx_comments">// }}}

	//
	// Read timeout generation
	//
	// {{{
	</span><span class="tlx_untouched">generate if (OPT_SINK &amp;&amp; OPT_TIMEOUT &gt; 1)
	begin
		reg [$clog2(OPT_TIMEOUT)-1:0] read_timer;

		initial	read_timer = OPT_TIMEOUT-1;
		initial	read_timeout = 1'b0;
		always @(posedge S_AXI_ACLK)
		if (!S_AXI_ARESETN)
		begin
			read_timer &lt;= OPT_TIMEOUT-1;
			read_timeout&lt;= 1'b0;
		end else if (!arskd_valid || (S_AXI_RVALID &amp;&amp; !S_AXI_RREADY)
				||!rfifo_empty
				||(arskd_addr[1] != ADDR_SINK[1]))
		begin
			read_timer &lt;= OPT_TIMEOUT-1;
			read_timeout&lt;= 1'b0;
		end else begin
			if (read_timer &gt; 0)
				read_timer &lt;= read_timer - 1;
			read_timeout &lt;= (read_timer &lt;= 1);
		end

`ifdef	FORMAL
		always @(*)
			assert(read_timer &lt;= OPT_TIMEOUT-1);
		always @(*)
			assert(read_timeout == (read_timer == 0));
`endif
	end else begin

		always @(*)
			read_timeout = 1'b1;

	end endgenerate
	</span><span class="tlx_comments">// }}}

	//
	// Read signaling
	//
	// {{{
	</span><span class="tlx_untouched">wire	arskd_valid;

	skidbuffer #(.OPT_OUTREG(0),
			.OPT_LOWPOWER(OPT_LOWPOWER),
			.DW(C_AXI_ADDR_WIDTH-ADDRLSB))
	axilarskid(</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_clk(S_AXI_ACLK), .i_reset(i_reset),
		.i_valid(S_AXI_ARVALID), .o_ready(S_AXI_ARREADY),
		.i_data(S_AXI_ARADDR[C_AXI_ADDR_WIDTH-1:ADDRLSB]),
		.o_valid(arskd_valid), .i_ready(axil_read_ready),
		.o_data(arskd_addr));

	assign	axil_read_ready = arskd_valid
			&amp;&amp; (!S_AXI_RVALID || S_AXI_RREADY)
			&amp;&amp; ((arskd_addr[1] != ADDR_SINK[1])
				|| (!rfifo_empty || read_timeout));

	initial	axil_read_valid = 1'b0;
	always @(posedge S_AXI_ACLK)
	if (i_reset)
		axil_read_valid &lt;= 1'b0;
	else if (axil_read_ready)
		axil_read_valid &lt;= 1'b1;
	else if (S_AXI_RREADY)
		axil_read_valid &lt;= 1'b0;

	assign	S_AXI_RVALID = axil_read_valid;

	always @(posedge S_AXI_ACLK)
	if (OPT_LOWPOWER &amp;&amp; !S_AXI_ARESETN)
		axil_rerr &lt;= 1'b0;
	else if (axil_read_ready)
		axil_rerr &lt;= rfifo_empty &amp;&amp; (arskd_addr[1] == ADDR_SINK[1]);
	else if (OPT_LOWPOWER &amp;&amp; S_AXI_RREADY)
		axil_rerr &lt;= 1'b0;

	assign	S_AXI_RRESP = { axil_rerr, 1'b0 };
	</span><span class="tlx_comments">// }}}

	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// AXI-lite register logic
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{


	//
	// Read data counting
	// {{{
	</span><span class="tlx_untouched">initial	reads_completed = 0;
	initial	read_bursts_completed = 0;
	always @(posedge S_AXI_ACLK)
	if (!S_AXI_ARESETN)
	begin
		reads_completed &lt;= 0;
		read_bursts_completed &lt;= 0;
	end else if (!OPT_SINK)
	begin
		reads_completed &lt;= reads_completed + (S_AXIS_TVALID ? 1:0);
		read_bursts_completed &lt;= read_bursts_completed
				+ ((S_AXIS_TVALID &amp;&amp; S_AXIS_TLAST) ? 1:0);
	end else if (read_rfifo &amp;&amp; !rfifo_empty)
	begin
		reads_completed &lt;= reads_completed + 1;
		read_bursts_completed &lt;= read_bursts_completed + (rfifo_last ? 1:0);
	end
	</span><span class="tlx_comments">// }}}

	//
	// Write data counting
	// {{{
	</span><span class="tlx_untouched">generate if (OPT_SOURCE)
	begin

		initial	writes_completed = 0;
		initial	write_bursts_completed = 0;
		always @(posedge S_AXI_ACLK)
		if (!S_AXI_ARESETN)
		begin
			writes_completed &lt;= 0;
			write_bursts_completed &lt;= 0;
		end else if (M_AXIS_TVALID &amp;&amp; M_AXIS_TREADY)
		begin
			writes_completed &lt;= writes_completed + 1;
			write_bursts_completed &lt;= write_bursts_completed
					+ (M_AXIS_TLAST ? 1:0);
		end

	end else begin

		always @(*)
		begin
			writes_completed = 0;
			write_bursts_completed = 0;
		end

	end endgenerate
	</span><span class="tlx_comments">// }}}

	//
	// Read data register
	// {{{
	</span><span class="tlx_untouched">initial	axil_read_data = 0;
	always @(posedge S_AXI_ACLK)
	if (OPT_LOWPOWER &amp;&amp; !S_AXI_ARESETN)
		axil_read_data &lt;= 0;
	else if (!S_AXI_RVALID || S_AXI_RREADY)
	begin
		axil_read_data &lt;= 0;
		casez(arskd_addr)
		{ ADDR_SINK[1], 1'b? }:	begin
			if (OPT_SIGN_EXTEND &amp;&amp; rfifo_data[SW-1])
				axil_read_data &lt;= -1;
			axil_read_data[SW-1:0] &lt;= rfifo_data;
			end
		ADDR_STATS: begin
			axil_read_data[31:28] &lt;= write_bursts_completed;
			axil_read_data[27:16] &lt;= writes_completed;
			axil_read_data[15:12] &lt;= read_bursts_completed;
			axil_read_data[11:0]  &lt;= reads_completed;
			end
		ADDR_FIFO:	begin
			</span><span class="tlx_comments">// FIFO information
			</span><span class="tlx_untouched">axil_read_data[16 +: LGFIFO+1] &lt;= wfifo_fill;
			axil_read_data[15] &lt;= rfifo_last;
			axil_read_data[LGFIFO:0] &lt;= rfifo_fill;
			end
		endcase

		if (OPT_LOWPOWER &amp;&amp; !axil_read_ready)
			axil_read_data &lt;= 0;
	end

	assign	S_AXI_RDATA  = axil_read_data;
	</span><span class="tlx_comments">// }}}

	// Verilator lint_off UNUSED
	</span><span class="tlx_untouched">wire	unused;
	assign	unused = &amp;{ 1'b0, S_AXI_AWPROT, S_AXI_ARPROT,
			S_AXI_ARADDR[ADDRLSB-1:0],
			S_AXI_AWADDR[ADDRLSB-1:0],
			wskd_data[C_AXI_DATA_WIDTH-1:SW] };
	</span><span class="tlx_comments">// Verilator lint_on  UNUSED
	// }}}
</span><span class="tlx_untouched">`ifdef	FORMAL
	</span><span class="tlx_comments">////////////////////////////////////////////////////////////////////////
	//
	// Formal properties used in verfiying this core
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	// {{{
	</span><span class="tlx_untouched">reg	f_past_valid;
	initial	f_past_valid = 0;
	always @(posedge S_AXI_ACLK)
		f_past_valid &lt;= 1;

	always @(*)
	if (!f_past_valid)
		assume(!S_AXI_ARESETN);
	</span><span class="tlx_comments">// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// The AXI-lite control interface
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	</span><span class="tlx_untouched">localparam	F_AXIL_LGDEPTH = 4;
	wire	[F_AXIL_LGDEPTH-1:0]	faxil_rd_outstanding,
					faxil_wr_outstanding,
					faxil_awr_outstanding;

	faxil_slave #(
		</span><span class="tlx_comments">// {{{
		</span><span class="tlx_untouched">.C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH),
		.C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH),
		.F_LGDEPTH(F_AXIL_LGDEPTH),
		.F_AXI_MAXWAIT(OPT_TIMEOUT + 2),
		.F_AXI_MAXDELAY(OPT_TIMEOUT + 2),
		.F_AXI_MAXRSTALL(2),
		.F_OPT_COVER_BURST(4)
		</span><span class="tlx_comments">// }}}
	</span><span class="tlx_untouched">) faxil(
		</span><span class="tlx_comments">// {{{
		</span><span class="tlx_untouched">.i_clk(S_AXI_ACLK), .i_axi_reset_n(S_AXI_ARESETN),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_awvalid(S_AXI_AWVALID),
		.i_axi_awready(S_AXI_AWREADY),
		.i_axi_awaddr( S_AXI_AWADDR),
		.i_axi_awcache(4'h0),
		.i_axi_awprot( S_AXI_AWPROT),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_wvalid(S_AXI_WVALID),
		.i_axi_wready(S_AXI_WREADY),
		.i_axi_wdata( S_AXI_WDATA),
		.i_axi_wstrb( S_AXI_WSTRB),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_bvalid(S_AXI_BVALID),
		.i_axi_bready(S_AXI_BREADY),
		.i_axi_bresp( S_AXI_BRESP),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_arvalid(S_AXI_ARVALID),
		.i_axi_arready(S_AXI_ARREADY),
		.i_axi_araddr( S_AXI_ARADDR),
		.i_axi_arcache(4'h0),
		.i_axi_arprot( S_AXI_ARPROT),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.i_axi_rvalid(S_AXI_RVALID),
		.i_axi_rready(S_AXI_RREADY),
		.i_axi_rdata( S_AXI_RDATA),
		.i_axi_rresp( S_AXI_RRESP),
		</span><span class="tlx_comments">//
		</span><span class="tlx_untouched">.f_axi_rd_outstanding(faxil_rd_outstanding),
		.f_axi_wr_outstanding(faxil_wr_outstanding),
		.f_axi_awr_outstanding(faxil_awr_outstanding)
		</span><span class="tlx_comments">// }}}
		</span><span class="tlx_untouched">);

	always @(*)
	begin
		assert(faxil_awr_outstanding== (S_AXI_BVALID ? 1:0)
			+(S_AXI_AWREADY ? 0:1));

		assert(faxil_wr_outstanding == (S_AXI_BVALID ? 1:0)
			+(S_AXI_WREADY ? 0:1));

		assert(faxil_rd_outstanding == (S_AXI_RVALID ? 1:0)
			+(S_AXI_ARREADY ? 0:1));
	end
	</span><span class="tlx_comments">// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// Verifying the packet counters
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	</span><span class="tlx_untouched">reg	[11:0]	f_reads, f_writes;
	reg	[3:0]	f_read_pkts, f_write_pkts;

	</span><span class="tlx_comments">//
	// Mirror the read counter
	//
	</span><span class="tlx_untouched">initial	f_reads      = 0;
	initial	f_read_pkts  = 0;

	always @(posedge S_AXI_ACLK)
	if (!S_AXI_ARESETN)
	begin
		f_reads &lt;= 0;
		f_read_pkts &lt;= 0;
	end else if (OPT_SINK &amp;&amp; (axil_read_ready
			&amp;&amp; arskd_addr == ADDR_SINK &amp;&amp; !rfifo_empty))
	begin
		f_reads &lt;= f_reads + 1;
		f_read_pkts &lt;= f_read_pkts + (rfifo_last ? 1:0);
	end else if (!OPT_SINK &amp;&amp; S_AXIS_TVALID)
	begin
		f_reads &lt;= f_reads + 1;
		f_read_pkts &lt;= f_read_pkts + (S_AXIS_TLAST ? 1:0);
	end

	always @(*)
		assert(f_reads == reads_completed);
	always @(*)
		assert(f_read_pkts == read_bursts_completed);

	always @(*)
	if (!OPT_SINK)
		assert(S_AXIS_TREADY);

	</span><span class="tlx_comments">//
	// Mirror the write counter
	//
	</span><span class="tlx_untouched">initial	f_writes     = 0;
	initial	f_write_pkts = 0;
	always @(posedge S_AXI_ACLK)
	if (!S_AXI_ARESETN)
	begin
		f_writes &lt;= 0;
		f_write_pkts &lt;= 0;
	end else if (OPT_SOURCE &amp;&amp; M_AXIS_TVALID &amp;&amp; M_AXIS_TREADY)
	begin
		f_writes &lt;= f_writes + 1;
		f_write_pkts &lt;= f_write_pkts + (M_AXIS_TLAST ? 1:0);
	end

	always @(*)
	if (!OPT_SOURCE)
	begin
		assert(f_writes == 0);
		assert(f_write_pkts == 0);
	end

	always @(*)
	begin
		assert(f_writes == writes_completed);
		assert(f_write_pkts == write_bursts_completed);
	end
	</span><span class="tlx_comments">// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// Verify the read result
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{
	</span><span class="tlx_untouched">always @(posedge S_AXI_ACLK)
	if (f_past_valid &amp;&amp; $past(S_AXI_ARESETN &amp;&amp; axil_read_ready))
	begin
		assert(S_AXI_RVALID);
		case($past(arskd_addr))
		ADDR_SINK: begin
			assert(S_AXI_RDATA[SW-1:0] == $past(rfifo_data));
			if (SW &lt; C_AXI_DATA_WIDTH)
			begin
				if (OPT_SIGN_EXTEND &amp;&amp; $past(rfifo_data[SW-1]))
					assert(&amp;S_AXI_RDATA[C_AXI_DATA_WIDTH-1:SW]);
				else
					assert(S_AXI_RDATA[C_AXI_DATA_WIDTH-1:SW] == 0);
			end end
		</span><span class="tlx_comments">// 1: assert(S_AXI_RDATA == $past(r1));
		</span><span class="tlx_untouched">ADDR_STATS: begin
			assert(S_AXI_RRESP == 2'b00);
			assert(S_AXI_RDATA[31:28]
					== $past(write_bursts_completed));
			assert(S_AXI_RDATA[27:16] == $past(writes_completed));

			assert(S_AXI_RDATA[15:12]
					== $past(read_bursts_completed));
			assert(S_AXI_RDATA[11:0] == $past(reads_completed));
			end
		ADDR_FIFO: begin
			assert(S_AXI_RRESP == 2'b00);
			if (LGFIFO &lt; 16)
				assert(S_AXI_RDATA[31:16+LGFIFO+1] == 0);
			assert(S_AXI_RDATA[16+: LGFIFO+1]==$past(wfifo_fill));
			assert(S_AXI_RDATA[15] == $past(rfifo_last));
			if (LGFIFO &lt; 15)
				assert(S_AXI_RDATA[14:LGFIFO+1] == 0);
			assert(S_AXI_RDATA[ 0+: LGFIFO+1]==$past(rfifo_fill));
			end
		default: begin end
		endcase
	end

	</span><span class="tlx_comments">//
	// Check that our low-power only logic works by verifying that anytime
	// S_AXI_RVALID is inactive, then the outgoing data is also zero.
	//
	</span><span class="tlx_untouched">always @(*)
	if (OPT_LOWPOWER &amp;&amp; !S_AXI_RVALID)
		assert(S_AXI_RDATA == 0);

	</span><span class="tlx_comments">// }}}

	////////////////////////////////////////////////////////////////////////
	//
	// The AXI-stream interfaces
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{

	// Slave/consumer properties
	</span><span class="tlx_untouched">always @(posedge S_AXI_ACLK)
	if (!f_past_valid || !$past(S_AXI_ARESETN))
	begin
		assume(!S_AXIS_TVALID);
	end else if ($past(S_AXIS_TVALID &amp;&amp; !S_AXIS_TREADY))
	begin
		assume(S_AXIS_TVALID);
		assume($stable(S_AXIS_TDATA));
		assume($stable(S_AXIS_TLAST));
	end

	</span><span class="tlx_comments">// Master/producer/source properties
	</span><span class="tlx_untouched">always @(posedge S_AXI_ACLK)
	if (!f_past_valid || !$past(S_AXI_ARESETN))
	begin
		assert(!M_AXIS_TVALID);
	end else if ($past(M_AXIS_TVALID &amp;&amp; !M_AXIS_TREADY))
	begin
		assert(M_AXIS_TVALID);
		assert($stable(M_AXIS_TDATA));
		assert($stable(M_AXIS_TLAST));
	end
	</span><span class="tlx_comments">// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Cover checks
	//
	////////////////////////////////////////////////////////////////////////
	//
	// {{{

	</span><span class="tlx_untouched">always @(*)
		cover(S_AXI_ARESETN &amp;&amp; writes_completed == 16);

	always @(*)
		cover(S_AXI_ARESETN &amp;&amp; reads_completed == 16);

	always @(*)
		cover(S_AXI_ARESETN &amp;&amp; writes_completed == 16
				&amp;&amp; reads_completed == 16);

	always @(*)
		cover(S_AXI_BVALID &amp;&amp; S_AXI_BRESP != 2'b00);

	always @(*)
		cover(S_AXI_RVALID &amp;&amp; S_AXI_RRESP != 2'b00);

	</span><span class="tlx_comments">// }}}
	// }}}
</span><span class="tlx_untouched">`endif
endmodule
  </span><span class="tlx_comments">// =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   //_|axil
      
      //_@0
         </span><span class="tlx_logic">assign parameter C_AXI_ADDR_WIDTH = 4;
         assign localparam C_AXI_DATA_WIDTH = 32;
         assign parameter C_AXIS_DATA_WIDTH = 16;
         assign AXIL_reset_a0 = reset;
         assign AXIL_S_AXI_AWVALID_a0 = S_AXI_AWVALID;
         assign AXIL_S_AXI_AWREADY_a0 = S_AXI_AWREADY;
         assign AXIL_S_AXI_AWADDR_a0[C_AXI_ADDR_WIDTH-1:0] = S_AXI_AWADDR;
         
         assign AXIL_S_AXI_WVALID_a0 = S_AXI_WVALID;
         assign AXIL_S_AXI_WREADY_a0 = S_AXI_WREADY;
         
      </span><span class="tlx_comments">//_@5
         </span><span class="tlx_logic">assign S_AXI_AWVALID = AXIL_S_AXI_AWVALID_a5;
         assign S_AXI_AWADDR = AXIL_S_AXI_AWADDR_a5[C_AXI_ADDR_WIDTH-1:0];
         
         assign S_AXI_AWREADY = AXIL_S_AXI_AWREADY_a5;
         assign S_AXI_WVALID = AXIL_S_AXI_WVALID_a5;
         assign S_AXI_WREADY = AXIL_S_AXI_WREADY_a5;
         
         
         
         
         
         
         
       
         

   </span><span class="tlx_comments">//...

   // Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">assign passed = cyc_cnt &gt; 40;
   assign failed = 1'b0; </span><span class="tlx_structure">endgenerate
</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"


genvar ring_stop;


//
// Signals declared top-level.
//

// For $reset.
logic L0_reset_a0;



generate


   //
   // Scope: /ring_stop[3:0]
   //
   for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1gen_RingStop

      //
      // Scope: |axil
      //

         // For $S_AXI_AWADDR.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a1[C_AXI_ADDR_WIDTH-1:0] <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a0[C_AXI_ADDR_WIDTH-1:0];
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a2[C_AXI_ADDR_WIDTH-1:0] <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a1[C_AXI_ADDR_WIDTH-1:0];
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a3[C_AXI_ADDR_WIDTH-1:0] <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a2[C_AXI_ADDR_WIDTH-1:0];
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a4[C_AXI_ADDR_WIDTH-1:0] <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a3[C_AXI_ADDR_WIDTH-1:0];
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a5[C_AXI_ADDR_WIDTH-1:0] <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a4[C_AXI_ADDR_WIDTH-1:0];

         // For $S_AXI_AWREADY.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a1 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a0;
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a2 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a1;
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a3 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a2;
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a4 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a3;
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a5 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a4;

         // For $S_AXI_AWVALID.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a1 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a0;
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a2 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a1;
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a3 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a2;
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a4 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a3;
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a5 <= L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a4;


   end


endgenerate




//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      //
      // Scope: /ring_stop[3:0]
      //
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : \/ring_stop 

         //
         // Scope: |axil
         //
         if (1) begin : \|axil 
            logic [C_AXI_ADDR_WIDTH-1:0] \@0$S_AXI_AWADDR ;
            assign \@0$S_AXI_AWADDR = L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWADDR_a0;
            logic [2:0] \@0$S_AXI_AWPROT ;
            assign \@0$S_AXI_AWPROT = L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWPROT_a0;
            logic  \@0$S_AXI_AWREADY ;
            assign \@0$S_AXI_AWREADY = L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWREADY_a0;
            logic  \@0$S_AXI_AWVALID ;
            assign \@0$S_AXI_AWVALID = L1_RingStop[ring_stop].L1_AXIL_S_AXI_AWVALID_a0;
         end
      end


   end

endgenerate




generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.

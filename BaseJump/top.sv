`line 2 "top.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
`include "sp_default.vh" //_\SV
/*
Copyright (c) 2018, Steve Hoover
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//m4_include_url(['http://localhost:8080/wip/viz.tlv'])
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// Included URL: "https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/5a8c0387be80b2deccfcd1506299b36049e0663e/fundamentals_lib.tlv"
// Included URL: "https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflow_lib.tlv"

// Include BaseJump STL FIFO files.
/* verilator lint_off CMPCONST */
/* verilator lint_off WIDTH */
`include "./sv_url_inc/bsg_defines.v"  // From: "https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_misc/bsg_defines.v"
`include "./sv_url_inc/bsg_fifo_tracker.v"  // From: "https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_dataflow/bsg_fifo_tracker.v"
`include "./sv_url_inc/bsg_circular_ptr.v"  // From: "https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_misc/bsg_circular_ptr.v"
`include "./sv_url_inc/bsg_fifo_1r1w_small.v"  // From: "https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_dataflow/bsg_fifo_1r1w_small.v"
`include "./sv_url_inc/bsg_mem_1r1w.v"  // From: "https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_mem/bsg_mem_1r1w.v"
`include "./sv_url_inc/bsg_mem_1r1w_synth.v"  // From: "https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_mem/bsg_mem_1r1w_synth.v"
/* verilator lint_on WIDTH */
/* verilator lint_on CMPCONST */


module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */



`include "top_gen.sv" //_\TLV
   assign L0_reset_a0 = reset;
   
   
   // DUT
   
   for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1_RingStop logic L1_BP0_accepted_a1; logic L1_BP0_avail_a1; logic L1_BP0_blocked_a1; logic L1_BP0_reset_a1; logic L1_BP0_reset_in_a1; logic L1_BP0_trans_valid_a1; logic [1:0] L1_BP0_Entry_Accum_Trans_dest_a1 [(4)-1:0]; logic [1:0] L1_BP0_Entry_Accum_Trans_sender_a1 [(4)-1:0]; logic L1_BP0_FifoHead_avail_a1; logic [1:0] L1_BP0_FifoHead_Trans_dest_a1; logic [1:0] L1_BP0_FifoHead_Trans_sender_a1; logic L1_BP0_Head_avail_a1; logic [1:0] L1_BP0_Head_Trans_dest_a1; logic [1:0] L1_BP0_Head_Trans_sender_a1; logic [1:0] L1_BP0_Trans_dest_a1; logic [1:0] L1_BP0_Trans_sender_a1; logic L1_BP1_accepted_a1; logic L1_BP1_avail_a0, L1_BP1_avail_a1; logic L1_BP1_blocked_a1; logic L1_BP1_recirc_a1; logic L1_BP1_reset_a0, L1_BP1_reset_a1; logic L1_BP1_reset_in_a1; logic [1:0] L1_BP1_Trans_dest_a0, L1_BP1_Trans_dest_a1; logic [1:0] L1_BP1_Trans_sender_a0, L1_BP1_Trans_sender_a1; logic L1_BP2_accepted_a1; logic L1_BP2_avail_a0, L1_BP2_avail_a1; logic L1_BP2_blocked_a1; logic L1_BP2_recirc_a1; logic L1_BP2_reset_a0, L1_BP2_reset_a1; logic L1_BP2_reset_in_a1; logic [1:0] L1_BP2_Trans_dest_a0, L1_BP2_Trans_dest_a1; logic [1:0] L1_BP2_Trans_sender_a0, L1_BP2_Trans_sender_a1; logic L1_BP3_accepted_a1; logic L1_BP3_avail_a0, L1_BP3_avail_a1; logic L1_BP3_blocked_a1; logic L1_BP3_local_a1; logic L1_BP3_recirc_a1; logic L1_BP3_reset_a0, L1_BP3_reset_a1; logic L1_BP3_reset_in_a1; logic [1:0] L1_BP3_Trans_dest_a0, L1_BP3_Trans_dest_a1; logic [1:0] L1_BP3_Trans_sender_a0, L1_BP3_Trans_sender_a1; logic L1_BYPASS_avail_a1; logic L1_BYPASS_reset_a1; logic L1_BYPASS_Trans_cyc_cnt_a1; logic [1:0] L1_BYPASS_Trans_sender_a1; logic L1_RING_IN_avail_a1; logic L1_RING_IN_reset_a1; logic L1_RING_IN_Trans_cyc_cnt_a1; logic [1:0] L1_RING_IN_Trans_dest_a1; logic [1:0] L1_RING_IN_Trans_sender_a1; logic L1_STALL0_accepted_a1; logic L1_STALL0_blocked_a1; logic L1_STALL0_reset_in_a1; logic L1_STALL1_accepted_a1; logic L1_STALL1_avail_a1, L1_STALL1_avail_a2; logic L1_STALL1_blocked_a1, L1_STALL1_blocked_a2; logic L1_STALL1_reset_a1; logic L1_STALL1_reset_in_a1; logic [1:0] L1_STALL1_Trans_dest_a1, L1_STALL1_Trans_dest_a2; logic [1:0] L1_STALL1_Trans_sender_a1, L1_STALL1_Trans_sender_a2; logic L1_STALL2_accepted_a1; logic L1_STALL2_avail_a1, L1_STALL2_avail_a2; logic L1_STALL2_blocked_a1, L1_STALL2_blocked_a2; logic L1_STALL2_reset_a1; logic L1_STALL2_reset_in_a1; logic [1:0] L1_STALL2_Trans_dest_a1, L1_STALL2_Trans_dest_a2; logic [1:0] L1_STALL2_Trans_sender_a1, L1_STALL2_Trans_sender_a2; logic L1_STALL3_accepted_a1; logic L1_STALL3_avail_a1, L1_STALL3_avail_a2; logic L1_STALL3_blocked_a1, L1_STALL3_blocked_a2; logic L1_STALL3_bypass_a1; logic L1_STALL3_empty_a2; logic L1_STALL3_full_a2; logic L1_STALL3_grow_a1; logic L1_STALL3_out_blocked_a1; logic L1_STALL3_push_a1; logic L1_STALL3_reset_a1; logic L1_STALL3_reset_in_a1; logic L1_STALL3_shrink_a1; logic L1_STALL3_two_valid_a1, L1_STALL3_two_valid_a2; logic [$clog2((4)+1)-1:0] L1_STALL3_valid_count_a1, L1_STALL3_valid_count_a2; logic L1_STALL3_would_bypass_a1; logic [(4)-1:0] L1_STALL3_Entry_prev_entry_was_tail_a1; logic [(4)-1:0] L1_STALL3_Entry_push_a1; logic [(4)-1:0] L1_STALL3_Entry_reconstructed_is_tail_a2; logic L1_STALL3_Entry_state_a1 [(4)-1:0], L1_STALL3_Entry_state_a2 [(4)-1:0]; logic [1:0] L1_STALL3_Trans_dest_a1, L1_STALL3_Trans_dest_a2; logic [1:0] L1_STALL3_Trans_sender_a1, L1_STALL3_Trans_sender_a2; //_/ring_stop
      `line 512 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+stall_pipeline(/ring_stop, |stall, 0, 3, /trans)
         
         `line 465 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall0, @1'], [' |stall1, @1'], )
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall0, @1'], )
                  // Avail/Blocked Input:
                  //_|stall0
                     //_@1
                        assign L1_STALL0_accepted_a1 = L1e_RingStop[ring_stop].L1_STALL0_avail_a1 && ! L1_STALL0_blocked_a1;  // provided for optional upstream use.
                        assign L1_STALL0_reset_in_a1 = L1e_RingStop[ring_stop].L1_STALL0_reset_a1;
                        `BOGUS_USE(L1_STALL0_accepted_a1 L1_STALL0_reset_in_a1)
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall0, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall1, @1'])
                  // Avail/Blocked Output:
                  //_|stall1
                     //_@1
                        `BOGUS_USE(L1_STALL1_reset_a1) // Output pipes must provide $reset.
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall1, @1))))
                     
                  //_\end_source
                  `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_\end_source
            `line 466 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            
            //_|stall0
               //_@1
                  assign L1_STALL0_blocked_a1 = L1_STALL1_blocked_a1;
            //_|stall1
               //_@1
                  // Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  assign L1_STALL1_reset_a1 = L1_STALL0_reset_in_a1;
                  
                  assign L1_STALL1_avail_a1 = L1_STALL1_reset_a1      ? 1'b0 :
                           L1_STALL1_blocked_a2 ? L1_STALL1_avail_a2 :
                                         L1e_RingStop[ring_stop].L1_STALL0_avail_a2;
                  //_?$avail
                     //_/trans
                        assign {RingStop_STALL1_Trans_cyc_cnt_a1[ring_stop], L1_STALL1_Trans_dest_a1[1:0], L1_STALL1_Trans_sender_a1[1:0]} = L1_STALL1_blocked_a2 ? {RingStop_STALL1_Trans_cyc_cnt_a2[ring_stop], L1_STALL1_Trans_dest_a2, L1_STALL1_Trans_sender_a2} : {RingStop_STALL0_Trans_cyc_cnt_a2[ring_stop], L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a2, L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a2};
            
         //_\end_source
         `line 514 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
         `line 465 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall1, @1'], [' |stall2, @1'], )
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall1, @1'], )
                  // Avail/Blocked Input:
                  //_|stall1
                     //_@1
                        assign L1_STALL1_accepted_a1 = L1_STALL1_avail_a1 && ! L1_STALL1_blocked_a1;  // provided for optional upstream use.
                        assign L1_STALL1_reset_in_a1 = L1_STALL1_reset_a1;
                        `BOGUS_USE(L1_STALL1_accepted_a1 L1_STALL1_reset_in_a1)
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall1, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall2, @1'])
                  // Avail/Blocked Output:
                  //_|stall2
                     //_@1
                        `BOGUS_USE(L1_STALL2_reset_a1) // Output pipes must provide $reset.
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall2, @1))))
                     
                  //_\end_source
                  `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_\end_source
            `line 466 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            
            //_|stall1
               //_@1
                  assign L1_STALL1_blocked_a1 = L1_STALL2_blocked_a1;
            //_|stall2
               //_@1
                  // Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  assign L1_STALL2_reset_a1 = L1_STALL1_reset_in_a1;
                  
                  assign L1_STALL2_avail_a1 = L1_STALL2_reset_a1      ? 1'b0 :
                           L1_STALL2_blocked_a2 ? L1_STALL2_avail_a2 :
                                         L1_STALL1_avail_a2;
                  //_?$avail
                     //_/trans
                        assign {RingStop_STALL2_Trans_cyc_cnt_a1[ring_stop], L1_STALL2_Trans_dest_a1[1:0], L1_STALL2_Trans_sender_a1[1:0]} = L1_STALL2_blocked_a2 ? {RingStop_STALL2_Trans_cyc_cnt_a2[ring_stop], L1_STALL2_Trans_dest_a2, L1_STALL2_Trans_sender_a2} : {RingStop_STALL1_Trans_cyc_cnt_a2[ring_stop], L1_STALL1_Trans_dest_a2, L1_STALL1_Trans_sender_a2};
            
         //_\end_source
         `line 516 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
         `line 465 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall2, @1'], [' |stall3, @1'], )
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall2, @1'], )
                  // Avail/Blocked Input:
                  //_|stall2
                     //_@1
                        assign L1_STALL2_accepted_a1 = L1_STALL2_avail_a1 && ! L1_STALL2_blocked_a1;  // provided for optional upstream use.
                        assign L1_STALL2_reset_in_a1 = L1_STALL2_reset_a1;
                        `BOGUS_USE(L1_STALL2_accepted_a1 L1_STALL2_reset_in_a1)
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall2, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall3, @1'])
                  // Avail/Blocked Output:
                  //_|stall3
                     //_@1
                        `BOGUS_USE(L1_STALL3_reset_a1) // Output pipes must provide $reset.
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall3, @1))))
                     
                  //_\end_source
                  `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_\end_source
            `line 466 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            
            //_|stall2
               //_@1
                  assign L1_STALL2_blocked_a1 = L1_STALL3_blocked_a1;
            //_|stall3
               //_@1
                  // Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  assign L1_STALL3_reset_a1 = L1_STALL2_reset_in_a1;
                  
                  assign L1_STALL3_avail_a1 = L1_STALL3_reset_a1      ? 1'b0 :
                           L1_STALL3_blocked_a2 ? L1_STALL3_avail_a2 :
                                         L1_STALL2_avail_a2;
                  //_?$avail
                     //_/trans
                        assign {RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop], L1_STALL3_Trans_dest_a1[1:0], L1_STALL3_Trans_sender_a1[1:0]} = L1_STALL3_blocked_a2 ? {RingStop_STALL3_Trans_cyc_cnt_a2[ring_stop], L1_STALL3_Trans_dest_a2, L1_STALL3_Trans_sender_a2} : {RingStop_STALL2_Trans_cyc_cnt_a2[ring_stop], L1_STALL2_Trans_dest_a2, L1_STALL2_Trans_sender_a2};
            
         //_\end_source
         `line 518 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
         //
      //_\end_source
      `line 65 "top.tlv" 2
      `line 576 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 65 as: m4+flop_fifo_v2(/ring_stop, |stall3, @1, |bp0, @1, 4, /trans)
         `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 576 as: m4+flow_interface(/ring_stop, [' |stall3, @1'], [' |bp0, @1'], )
            `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall3, @1'], )
               // Avail/Blocked Input:
               //_|stall3
                  //_@1
                     assign L1_STALL3_accepted_a1 = L1_STALL3_avail_a1 && ! L1_STALL3_blocked_a1;  // provided for optional upstream use.
                     assign L1_STALL3_reset_in_a1 = L1_STALL3_reset_a1;
                     `BOGUS_USE(L1_STALL3_accepted_a1 L1_STALL3_reset_in_a1)
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 65 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall3, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp0, @1'])
               // Avail/Blocked Output:
               //_|bp0
                  //_@1
                     `BOGUS_USE(L1_BP0_reset_a1) // Output pipes must provide $reset.
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 65 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp0, @1))))
                  
               //_\end_source
               `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_\end_source
         `line 577 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
         
         
         
         
         //   @0
         /*SV_plus*/
            localparam bit [$clog2((4)+1)-1:0] full_mark_25 = 4 - 0;
         // FIFO Instantiation
         // Hierarchy declarations
         //_|stall3
            //_/entry
         //_|bp0
            //_/entry
         //_|stall3
            //_@1
               assign L1_STALL3_out_blocked_a1 = L1_BP0_blocked_a1;
               assign L1_STALL3_blocked_a1 = L1_STALL3_full_a2 && L1_STALL3_out_blocked_a1;
               `BOGUS_USE(L1_STALL3_blocked_a1)   // Not required to be consumed elsewhere.
               assign L1_STALL3_would_bypass_a1 = L1_STALL3_empty_a2;
               assign L1_STALL3_bypass_a1 = L1_STALL3_would_bypass_a1 && ! L1_STALL3_out_blocked_a1;
               assign L1_STALL3_push_a1 = L1_STALL3_accepted_a1 && ! L1_STALL3_bypass_a1;
               assign L1_STALL3_grow_a1   =   L1_STALL3_accepted_a1 &&   L1_STALL3_out_blocked_a1;
               assign L1_STALL3_shrink_a1 = ! L1_STALL3_avail_a1 && ! L1_STALL3_out_blocked_a1 && ! L1_STALL3_empty_a2;
               assign L1_STALL3_valid_count_a1[$clog2((4)+1)-1:0] = L1_STALL3_reset_a1 ? '0
                                                           : L1_STALL3_valid_count_a2 + (
                                                                L1_STALL3_grow_a1   ? { {($clog2((4)+1)-1){1'b0}}, 1'b1} :
                                                                L1_STALL3_shrink_a1 ? '1
                                                                        : '0
                                                             );
               // At least 2 valid entries.
               //$two_valid = | $ValidCount[m4_counter_width-1:1];
               // but logic depth minimized by taking advantage of prev count >= 4.
               assign L1_STALL3_two_valid_a1 = | L1_STALL3_valid_count_a2[$clog2((4)+1)-1:2] || | L1_STALL3_valid_count_a1[2:1];
               // These are an optimization of the commented block below to operate on vectors, rather than bits.
               // TODO: Keep optimizing...
               assign {L1_STALL3_Entry_prev_entry_was_tail_a1} = {L1_STALL3_Entry_reconstructed_is_tail_a2[2:0], L1_STALL3_Entry_reconstructed_is_tail_a2[3]} /* circular << */;
               assign {L1_STALL3_Entry_push_a1} = {4{L1_STALL3_push_a1}} & L1_STALL3_Entry_prev_entry_was_tail_a1;
               for (entry = 0; entry <= (4)-1; entry++) begin : L2b_STALL3_Entry logic L2_is_tail_a1; logic L2_valid_a1; //_/entry
                  // Replaced with optimized versions above:
                  // $prev_entry_was_tail = /entry[(entry+(m4_depth)-1)%(m4_depth)]>>1$reconstructed_is_tail;
                  // $push = |stall3$push && $prev_entry_was_tail;
                  assign L2_valid_a1 = (L2c_STALL3_Entry[entry].L2_reconstructed_valid_a2 && ! L2b_BP0_Entry[entry].L2_pop_a1) || L1_STALL3_Entry_push_a1[entry];
                  assign L2_is_tail_a1 = L1_STALL3_accepted_a1 ? L1_STALL3_Entry_prev_entry_was_tail_a1[entry]  // shift tail
                                                  : L1_STALL3_Entry_reconstructed_is_tail_a2[entry];  // retain tail
                  assign L1_STALL3_Entry_state_a1[entry] = L1_STALL3_reset_a1 ? 1'b0
                                             : L2_valid_a1 && ! (L1_STALL3_two_valid_a1 && L2_is_tail_a1); end
            //_@2
               assign L1_STALL3_empty_a2 = ! L1_STALL3_two_valid_a2 && ! L1_STALL3_valid_count_a2[0];
               assign L1_STALL3_full_a2 = (L1_STALL3_valid_count_a2 == full_mark_25);  // Could optimize for power-of-two depth.
            for (entry = 0; entry <= (4)-1; entry++) begin : L2c_STALL3_Entry logic L2_is_head_a2; logic L2_next_entry_state_a2; logic L2_prev_entry_state_a2; logic L2_reconstructed_valid_a2; //_/entry
               //_@2
                  assign L2_prev_entry_state_a2 = L1_STALL3_Entry_state_a2[(entry+(4)-1)%(4)];
                  assign L2_next_entry_state_a2 = L1_STALL3_Entry_state_a2[(entry+1)%(4)];
                  assign L1_STALL3_Entry_reconstructed_is_tail_a2[entry] = (  L1_STALL3_two_valid_a2 && (!L1_STALL3_Entry_state_a2[entry] && L2_prev_entry_state_a2)) ||
                                           (! L1_STALL3_two_valid_a2 && (!L2_next_entry_state_a2 && L1_STALL3_Entry_state_a2[entry])) ||
                                           (L1_STALL3_empty_a2 && (entry == 0));  // need a tail when empty for push
                  assign L2_is_head_a2 = L1_STALL3_Entry_state_a2[entry] && ! L2_prev_entry_state_a2;
                  assign L2_reconstructed_valid_a2 = L1_STALL3_Entry_state_a2[entry] || (L1_STALL3_two_valid_a2 && L2_prev_entry_state_a2); end
            // Write data
         //_|stall3
            //_@1
               for (entry = 0; entry <= (4)-1; entry++) begin : L2d_STALL3_Entry logic [1:0] L2_Trans_dest_a1, L2_Trans_dest_a2; logic [1:0] L2_Trans_sender_a1, L2_Trans_sender_a2; //_/entry
                     //?$push
                     //   $aNY = |m4_in_pipe['']m4_trans$ANY;
                  //_/trans
                     assign {RingStop_STALL3_Entry_Trans_cyc_cnt_a1[ring_stop][entry], L2_Trans_dest_a1[1:0], L2_Trans_sender_a1[1:0]} = L1_STALL3_Entry_push_a1[entry] ? {RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop], L1_STALL3_Trans_dest_a1[1:0], L1_STALL3_Trans_sender_a1[1:0]} : {RingStop_STALL3_Entry_Trans_cyc_cnt_a2[ring_stop][entry], L2_Trans_dest_a2[1:0], L2_Trans_sender_a2[1:0]} /* RETAIN */; end
            // Read data
         //_|bp0
            //_@1
                  //$pop  = ! /m4_top|m4_in_pipe>>m4_align(m4_in_at + 1, m4_out_at)$empty && ! $blocked;
               for (entry = 0; entry <= (4)-1; entry++) begin : L2b_BP0_Entry logic L2_is_head_a1; logic L2_pop_a1; logic [1:0] L2_ReadMasked_Trans_dest_a1; logic [1:0] L2_ReadMasked_Trans_sender_a1; //_/entry
                  assign L2_is_head_a1 = L2c_STALL3_Entry[entry].L2_is_head_a2;
                  assign L2_pop_a1  = L2_is_head_a1 && ! L1_BP0_blocked_a1;
                  //_/read_masked
                     //_/trans
                        assign {RingStop_BP0_Entry_ReadMasked_Trans_cyc_cnt_a1[ring_stop][entry], L2_ReadMasked_Trans_dest_a1[1:0], L2_ReadMasked_Trans_sender_a1[1:0]} = L2_is_head_a1 ? {RingStop_STALL3_Entry_Trans_cyc_cnt_a2[ring_stop][entry], L2d_STALL3_Entry[entry].L2_Trans_dest_a2[1:0], L2d_STALL3_Entry[entry].L2_Trans_sender_a2[1:0]} /* $aNY */ : '0;
                  //_/accum
                     //_/trans
                        assign {RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1[ring_stop][entry], L1_BP0_Entry_Accum_Trans_dest_a1[entry][1:0], L1_BP0_Entry_Accum_Trans_sender_a1[entry][1:0]} = ((entry == 0) ? '0 : {RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1[ring_stop][(entry+(4)-1)%(4)], L1_BP0_Entry_Accum_Trans_dest_a1[(entry+(4)-1)%(4)][1:0], L1_BP0_Entry_Accum_Trans_sender_a1[(entry+(4)-1)%(4)][1:0]}) |
                                   {RingStop_BP0_Entry_ReadMasked_Trans_cyc_cnt_a1[ring_stop][entry], L2_ReadMasked_Trans_dest_a1[1:0], L2_ReadMasked_Trans_sender_a1[1:0]}; end
               //_/head
                  assign L1_BP0_Head_avail_a1 = L1_BP0_avail_a1;
                  //_?$avail
                     //_/trans
                        assign {RingStop_BP0_Head_Trans_cyc_cnt_a1[ring_stop], L1_BP0_Head_Trans_dest_a1[1:0], L1_BP0_Head_Trans_sender_a1[1:0]} = {RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1[ring_stop][(4)-1], L1_BP0_Entry_Accum_Trans_dest_a1[(4)-1][1:0], L1_BP0_Entry_Accum_Trans_sender_a1[(4)-1][1:0]};
         // Bypass
         //_|bp0
            //_@1
               // Available output.  Sometimes it's necessary to know what would be coming to determined
               // if it's blocked.  This can be used externally in that case.
               //_/fifo_head
                  assign L1_BP0_FifoHead_avail_a1 = L1_BP0_avail_a1;
                  //_?$avail
                     //_/trans
                        assign {RingStop_BP0_FifoHead_Trans_cyc_cnt_a1[ring_stop], L1_BP0_FifoHead_Trans_dest_a1[1:0], L1_BP0_FifoHead_Trans_sender_a1[1:0]} = L1_STALL3_would_bypass_a1
                                     ? {RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop], L1_STALL3_Trans_dest_a1, L1_STALL3_Trans_sender_a1}
                                     : {RingStop_BP0_Head_Trans_cyc_cnt_a1[ring_stop], L1_BP0_Head_Trans_dest_a1[1:0], L1_BP0_Head_Trans_sender_a1[1:0]};
               assign L1_BP0_avail_a1 = ! L1_STALL3_would_bypass_a1 || L1_STALL3_avail_a1;
               assign L1_BP0_trans_valid_a1 = L1_BP0_avail_a1 && ! L1_BP0_blocked_a1;
               //_?$trans_valid
                  //_/trans
                     assign {RingStop_BP0_Trans_cyc_cnt_a1[ring_stop], L1_BP0_Trans_dest_a1[1:0], L1_BP0_Trans_sender_a1[1:0]} = {RingStop_BP0_FifoHead_Trans_cyc_cnt_a1[ring_stop], L1_BP0_FifoHead_Trans_dest_a1, L1_BP0_FifoHead_Trans_sender_a1};
               
               // Deliver reset.
               assign L1_BP0_reset_a1 = L1_STALL3_reset_in_a1;
      
         
         
         
         
         
         /* Alternate code for pointer indexing.  Replaces $ANY expression above.
      
         // Hierarchy
         |m4_in_pipe
            /entry2[(m4_depth)-1:0]
      
         // Head/Tail ptrs.
         |m4_in_pipe
            @m4_in_at
               >>1$WrPtr[m4_ptr_width-1:0] =
                   $reset       ? '0 :
                   $trans_valid ? ($WrPtr == (m4_depth - 1))
                                    ? '0
                                    : $WrPtr + {{(m4_ptr_width-1){1'b0}}, 1'b1} :
                                  $RETAIN;
         |m4_out_pipe
            @m4_out_at
               >>1$RdPtr[m4_ptr_width-1:0] =
                   /m4_top|m4_in_pipe>>m4_reverse_bypass_align$reset
                                ? '0 :
                   $trans_valid ? ($RdPtr == (m4_depth - 1))
                                    ? '0
                                    : $RdPtr + {{(m4_ptr_width-1){1'b0}}, 1'b1} :
                                  $RETAIN;
         // Write FIFO
         |m4_in_pipe
            @m4_in_at
               $dummy = '0;
               ?$trans_valid
                  // This doesn't work because SV complains for FIFOs in replicated context that
                  // there are multiple procedures that assign the signals.
                  // Array writes can be done in an SV module.
                  // The only long-term resolutions are support for module generation and use
                  // signals declared within for loops with cross-hierarchy references in SV.
                  // TODO: To make a simulation-efficient FIFO, use DesignWare.
                  {/entry2[$WrPtr]$$ANY} = $ANY;
         // Read FIFO
         |m4_out_pipe
            @m4_out_at
               /read2
                  $trans_valid = |m4_out_pipe$trans_valid;
                  ?$trans_valid
                     $ANY = /m4_top|m4_in_pipe/entry2[|m4_out_pipe$RdPtr]>>m4_reverse_bypass_align$ANY;
                  `BOGUS_USE($dummy)
               ?$trans_valid
                  $ANY = /read2$ANY;
         */
      
  
    
    
    
  

      //_\end_source
      `line 66 "top.tlv" 2
      //m4+simple_bypass_fifo_v2(/ring_stop, |stall3, @1, |bp0, @1, 4, 100, /trans)
      `line 417 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+bp_pipeline(/ring_stop, |bp, 0, 3, /trans)
         
         `line 343 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp0, @1'], [' |bp1, @1'], )
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp0, @1'], )
                  // Avail/Blocked Input:
                  //_|bp0
                     //_@1
                        assign L1_BP0_accepted_a1 = L1_BP0_avail_a1 && ! L1_BP0_blocked_a1;  // provided for optional upstream use.
                        assign L1_BP0_reset_in_a1 = L1_BP0_reset_a1;
                        `BOGUS_USE(L1_BP0_accepted_a1 L1_BP0_reset_in_a1)
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp0, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp1, @1'])
                  // Avail/Blocked Output:
                  //_|bp1
                     //_@1
                        `BOGUS_USE(L1_BP1_reset_a1) // Output pipes must provide $reset.
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp1, @1))))
                     
                  //_\end_source
                  `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_\end_source
            `line 350 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_|bp1
               //_@0
                  assign L1_BP1_reset_a0 = L1_BP0_reset_in_a1;
                  
                  assign L1_BP1_avail_a0 = L1_BP1_reset_a0 ? 1'b0 :
                                    (L1_BP1_avail_a1 && L1_BP1_blocked_a1) ||  // Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    L1_BP0_avail_a1; // Incoming available
                  //$first_avail = $avail && ! >>1$blocked;  // Transaction is newly available.
               //_@0
                  //_?$avail  // Physically, $first_avail && *reset_b for functional gating in
                           // place of recirculation.
                     //_/trans
                        assign {RingStop_BP1_Trans_cyc_cnt_a0[ring_stop], L1_BP1_Trans_dest_a0[1:0], L1_BP1_Trans_sender_a0[1:0]} =
                           L1_BP1_recirc_a1 ? {RingStop_BP1_Trans_cyc_cnt_a1[ring_stop], L1_BP1_Trans_dest_a1, L1_BP1_Trans_sender_a1}
                                                : {RingStop_BP0_Trans_cyc_cnt_a1[ring_stop], L1_BP0_Trans_dest_a1, L1_BP0_Trans_sender_a1};
               //_@1
                  assign L1_BP1_recirc_a1 = L1_BP1_avail_a1 && L1_BP1_blocked_a1;  // Available transaction that is blocked; must recirc.
            //_|bp0
               //_@1
                  assign L1_BP0_blocked_a1 = L1_BP1_recirc_a1;
                  // This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         //_\end_source
         `line 419 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
         `line 343 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp1, @1'], [' |bp2, @1'], )
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp1, @1'], )
                  // Avail/Blocked Input:
                  //_|bp1
                     //_@1
                        assign L1_BP1_accepted_a1 = L1_BP1_avail_a1 && ! L1_BP1_blocked_a1;  // provided for optional upstream use.
                        assign L1_BP1_reset_in_a1 = L1_BP1_reset_a1;
                        `BOGUS_USE(L1_BP1_accepted_a1 L1_BP1_reset_in_a1)
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp1, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp2, @1'])
                  // Avail/Blocked Output:
                  //_|bp2
                     //_@1
                        `BOGUS_USE(L1_BP2_reset_a1) // Output pipes must provide $reset.
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp2, @1))))
                     
                  //_\end_source
                  `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_\end_source
            `line 350 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_|bp2
               //_@0
                  assign L1_BP2_reset_a0 = L1_BP1_reset_in_a1;
                  
                  assign L1_BP2_avail_a0 = L1_BP2_reset_a0 ? 1'b0 :
                                    (L1_BP2_avail_a1 && L1_BP2_blocked_a1) ||  // Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    L1_BP1_avail_a1; // Incoming available
                  //$first_avail = $avail && ! >>1$blocked;  // Transaction is newly available.
               //_@0
                  //_?$avail  // Physically, $first_avail && *reset_b for functional gating in
                           // place of recirculation.
                     //_/trans
                        assign {RingStop_BP2_Trans_cyc_cnt_a0[ring_stop], L1_BP2_Trans_dest_a0[1:0], L1_BP2_Trans_sender_a0[1:0]} =
                           L1_BP2_recirc_a1 ? {RingStop_BP2_Trans_cyc_cnt_a1[ring_stop], L1_BP2_Trans_dest_a1, L1_BP2_Trans_sender_a1}
                                                : {RingStop_BP1_Trans_cyc_cnt_a1[ring_stop], L1_BP1_Trans_dest_a1, L1_BP1_Trans_sender_a1};
               //_@1
                  assign L1_BP2_recirc_a1 = L1_BP2_avail_a1 && L1_BP2_blocked_a1;  // Available transaction that is blocked; must recirc.
            //_|bp1
               //_@1
                  assign L1_BP1_blocked_a1 = L1_BP2_recirc_a1;
                  // This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         //_\end_source
         `line 421 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
         `line 343 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp2, @1'], [' |bp3, @1'], )
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp2, @1'], )
                  // Avail/Blocked Input:
                  //_|bp2
                     //_@1
                        assign L1_BP2_accepted_a1 = L1_BP2_avail_a1 && ! L1_BP2_blocked_a1;  // provided for optional upstream use.
                        assign L1_BP2_reset_in_a1 = L1_BP2_reset_a1;
                        `BOGUS_USE(L1_BP2_accepted_a1 L1_BP2_reset_in_a1)
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp2, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp3, @1'])
                  // Avail/Blocked Output:
                  //_|bp3
                     //_@1
                        `BOGUS_USE(L1_BP3_reset_a1) // Output pipes must provide $reset.
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp3, @1))))
                     
                  //_\end_source
                  `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_\end_source
            `line 350 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            //_|bp3
               //_@0
                  assign L1_BP3_reset_a0 = L1_BP2_reset_in_a1;
                  
                  assign L1_BP3_avail_a0 = L1_BP3_reset_a0 ? 1'b0 :
                                    (L1_BP3_avail_a1 && L1_BP3_blocked_a1) ||  // Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    L1_BP2_avail_a1; // Incoming available
                  //$first_avail = $avail && ! >>1$blocked;  // Transaction is newly available.
               //_@0
                  //_?$avail  // Physically, $first_avail && *reset_b for functional gating in
                           // place of recirculation.
                     //_/trans
                        assign {RingStop_BP3_Trans_cyc_cnt_a0[ring_stop], L1_BP3_Trans_dest_a0[1:0], L1_BP3_Trans_sender_a0[1:0]} =
                           L1_BP3_recirc_a1 ? {RingStop_BP3_Trans_cyc_cnt_a1[ring_stop], L1_BP3_Trans_dest_a1, L1_BP3_Trans_sender_a1}
                                                : {RingStop_BP2_Trans_cyc_cnt_a1[ring_stop], L1_BP2_Trans_dest_a1, L1_BP2_Trans_sender_a1};
               //_@1
                  assign L1_BP3_recirc_a1 = L1_BP3_avail_a1 && L1_BP3_blocked_a1;  // Available transaction that is blocked; must recirc.
            //_|bp2
               //_@1
                  assign L1_BP2_blocked_a1 = L1_BP3_recirc_a1;
                  // This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         //_\end_source
         `line 423 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
      //_\end_source
      `line 68 "top.tlv" 2
      //_|bp3
         //_@1
            assign L1_BP3_local_a1 = L1_BP3_Trans_dest_a1 == ring_stop;
      `line 180 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 71 as: m4+opportunistic_flow(/ring_stop, |bp3, @1, |bypass, @1, $local, |ring_in, @1, /trans)
         `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 180 as: m4+flow_interface(/ring_stop, [' |bp3, @1'], [' |bypass, @1, |ring_in, @1'], )
            `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp3, @1'], )
               // Avail/Blocked Input:
               //_|bp3
                  //_@1
                     assign L1_BP3_accepted_a1 = L1_BP3_avail_a1 && ! L1_BP3_blocked_a1;  // provided for optional upstream use.
                     assign L1_BP3_reset_in_a1 = L1_BP3_reset_a1;
                     `BOGUS_USE(L1_BP3_accepted_a1 L1_BP3_reset_in_a1)
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 71 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp3, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bypass, @1, |ring_in, @1'])
               // Avail/Blocked Output:
               //_|bypass
                  //_@1
                     `BOGUS_USE(L1_BYPASS_reset_a1) // Output pipes must provide $reset.
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 71 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bypass, @1, |ring_in, @1))))
                  // Avail/Blocked Output:
                  //_|ring_in
                     //_@1
                        `BOGUS_USE(L1_RING_IN_reset_a1) // Output pipes must provide $reset.
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 71 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift(|ring_in,@1))))
                     
                  //_\end_source
                  `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_\end_source
         `line 181 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
         //_|bypass
            //_@1
               assign L1_BYPASS_avail_a1 = L1_BP3_avail_a1 &&
                        L1_BP3_local_a1;
               assign L1_BYPASS_reset_a1 = L1_BP3_reset_in_a1;
               //_?$avail
                  //_/trans
                     assign {L1_BYPASS_Trans_cyc_cnt_a1, L1_BYPASS_Trans_sender_a1[1:0]} = {RingStop_BP3_Trans_cyc_cnt_a1[ring_stop], L1_BP3_Trans_sender_a1[1:0]};
         //_|ring_in
            //_@1
               assign L1_RING_IN_avail_a1 = L1_BP3_avail_a1 &&
                        (! L1_BP3_local_a1 ||
                         L1c_RingStop[ring_stop].L1_BYPASS_blocked_a1);
               assign L1_RING_IN_reset_a1 = L1_BP3_reset_in_a1;
               //_?$avail
                  //_/trans
                     assign {L1_RING_IN_Trans_cyc_cnt_a1, L1_RING_IN_Trans_dest_a1[1:0], L1_RING_IN_Trans_sender_a1[1:0]} = {RingStop_BP3_Trans_cyc_cnt_a1[ring_stop], L1_BP3_Trans_dest_a1, L1_BP3_Trans_sender_a1};
         //_|bp3
            //_@1
               assign L1_BP3_blocked_a1 = (L1b_RingStop[ring_stop].L1_RING_IN_blocked_a1 ||
                           ! L1_BP3_local_a1) &&
                          L1c_RingStop[ring_stop].L1_BYPASS_blocked_a1;
         
      end //_\end_source
      `line 72 "top.tlv" 2
   `line 1018 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 72 as: m4+simple_ring(/ring_stop, |ring_in, @1, |ring_out, @1, /top<>0$reset, |rg, /trans)
      
      
      
      
      
      
      // Logic
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1b_RingStop logic L1_RG_passed_on_a1; logic L1_RG_valid_a1; logic L1_RING_IN_accepted_a1; logic L1_RING_IN_blocked_a1; logic L1_RING_IN_reset_in_a1; logic L1_RING_OUT_avail_a1, L1_RING_OUT_avail_a2, L1_RING_OUT_avail_a3, L1_RING_OUT_avail_a4; logic L1_RING_OUT_reset_a1, L1_RING_OUT_reset_a2, L1_RING_OUT_reset_a3, L1_RING_OUT_reset_a4; logic L1_RING_OUT_trans_valid_a1, L1_RING_OUT_trans_valid_a2, L1_RING_OUT_trans_valid_a3; logic L1_RING_OUT_Trans_cyc_cnt_a1, L1_RING_OUT_Trans_cyc_cnt_a2, L1_RING_OUT_Trans_cyc_cnt_a3, L1_RING_OUT_Trans_cyc_cnt_a4; logic [1:0] L1_RING_OUT_Trans_sender_a1, L1_RING_OUT_Trans_sender_a2, L1_RING_OUT_Trans_sender_a3, L1_RING_OUT_Trans_sender_a4; //_/ring_stop
         `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 1026 as: m4+flow_interface(/ring_stop, [' |ring_in, @1'], [' |ring_out, @1'], /top<>0$reset)
            `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |ring_in, @1'], /top<>0$reset)
               // Avail/Blocked Input:
               //_|ring_in
                  //_@1
                     assign L1_RING_IN_accepted_a1 = L1_RingStop[ring_stop].L1_RING_IN_avail_a1 && ! L1_RING_IN_blocked_a1;  // provided for optional upstream use.
                     assign L1_RING_IN_reset_in_a1 =  L0_reset_a1;
                     `BOGUS_USE(L1_RING_IN_accepted_a1 L1_RING_IN_reset_in_a1)
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 72 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_in, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |ring_out, @1'])
               // Avail/Blocked Output:
               //_|ring_out
                  //_@1
                     `BOGUS_USE(L1_RING_OUT_reset_a1) // Output pipes must provide $reset.
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 72 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_out, @1))))
                  
               //_\end_source
               `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_\end_source
         `line 1027 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_|default
            //_@0
               /*SV_plus*/
                  int prev_hop = (ring_stop + 4 - 1) % 4;
         //_|ring_in
            //_@1
               assign L1_RING_IN_blocked_a1 = L1_RG_passed_on_a1;
         //_|rg
            //_@1
               assign L1_RG_passed_on_a1 = RingStop_RG_pass_on_a2[prev_hop];
               assign L1_RG_valid_a1 = ! L1_RING_IN_reset_in_a1 &&
                        (L1_RG_passed_on_a1 || L1_RingStop[ring_stop].L1_RING_IN_avail_a1);
               assign RingStop_RG_pass_on_a1[ring_stop] = L1_RG_valid_a1 && ! L1_RING_OUT_trans_valid_a1;
               assign RingStop_RG_dest_a1[ring_stop][1:0] =
                  L1_RG_passed_on_a1
                     ? RingStop_RG_dest_a2[prev_hop]
                     : L1_RingStop[ring_stop].L1_RING_IN_Trans_dest_a1;
            //_@1
               //_?$valid
                  //_/trans
                     assign {RingStop_RG_Trans_cyc_cnt_a1[ring_stop], RingStop_RG_Trans_sender_a1[ring_stop][1:0]} =
                       L1_RG_passed_on_a1
                           ? {RingStop_RG_Trans_cyc_cnt_a2[prev_hop], RingStop_RG_Trans_sender_a2[prev_hop]}
                           : {L1_RingStop[ring_stop].L1_RING_IN_Trans_cyc_cnt_a1, L1_RingStop[ring_stop].L1_RING_IN_Trans_sender_a1};
         //_|ring_out
            // Ring out
            //_@1
               assign L1_RING_OUT_avail_a1 = L1_RG_valid_a1 && (RingStop_RG_dest_a1[ring_stop] == ring_stop);
               //$blocked = 1'b0;
               assign L1_RING_OUT_trans_valid_a1 = L1_RING_OUT_avail_a1; // && ! $blocked;
               assign L1_RING_OUT_reset_a1 = L1_RING_IN_reset_in_a1;
            //_?$trans_valid
               //_@1
                  //_/trans
                     assign {L1_RING_OUT_Trans_cyc_cnt_a1, L1_RING_OUT_Trans_sender_a1[1:0]} = {RingStop_RG_Trans_cyc_cnt_a1[ring_stop], RingStop_RG_Trans_sender_a1[ring_stop]}; end
      
      
      
      
      
   //_\end_source
   `line 73 "top.tlv" 2
   
   for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1c_RingStop logic L1_ARB_OUT_avail_a1; logic L1_ARB_OUT_blocked_a1; logic L1_ARB_OUT_ready_a1; logic L1_ARB_OUT_reset_a1; logic L1_ARB_OUT_Trans_cyc_cnt_a1; logic [1:0] L1_ARB_OUT_Trans_sender_a1; logic L1_BYPASS_accepted_a1; logic L1_BYPASS_blocked_a1; logic L1_BYPASS_reset_in_a1; logic L1_FIFO2_OUT_avail_a1; logic L1_FIFO2_OUT_Trans_cyc_cnt_a1; logic [1:0] L1_FIFO2_OUT_Trans_sender_a1; logic L1_RING_OUT_accepted_a4; logic L1_RING_OUT_blocked_a4; logic L1_RING_OUT_reset_in_a4; //_/ring_stop
      `line 151 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 75 as: m4+arb2(/ring_stop, |ring_out, @4, |bypass, @1, |arb_out, @1, /trans)
         `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 151 as: m4+flow_interface(/ring_stop, [' |ring_out, @4, |bypass, @1'], [' |arb_out, @1'], )
            `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |ring_out, @4, |bypass, @1'], )
               // Avail/Blocked Input:
               //_|ring_out
                  //_@4
                     assign L1_RING_OUT_accepted_a4 = L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 && ! L1_RING_OUT_blocked_a4;  // provided for optional upstream use.
                     assign L1_RING_OUT_reset_in_a4 = L1b_RingStop[ring_stop].L1_RING_OUT_reset_a4;
                     `BOGUS_USE(L1_RING_OUT_accepted_a4 L1_RING_OUT_reset_in_a4)
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 75 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_out, @4, |bypass, @1))), m4_quote(m4_shift(_resets)))
                  // Avail/Blocked Input:
                  //_|bypass
                     //_@1
                        assign L1_BYPASS_accepted_a1 = L1_RingStop[ring_stop].L1_BYPASS_avail_a1 && ! L1_BYPASS_blocked_a1;  // provided for optional upstream use.
                        assign L1_BYPASS_reset_in_a1 = L1_RingStop[ring_stop].L1_BYPASS_reset_a1;
                        `BOGUS_USE(L1_BYPASS_accepted_a1 L1_BYPASS_reset_in_a1)
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 75 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift(|bypass,@1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  
               //_\end_source
               `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |arb_out, @1'])
               // Avail/Blocked Output:
               //_|arb_out
                  //_@1
                     `BOGUS_USE(L1_ARB_OUT_reset_a1) // Output pipes must provide $reset.
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 75 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |arb_out, @1))))
                  
               //_\end_source
               `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_\end_source
         `line 152 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         
         // In1 is blocked if output is blocked.
         //_|ring_out
            //_@4
               assign L1_RING_OUT_blocked_a4 = L1_ARB_OUT_blocked_a1;
         // In2 is blocked if output is blocked or in1 is available.
         //_|bypass
            //_@1
               assign L1_BYPASS_blocked_a1 = L1_ARB_OUT_blocked_a1 ||
                          L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4;
         // Output comes from in1 if available, otherwise, in2.
         //_|arb_out
            //_@1
               assign L1_ARB_OUT_reset_a1 = L1_RING_OUT_reset_in_a4;
               // Output is available if either input is available.
               assign L1_ARB_OUT_avail_a1 = L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 ||
                        L1_RingStop[ring_stop].L1_BYPASS_avail_a1;
               //_?$avail
                  //_/trans
                     assign {L1_ARB_OUT_Trans_cyc_cnt_a1, L1_ARB_OUT_Trans_sender_a1[1:0]} = L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 ? {L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a4, L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a4} :
                                                                                {L1_RingStop[ring_stop].L1_BYPASS_Trans_cyc_cnt_a1, L1_RingStop[ring_stop].L1_BYPASS_Trans_sender_a1[1:0]};
         
      //_\end_source
      `line 76 "top.tlv" 2
      // FIFO2
      // To use BaseJump STL, this line:
      //m4+simple_bypass_fifo_v2(/ring_stop, |arb_out, @1, |fifo2_out, @1, 4, 100, /trans)        
      // Becomes:
      //----------------
      //_|arb_out
         //_@1
            /*SV_plus*/
               bsg_fifo_1r1w_small #(.width_p(100)) my_fifo(
                  clk, L1_ARB_OUT_reset_a1,
                  L1_ARB_OUT_avail_a1, L1_ARB_OUT_ready_a1, {L1_ARB_OUT_Trans_cyc_cnt_a1, L1_ARB_OUT_Trans_sender_a1},
                  L1_FIFO2_OUT_avail_a1, {L1_FIFO2_OUT_Trans_cyc_cnt_a1, L1_FIFO2_OUT_Trans_sender_a1[1:0]}, L1d_RingStop[ring_stop].L1_FIFO2_OUT_accepted_a1
               );
            assign L1_ARB_OUT_blocked_a1 = ! L1_ARB_OUT_ready_a1; end
      //----------------
   
   
   //m4+trans()
   
   
   // Testbench
   `line 1306 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 97 as: m4+router_testbench(/top, /ring_stop, |stall0, @1, |fifo2_out, @1, /trans, /top<>0$reset)
        // Otherwise we can have a cyclic reset loop through flow.
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1d_RingStop logic L1_FIFO2_OUT_accepted_a1; logic L1_FIFO2_OUT_reset_in_a1; //_/ring_stop
         // Define flow interface. Note that router ins are tb outs and outs are ins.
         `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 1309 as: m4+flow_interface(/ring_stop, [' |fifo2_out, @1'], [' |stall0, @1'], /top<>0$reset)
            `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |fifo2_out, @1'], /top<>0$reset)
               // Avail/Blocked Input:
               //_|fifo2_out
                  //_@1
                     assign L1_FIFO2_OUT_accepted_a1 = L1c_RingStop[ring_stop].L1_FIFO2_OUT_avail_a1 && ! L1e_RingStop[ring_stop].L1_FIFO2_OUT_blocked_a1;  // provided for optional upstream use.
                     assign L1_FIFO2_OUT_reset_in_a1 =  L0_reset_a1;
                     `BOGUS_USE(L1_FIFO2_OUT_accepted_a1 L1_FIFO2_OUT_reset_in_a1)
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 97 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |fifo2_out, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall0, @1'])
               // Avail/Blocked Output:
               //_|stall0
                  //_@1
                     `BOGUS_USE(L1e_RingStop[ring_stop].L1_STALL0_reset_a1) // Output pipes must provide $reset.
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 97 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall0, @1))))
                  
               //_\end_source
               `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         end //_\end_source
         `line 1310 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
      
      
      
   
      //_/tb
         //_|count
            //_@1
               assign Tb_COUNT_CycCount_a0[15:0] = L1e_RingStop[0].L1_STALL0_reset_a2
                                     ? 16'b0 :
                                       Tb_COUNT_CycCount_a1 + 1;
               /*SV_plus*/
                  always_ff @(posedge clk) begin
                     $display("Cycle: %0d", Tb_COUNT_CycCount_a1);
                  end
         for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1_Tb_RingStop logic L1_RECEIVE1_accepted_a1; logic L1_RECEIVE1_avail_a1; logic L1_RECEIVE1_blocked_a1; logic L1_RECEIVE1_reset_a1; logic L1_RECEIVE1_reset_in_a1; logic L1_RECEIVE1_Trans_cyc_cnt_a1; logic [1:0] L1_RECEIVE1_Trans_dest_a1; logic L1_RECEIVE1_Trans_request_a1; logic L1_RECEIVE1_Trans_response_a1; logic L1_RECEIVE1_Trans_response_debug_a1; logic [1:0] L1_RECEIVE1_Trans_sender_a1; logic [16-1:0] L1_RECEIVE2_OutstandingPackets_a0, L1_RECEIVE2_OutstandingPackets_a1; logic L1_RECEIVE2_accepted_a1; logic L1_RECEIVE2_avail_a0, L1_RECEIVE2_avail_a1; logic L1_RECEIVE2_blocked_a1; logic L1_RECEIVE2_generated_request_a1; logic L1_RECEIVE2_recirc_a1; logic L1_RECEIVE2_reset_a0, L1_RECEIVE2_reset_a1; logic L1_RECEIVE2_valid_request_a1; logic L1_RECEIVE2_valid_response_a1; logic L1_RECEIVE2_Trans_cyc_cnt_a0, L1_RECEIVE2_Trans_cyc_cnt_a1; logic [1:0] L1_RECEIVE2_Trans_dest_a0, L1_RECEIVE2_Trans_dest_a1; logic L1_RECEIVE2_Trans_request_a0, L1_RECEIVE2_Trans_request_a1; logic L1_RECEIVE2_Trans_response_a0, L1_RECEIVE2_Trans_response_a1; logic L1_RECEIVE2_Trans_response_debug_a0, L1_RECEIVE2_Trans_response_debug_a1; logic L1_RECEIVE2_Trans_sender_a0, L1_RECEIVE2_Trans_sender_a1; logic L1_SEND_avail_a1; logic L1_SEND_reset_a1; logic L1_SEND_valid_in_a1; logic [15:0] L1_SEND_GenTrans_cyc_cnt_a1; logic [1:0] L1_SEND_GenTrans_dest_a1; logic [1:0] L1_SEND_GenTrans_dest_tmp_a1; logic L1_SEND_GenTrans_response_debug_a1; logic [1:0] L1_SEND_GenTrans_sender_a1; logic [15:0] L1_SEND_TransOut_cyc_cnt_a1; logic [1:0] L1_SEND_TransOut_dest_a1; logic L1_SEND_TransOut_response_debug_a1; logic [1:0] L1_SEND_TransOut_sender_a1; //_/ring_stop
            // STIMULUS
            //_|send
               //_@1
                  // Generate a transaction to inject sometimes (if needed)
                  assign L1_SEND_reset_a1 = L1_RECEIVE2_reset_a1;
                  assign L1_SEND_valid_in_a1 = Tb_COUNT_CycCount_a1 == 3;
                  //_?$valid_in
                     //_/gen_trans
                        assign L1_SEND_GenTrans_cyc_cnt_a1[15:0] = Tb_COUNT_CycCount_a1;
                        assign L1_SEND_GenTrans_response_debug_a1 = 1'b0;  // Not a response (for debug)
                        assign L1_SEND_GenTrans_sender_a1[1:0] = ring_stop;
                        //m4_rand($size, M4_PACKET_SIZE-1, 0, #m4_port) // unused
                        assign L1_SEND_GenTrans_dest_tmp_a1[1:0] = RW_rand_vect[(0 + (ring_stop)) % 257 +: 2];
                        assign L1_SEND_GenTrans_dest_a1[1:0] = L1_SEND_GenTrans_dest_tmp_a1 % 4;
                        //$dest[M4_['']M4_PORT['']_INDEX_RANGE] = #m4_port;
                        //$packet_valid = #m4_port == 0 ? 1'b1 : 1'b0; // valid for only first port - unused
                  assign L1_SEND_avail_a1 = L1_SEND_valid_in_a1 || L1_RECEIVE2_valid_request_a1;
                  //_?$avail
                     //_/trans_out
                        // Loopback requests as responses or use gen_trans.
                        assign {L1_SEND_TransOut_cyc_cnt_a1[15:0], L1_SEND_TransOut_dest_a1[1:0], L1_SEND_TransOut_response_debug_a1, L1_SEND_TransOut_sender_a1[1:0]} = L1_RECEIVE2_valid_request_a1
                                    ? {L1_RECEIVE2_Trans_cyc_cnt_a1, L1_RECEIVE2_Trans_dest_a1, L1_RECEIVE2_Trans_response_debug_a1, L1_RECEIVE2_Trans_sender_a1} :
                                      {L1_SEND_GenTrans_cyc_cnt_a1, L1_SEND_GenTrans_dest_a1[1:0], L1_SEND_GenTrans_response_debug_a1, L1_SEND_GenTrans_sender_a1};
                        
                        /*SV_plus*/
                           always_ff @(posedge clk) begin
                              if (! L1_SEND_reset_a1 && ! reset && L1_RingStop[ring_stop].L1_STALL0_accepted_a1) begin
                                 $display("|send[%0d]", ring_stop);
                                 $display("Sender: %0d, Orig. Cyc: %0d, Dest: %0d, Resp: %0d", L1_SEND_TransOut_sender_a1, L1_SEND_TransOut_cyc_cnt_a1, L1_SEND_TransOut_dest_a1, L1_SEND_TransOut_response_debug_a1);
                              end
                           end
            // Hook router out to |receive1 and determine transaction response routing (within the transaction).
            //_|receive1
               //_@1
                  assign L1_RECEIVE1_avail_a1 = L1c_RingStop[ring_stop].L1_FIFO2_OUT_avail_a1;
                  assign L1_RECEIVE1_reset_a1 = L1d_RingStop[ring_stop].L1_FIFO2_OUT_reset_in_a1;
                  //_?$accepted
                     //_/trans
                        assign L1_RECEIVE1_Trans_response_debug_a1 = 1'b1; // Turn this around as a response.
                        assign L1_RECEIVE1_Trans_request_a1 = L1_RECEIVE1_Trans_sender_a1 != ring_stop;  // Arrived as request?
                        assign L1_RECEIVE1_Trans_response_a1 = L1_RECEIVE1_Trans_sender_a1 == ring_stop; // Arrived as response?
                        assign {L1_RECEIVE1_Trans_cyc_cnt_a1, L1_RECEIVE1_Trans_sender_a1[1:0]} = {L1c_RingStop[ring_stop].L1_FIFO2_OUT_Trans_cyc_cnt_a1, L1c_RingStop[ring_stop].L1_FIFO2_OUT_Trans_sender_a1};
                        assign L1_RECEIVE1_Trans_dest_a1[1:0] = L1_RECEIVE1_Trans_request_a1 ? L1_RECEIVE1_Trans_sender_a1 : L1_RECEIVE1_Trans_dest_a1;
            `line 343 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 1368 as: m4+bp_stage(/ring_stop, |receive1, @1, |receive2, @1, /trans)
               
               
               
               
               
               
               `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |receive1, @1'], [' |receive2, @1'], )
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |receive1, @1'], )
                     // Avail/Blocked Input:
                     //_|receive1
                        //_@1
                           assign L1_RECEIVE1_accepted_a1 = L1_RECEIVE1_avail_a1 && ! L1_RECEIVE1_blocked_a1;  // provided for optional upstream use.
                           assign L1_RECEIVE1_reset_in_a1 = L1_RECEIVE1_reset_a1;
                           `BOGUS_USE(L1_RECEIVE1_accepted_a1 L1_RECEIVE1_reset_in_a1)
                     `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 97 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |receive1, @1))), m4_quote(m4_shift(_resets)))
                        
                     //_\end_source
                     `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                     
                  //_\end_source
                  `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |receive2, @1'])
                     // Avail/Blocked Output:
                     //_|receive2
                        //_@1
                           `BOGUS_USE(L1_RECEIVE2_reset_a1) // Output pipes must provide $reset.
                     `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 97 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |receive2, @1))))
                        
                     //_\end_source
                     `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                     
                  //_\end_source
                  `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               //_\end_source
               `line 350 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               //_|receive2
                  //_@0
                     assign L1_RECEIVE2_reset_a0 = L1_RECEIVE1_reset_in_a1;
                     
                     assign L1_RECEIVE2_avail_a0 = L1_RECEIVE2_reset_a0 ? 1'b0 :
                                       (L1_RECEIVE2_avail_a1 && L1_RECEIVE2_blocked_a1) ||  // Recirc'ed or
                                       // Above is recomputation of $recirc to avoid a flop.
                                       // For SELF, its in the same stage, and is redundant computation.
                                       L1_RECEIVE1_avail_a1; // Incoming available
                     //$first_avail = $avail && ! >>1$blocked;  // Transaction is newly available.
                  //_@0
                     //_?$avail  // Physically, $first_avail && *reset_b for functional gating in
                              // place of recirculation.
                        //_/trans
                           assign {L1_RECEIVE2_Trans_cyc_cnt_a0, L1_RECEIVE2_Trans_dest_a0[1:0], L1_RECEIVE2_Trans_request_a0, L1_RECEIVE2_Trans_response_a0, L1_RECEIVE2_Trans_response_debug_a0, L1_RECEIVE2_Trans_sender_a0} =
                              L1_RECEIVE2_recirc_a1 ? {L1_RECEIVE2_Trans_cyc_cnt_a1, L1_RECEIVE2_Trans_dest_a1, L1_RECEIVE2_Trans_request_a1, L1_RECEIVE2_Trans_response_a1, L1_RECEIVE2_Trans_response_debug_a1, L1_RECEIVE2_Trans_sender_a1}
                                                   : {L1_RECEIVE1_Trans_cyc_cnt_a1, L1_RECEIVE1_Trans_dest_a1, L1_RECEIVE1_Trans_request_a1, L1_RECEIVE1_Trans_response_a1, L1_RECEIVE1_Trans_response_debug_a1, L1_RECEIVE1_Trans_sender_a1};
                  //_@1
                     assign L1_RECEIVE2_recirc_a1 = L1_RECEIVE2_avail_a1 && L1_RECEIVE2_blocked_a1;  // Available transaction that is blocked; must recirc.
               //_|receive1
                  //_@1
                     assign L1_RECEIVE1_blocked_a1 = L1_RECEIVE2_recirc_a1;
                     // This trans is blocked (whether valid or not) if the next stage is recirculating.
               
               
               
               
               
               
            //_\end_source
            `line 1369 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            // A one-cycle backpressured stage to avoid 0-cycle loopback.
            //_|receive2
               //_@1
                  assign L1_RECEIVE2_valid_request_a1 = L1_RECEIVE2_accepted_a1 && L1_RECEIVE2_Trans_request_a1;
                  assign L1_RECEIVE2_valid_response_a1 = L1_RECEIVE2_accepted_a1 && L1_RECEIVE2_Trans_response_a1;
                  // Block requests that cannot loopback a response .
                  assign L1_RECEIVE2_blocked_a1 = L1_RECEIVE2_valid_request_a1 && L1_RingStop[ring_stop].L1_STALL0_blocked_a1;
                  assign L1_RECEIVE2_accepted_a1 = L1_RECEIVE2_avail_a1 && ! L1_RECEIVE2_blocked_a1;
                  assign L1_RECEIVE2_generated_request_a1 =   L1_RingStop[ring_stop].L1_STALL0_accepted_a1 &&
                                       ! L1e_RingStop[ring_stop].L1_STALL0_Trans_response_debug_a1;
                  assign L1_RECEIVE2_OutstandingPackets_a0[16-1:0] =
                       L1_RECEIVE2_reset_a1 ? '0 :
                         (L1_RECEIVE2_OutstandingPackets_a1 +
                          (L1_RECEIVE2_generated_request_a1 ? 16'b1 : '0) -
                          (L1_RECEIVE2_valid_response_a1 ? 16'b1 : '0)
                         );
            //_|passed  // Aligned to |receive2, but given a new pipeline name to provide a cleaner interface for this $passed output.
               //_@1
                  assign Tb_RingStop_PASSED_passed_a1[ring_stop] = ! L1_RECEIVE2_reset_a1 && L1_RECEIVE2_OutstandingPackets_a1 == '0 && Tb_COUNT_CycCount_a1 > 12; end
      // Connect with DUT.
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1e_RingStop logic L1_FIFO2_OUT_blocked_a1; logic L1_STALL0_avail_a1, L1_STALL0_avail_a2; logic L1_STALL0_reset_a1, L1_STALL0_reset_a2; logic [1:0] L1_STALL0_Trans_dest_a1, L1_STALL0_Trans_dest_a2; logic L1_STALL0_Trans_response_debug_a1; logic [1:0] L1_STALL0_Trans_sender_a1, L1_STALL0_Trans_sender_a2; //_/ring_stop
         //_|stall0
            //_@1
               assign L1_STALL0_avail_a1 = ! L1_STALL0_reset_a1 && L1_Tb_RingStop[ring_stop].L1_SEND_avail_a1;
               //_?$avail
                  //_/trans
                     assign {RingStop_STALL0_Trans_cyc_cnt_a1[ring_stop], L1_STALL0_Trans_dest_a1[1:0], L1_STALL0_Trans_response_debug_a1, L1_STALL0_Trans_sender_a1[1:0]} = {L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_cyc_cnt_a1, L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_dest_a1, L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_response_debug_a1, L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_sender_a1};
               assign L1_STALL0_reset_a1 = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a1;
         //_|fifo2_out
            //_@1
               assign L1_FIFO2_OUT_blocked_a1 = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_blocked_a1;
            end //_/trans
      
      
   //_\end_source
   `line 98 "top.tlv" 2
   
   
   // Simulation control.
   assign passed = & Tb_RingStop_PASSED_passed_a1;
   assign failed = cyc_cnt > 80; endgenerate
//_\SV
endmodule 

<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 528, 5746, 0, 150, 12637, 151, 0, 0, 'opacity: 0.1', 19463, 'opacity: 0.1', 17022, 'opacity: 0.1'],
      ['top.sv', 0, 528, 17904, 6407, 0, 17761, 0, 0, 0, 'opacity: 0.1', 22278, 'opacity: 0.1', 19253, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 1312, 9426, 416, 0, 2229, 17396, 'opacity: 0.1', 4752, 'opacity: 0.1', 14278, 'opacity: 0.1'],
      ['SV Total', 0, 528, 17904, 7719, 9426, 18177, 0, 2229, 17396, 'opacity: 0.1', 27030, 'opacity: 0.1', 33531, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar entry, ring_stop;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0,
      L0_reset_a1;

</span><span class="tlx_comments">// For /ring_stop|bp0/entry/accum/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1 [3:0][(4)-1:0];

</span><span class="tlx_comments">// For /ring_stop|bp0/entry/read_masked/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_BP0_Entry_ReadMasked_Trans_cyc_cnt_a1 [3:0][(4)-1:0];

</span><span class="tlx_comments">// For /ring_stop|bp0/fifo_head/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_BP0_FifoHead_Trans_cyc_cnt_a1 [3:0];

</span><span class="tlx_comments">// For /ring_stop|bp0/head/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_BP0_Head_Trans_cyc_cnt_a1 [3:0];

</span><span class="tlx_comments">// For /ring_stop|bp0/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_BP0_Trans_cyc_cnt_a1 [3:0];

</span><span class="tlx_comments">// For /ring_stop|bp1/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_BP1_Trans_cyc_cnt_a0 [3:0],
      RingStop_BP1_Trans_cyc_cnt_a1 [3:0];

</span><span class="tlx_comments">// For /ring_stop|bp2/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_BP2_Trans_cyc_cnt_a0 [3:0],
      RingStop_BP2_Trans_cyc_cnt_a1 [3:0];

</span><span class="tlx_comments">// For /ring_stop|bp3/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_BP3_Trans_cyc_cnt_a0 [3:0],
      RingStop_BP3_Trans_cyc_cnt_a1 [3:0];

</span><span class="tlx_comments">// For /ring_stop|rg$dest.
</span><span class="tlx_declarations">logic [1:0] RingStop_RG_dest_a1 [3:0],
            RingStop_RG_dest_a2 [3:0];

</span><span class="tlx_comments">// For /ring_stop|rg$pass_on.
</span><span class="tlx_declarations">logic RingStop_RG_pass_on_a1 [3:0],
      RingStop_RG_pass_on_a2 [3:0];

</span><span class="tlx_comments">// For /ring_stop|rg/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_RG_Trans_cyc_cnt_a1 [3:0] </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */</span><span class="tlx_declarations">,
      RingStop_RG_Trans_cyc_cnt_a2 [3:0] </span><span class="tlx_comments">/* verilator lint_restore */</span><span class="tlx_declarations">;

</span><span class="tlx_comments">// For /ring_stop|rg/trans$sender.
</span><span class="tlx_declarations">logic [1:0] RingStop_RG_Trans_sender_a1 [3:0] </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */</span><span class="tlx_declarations">,
            RingStop_RG_Trans_sender_a2 [3:0] </span><span class="tlx_comments">/* verilator lint_restore */</span><span class="tlx_declarations">;

</span><span class="tlx_comments">// For /ring_stop|stall0/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_STALL0_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL0_Trans_cyc_cnt_a2 [3:0];

</span><span class="tlx_comments">// For /ring_stop|stall1/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_STALL1_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL1_Trans_cyc_cnt_a2 [3:0];

</span><span class="tlx_comments">// For /ring_stop|stall2/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_STALL2_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL2_Trans_cyc_cnt_a2 [3:0];

</span><span class="tlx_comments">// For /ring_stop|stall3/entry/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_STALL3_Entry_Trans_cyc_cnt_a1 [3:0][(4)-1:0],
      RingStop_STALL3_Entry_Trans_cyc_cnt_a2 [3:0][(4)-1:0];

</span><span class="tlx_comments">// For /ring_stop|stall3/trans$cyc_cnt.
</span><span class="tlx_declarations">logic RingStop_STALL3_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL3_Trans_cyc_cnt_a2 [3:0];

</span><span class="tlx_comments">// For /tb/ring_stop|passed$passed.
</span><span class="tlx_declarations">logic [3:0] Tb_RingStop_PASSED_passed_a1;

</span><span class="tlx_comments">// For /tb|count$CycCount.
</span><span class="tlx_declarations">logic [15:0] Tb_COUNT_CycCount_a0,
             Tb_COUNT_CycCount_a1;

</span><span class="tlx_comments">
//
// Scope: /ring_stop[3:0]
//

//
// Scope: /ring_stop|bp1
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_BP1_avail_a1 [3:0];

</span><span class="tlx_comments">//
// Scope: /ring_stop|bp2
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_BP2_avail_a1 [3:0];

</span><span class="tlx_comments">//
// Scope: /ring_stop|bp3
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_BP3_avail_a1 [3:0];

</span><span class="tlx_comments">//
// Scope: /ring_stop|rg
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_RG_valid_a2 [3:0];

</span><span class="tlx_comments">//
// Scope: /ring_stop|ring_out
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_RING_OUT_trans_valid_a2 [3:0];
logic clkP_RingStop_RING_OUT_trans_valid_a3 [3:0];
logic clkP_RingStop_RING_OUT_trans_valid_a4 [3:0];

</span><span class="tlx_comments">//
// Scope: /ring_stop|stall0
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_STALL0_avail_a2 [3:0];

</span><span class="tlx_comments">//
// Scope: /ring_stop|stall1
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_STALL1_avail_a2 [3:0];

</span><span class="tlx_comments">//
// Scope: /ring_stop|stall2
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_STALL2_avail_a2 [3:0];

</span><span class="tlx_comments">//
// Scope: /ring_stop|stall3
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_RingStop_STALL3_avail_a2 [3:0];

</span><span class="tlx_comments">//
// Scope: /tb
//

//
// Scope: /tb/ring_stop[3:0]
//

//
// Scope: /tb/ring_stop|receive2
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_Tb_RingStop_RECEIVE2_avail_a1 [3:0];

</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">
   // For $reset.
   </span><span class="tlx_staging">always_ff @(posedge clk) L0_reset_a1 &lt;= L0_reset_a0;


   </span><span class="tlx_comments">//
   // Scope: /ring_stop[3:0]
   //
   </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1gen_RingStop
</span><span class="tlx_comments">
      //
      // Scope: |bp1
      //

         // For $avail.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP1_avail_a1 &lt;= L1_RingStop[ring_stop].L1_BP1_avail_a0;

         </span><span class="tlx_comments">// For $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP1_reset_a1 &lt;= L1_RingStop[ring_stop].L1_BP1_reset_a0;


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_BP1_Trans_cyc_cnt_a1[ring_stop] &lt;= RingStop_BP1_Trans_cyc_cnt_a0[ring_stop];

            </span><span class="tlx_comments">// For $dest.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_BP1_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP1_Trans_dest_a1[1:0] &lt;= L1_RingStop[ring_stop].L1_BP1_Trans_dest_a0[1:0];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_BP1_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP1_Trans_sender_a1[1:0] &lt;= L1_RingStop[ring_stop].L1_BP1_Trans_sender_a0[1:0];




      </span><span class="tlx_comments">//
      // Scope: |bp2
      //

         // For $avail.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP2_avail_a1 &lt;= L1_RingStop[ring_stop].L1_BP2_avail_a0;

         </span><span class="tlx_comments">// For $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP2_reset_a1 &lt;= L1_RingStop[ring_stop].L1_BP2_reset_a0;


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_BP2_Trans_cyc_cnt_a1[ring_stop] &lt;= RingStop_BP2_Trans_cyc_cnt_a0[ring_stop];

            </span><span class="tlx_comments">// For $dest.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_BP2_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP2_Trans_dest_a1[1:0] &lt;= L1_RingStop[ring_stop].L1_BP2_Trans_dest_a0[1:0];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_BP2_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP2_Trans_sender_a1[1:0] &lt;= L1_RingStop[ring_stop].L1_BP2_Trans_sender_a0[1:0];




      </span><span class="tlx_comments">//
      // Scope: |bp3
      //

         // For $avail.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP3_avail_a1 &lt;= L1_RingStop[ring_stop].L1_BP3_avail_a0;

         </span><span class="tlx_comments">// For $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP3_reset_a1 &lt;= L1_RingStop[ring_stop].L1_BP3_reset_a0;


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_BP3_Trans_cyc_cnt_a1[ring_stop] &lt;= RingStop_BP3_Trans_cyc_cnt_a0[ring_stop];

            </span><span class="tlx_comments">// For $dest.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_BP3_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP3_Trans_dest_a1[1:0] &lt;= L1_RingStop[ring_stop].L1_BP3_Trans_dest_a0[1:0];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_BP3_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP3_Trans_sender_a1[1:0] &lt;= L1_RingStop[ring_stop].L1_BP3_Trans_sender_a0[1:0];




      </span><span class="tlx_comments">//
      // Scope: |rg
      //

         // For $dest.
         </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_RG_dest_a2[ring_stop][1:0] &lt;= RingStop_RG_dest_a1[ring_stop][1:0];

         </span><span class="tlx_comments">// For $pass_on.
         </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_RG_pass_on_a2[ring_stop] &lt;= RingStop_RG_pass_on_a1[ring_stop];


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_RG_valid_a2[ring_stop]) RingStop_RG_Trans_cyc_cnt_a2[ring_stop] &lt;= RingStop_RG_Trans_cyc_cnt_a1[ring_stop];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_RG_valid_a2[ring_stop]) RingStop_RG_Trans_sender_a2[ring_stop][1:0] &lt;= RingStop_RG_Trans_sender_a1[ring_stop][1:0];




      </span><span class="tlx_comments">//
      // Scope: |ring_out
      //

         // For $avail.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a2 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a3 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a2;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a3;

         </span><span class="tlx_comments">// For $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a2 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a3 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a2;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a4 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a3;

         </span><span class="tlx_comments">// For $trans_valid.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a3 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2;


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a2 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a1;
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a3 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a2;
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a4 &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a3;

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a2[1:0] &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a1[1:0];
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a3[1:0] &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a2[1:0];
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a4[1:0] &lt;= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a3[1:0];




      </span><span class="tlx_comments">//
      // Scope: |stall0
      //

         // For $avail.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1e_RingStop[ring_stop].L1_STALL0_avail_a2 &lt;= L1e_RingStop[ring_stop].L1_STALL0_avail_a1;

         </span><span class="tlx_comments">// For $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1e_RingStop[ring_stop].L1_STALL0_reset_a2 &lt;= L1e_RingStop[ring_stop].L1_STALL0_reset_a1;


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_STALL0_Trans_cyc_cnt_a2[ring_stop] &lt;= RingStop_STALL0_Trans_cyc_cnt_a1[ring_stop];

            </span><span class="tlx_comments">// For $dest.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_STALL0_avail_a2[ring_stop]) L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a2[1:0] &lt;= L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a1[1:0];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_STALL0_avail_a2[ring_stop]) L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a2[1:0] &lt;= L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a1[1:0];




      </span><span class="tlx_comments">//
      // Scope: |stall1
      //

         // For $avail.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL1_avail_a2 &lt;= L1_RingStop[ring_stop].L1_STALL1_avail_a1;

         </span><span class="tlx_comments">// For $blocked.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL1_blocked_a2 &lt;= L1_RingStop[ring_stop].L1_STALL1_blocked_a1;


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_STALL1_Trans_cyc_cnt_a2[ring_stop] &lt;= RingStop_STALL1_Trans_cyc_cnt_a1[ring_stop];

            </span><span class="tlx_comments">// For $dest.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_STALL1_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL1_Trans_dest_a2[1:0] &lt;= L1_RingStop[ring_stop].L1_STALL1_Trans_dest_a1[1:0];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_STALL1_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL1_Trans_sender_a2[1:0] &lt;= L1_RingStop[ring_stop].L1_STALL1_Trans_sender_a1[1:0];




      </span><span class="tlx_comments">//
      // Scope: |stall2
      //

         // For $avail.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL2_avail_a2 &lt;= L1_RingStop[ring_stop].L1_STALL2_avail_a1;

         </span><span class="tlx_comments">// For $blocked.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL2_blocked_a2 &lt;= L1_RingStop[ring_stop].L1_STALL2_blocked_a1;


         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_STALL2_Trans_cyc_cnt_a2[ring_stop] &lt;= RingStop_STALL2_Trans_cyc_cnt_a1[ring_stop];

            </span><span class="tlx_comments">// For $dest.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_STALL2_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL2_Trans_dest_a2[1:0] &lt;= L1_RingStop[ring_stop].L1_STALL2_Trans_dest_a1[1:0];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_STALL2_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL2_Trans_sender_a2[1:0] &lt;= L1_RingStop[ring_stop].L1_STALL2_Trans_sender_a1[1:0];




      </span><span class="tlx_comments">//
      // Scope: |stall3
      //

         // For $avail.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_avail_a2 &lt;= L1_RingStop[ring_stop].L1_STALL3_avail_a1;

         </span><span class="tlx_comments">// For $blocked.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_blocked_a2 &lt;= L1_RingStop[ring_stop].L1_STALL3_blocked_a1;

         </span><span class="tlx_comments">// For $two_valid.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_two_valid_a2 &lt;= L1_RingStop[ring_stop].L1_STALL3_two_valid_a1;

         </span><span class="tlx_comments">// For $valid_count.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_valid_count_a2[$clog2((4)+1)-1:0] &lt;= L1_RingStop[ring_stop].L1_STALL3_valid_count_a1[$clog2((4)+1)-1:0];


         </span><span class="tlx_comments">//
         // Scope: /entry[(4)-1:0]
         //
         </span><span class="tlx_structure">for (entry = 0; entry &lt;= (4)-1; entry++) begin : L2gen_STALL3_Entry
</span><span class="tlx_comments">            // For $state.
            </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_Entry_state_a2[entry] &lt;= L1_RingStop[ring_stop].L1_STALL3_Entry_state_a1[entry];


            </span><span class="tlx_comments">//
            // Scope: /trans
            //

               // For $cyc_cnt.
               </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_STALL3_Entry_Trans_cyc_cnt_a2[ring_stop][entry] &lt;= RingStop_STALL3_Entry_Trans_cyc_cnt_a1[ring_stop][entry];

               </span><span class="tlx_comments">// For $dest.
               </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_dest_a2[1:0] &lt;= L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_dest_a1[1:0];

               </span><span class="tlx_comments">// For $sender.
               </span><span class="tlx_staging">always_ff @(posedge clk) L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_sender_a2[1:0] &lt;= L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_sender_a1[1:0];


         </span><span class="tlx_structure">end

         </span><span class="tlx_comments">//
         // Scope: /trans
         //

            // For $cyc_cnt.
            </span><span class="tlx_staging">always_ff @(posedge clk) RingStop_STALL3_Trans_cyc_cnt_a2[ring_stop] &lt;= RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop];

            </span><span class="tlx_comments">// For $dest.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_STALL3_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL3_Trans_dest_a2[1:0] &lt;= L1_RingStop[ring_stop].L1_STALL3_Trans_dest_a1[1:0];

            </span><span class="tlx_comments">// For $sender.
            </span><span class="tlx_staging">always_ff @(posedge clkP_RingStop_STALL3_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL3_Trans_sender_a2[1:0] &lt;= L1_RingStop[ring_stop].L1_STALL3_Trans_sender_a1[1:0];



   </span><span class="tlx_structure">end

   </span><span class="tlx_comments">//
   // Scope: /tb
   //


      //
      // Scope: /ring_stop[3:0]
      //
      </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1gen_Tb_RingStop
</span><span class="tlx_comments">
         //
         // Scope: |receive2
         //

            // For $OutstandingPackets.
            </span><span class="tlx_staging">always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_OutstandingPackets_a1[16-1:0] &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_OutstandingPackets_a0[16-1:0];

            </span><span class="tlx_comments">// For $avail.
            </span><span class="tlx_staging">always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a1 &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a0;

            </span><span class="tlx_comments">// For $reset.
            </span><span class="tlx_staging">always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a1 &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a0;


            </span><span class="tlx_comments">//
            // Scope: /trans
            //

               // For $cyc_cnt.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_cyc_cnt_a1 &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_cyc_cnt_a0;

               </span><span class="tlx_comments">// For $dest.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_dest_a1[1:0] &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_dest_a0[1:0];

               </span><span class="tlx_comments">// For $request.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_request_a1 &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_request_a0;

               </span><span class="tlx_comments">// For $response.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_a1 &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_a0;

               </span><span class="tlx_comments">// For $response_debug.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_debug_a1 &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_debug_a0;

               </span><span class="tlx_comments">// For $sender.
               </span><span class="tlx_staging">always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_sender_a1 &lt;= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_sender_a0;



      </span><span class="tlx_structure">end

      </span><span class="tlx_comments">//
      // Scope: |count
      //

         // For $CycCount.
         </span><span class="tlx_staging">always_ff @(posedge clk) Tb_COUNT_CycCount_a1[15:0] &lt;= Tb_COUNT_CycCount_a0[15:0];





</span><span class="tlx_structure">endgenerate



</span><span class="tlx_comments">//
// Gated clocks.
//

</span><span class="tlx_structure">generate

</span><span class="tlx_comments">

   //
   // Scope: /ring_stop[3:0]
   //
   </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1clk_RingStop
</span><span class="tlx_comments">
      //
      // Scope: |bp1
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_BP1_avail_a1(clkP_RingStop_BP1_avail_a1[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_BP1_avail_a0, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |bp2
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_BP2_avail_a1(clkP_RingStop_BP2_avail_a1[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_BP2_avail_a0, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |bp3
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_BP3_avail_a1(clkP_RingStop_BP3_avail_a1[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_BP3_avail_a0, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |rg
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_RG_valid_a2(clkP_RingStop_RG_valid_a2[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RG_valid_a1, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |ring_out
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a2(clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a1, 1'b0);
         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a3(clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2, 1'b0);
         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a4(clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a3, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |stall0
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_STALL0_avail_a2(clkP_RingStop_STALL0_avail_a2[ring_stop], clk, 1'b1, L1e_RingStop[ring_stop].L1_STALL0_avail_a1, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |stall1
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_STALL1_avail_a2(clkP_RingStop_STALL1_avail_a2[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_STALL1_avail_a1, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |stall2
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_STALL2_avail_a2(clkP_RingStop_STALL2_avail_a2[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_STALL2_avail_a1, 1'b0);


      </span><span class="tlx_comments">//
      // Scope: |stall3
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_RingStop_STALL3_avail_a2(clkP_RingStop_STALL3_avail_a2[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_STALL3_avail_a1, 1'b0);

   </span><span class="tlx_structure">end

   </span><span class="tlx_comments">//
   // Scope: /tb
   //


      //
      // Scope: /ring_stop[3:0]
      //
      </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1clk_Tb_RingStop
</span><span class="tlx_comments">
         //
         // Scope: |receive2
         //

</span><span class="tlx_gating">            clk_gate gen_clkP_Tb_RingStop_RECEIVE2_avail_a1(clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop], clk, 1'b1, L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a0, 1'b0);

      </span><span class="tlx_structure">end



endgenerate



</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      </span><span class="tlx_comments">//
      // Scope: /ring_stop[3:0]
      //
      </span><span class="tlx_instrumentation">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : \/ring_stop 
</span><span class="tlx_comments">
         //
         // Scope: |arb_out
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|arb_out 
            logic  \@1$avail ;
            assign \@1$avail = L1c_RingStop[ring_stop].L1_ARB_OUT_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1c_RingStop[ring_stop].L1_ARB_OUT_blocked_a1;
            logic  \@1$ready ;
            assign \@1$ready = L1c_RingStop[ring_stop].L1_ARB_OUT_ready_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1c_RingStop[ring_stop].L1_ARB_OUT_reset_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1c_RingStop[ring_stop].L1_ARB_OUT_Trans_cyc_cnt_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1c_RingStop[ring_stop].L1_ARB_OUT_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |bp0
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|bp0 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_BP0_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_BP0_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_BP0_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_BP0_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_BP0_reset_in_a1;
            logic  \@1$trans_valid ;
            assign \@1$trans_valid = L1_RingStop[ring_stop].L1_BP0_trans_valid_a1;

            </span><span class="tlx_comments">//
            // Scope: /entry[(4)-1:0]
            //
            </span><span class="tlx_instrumentation">for (entry = 0; entry &lt;= (4)-1; entry++) begin : \/entry 
               logic  \@1$is_head ;
               assign \@1$is_head = L1_RingStop[ring_stop].L2b_BP0_Entry[entry].L2_is_head_a1;
               logic  \@1$pop ;
               assign \@1$pop = L1_RingStop[ring_stop].L2b_BP0_Entry[entry].L2_pop_a1;

               </span><span class="tlx_comments">//
               // Scope: /accum
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/accum 
</span><span class="tlx_comments">
                  //
                  // Scope: /trans
                  //
                  </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                     logic  \@1$cyc_cnt ;
                     assign \@1$cyc_cnt = RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1[ring_stop][entry];
                     logic [1:0] \@1$dest ;
                     assign \@1$dest = L1_RingStop[ring_stop].L1_BP0_Entry_Accum_Trans_dest_a1[entry];
                     logic [1:0] \@1$sender ;
                     assign \@1$sender = L1_RingStop[ring_stop].L1_BP0_Entry_Accum_Trans_sender_a1[entry];
                  end
               end

               </span><span class="tlx_comments">//
               // Scope: /read_masked
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/read_masked 
</span><span class="tlx_comments">
                  //
                  // Scope: /trans
                  //
                  </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                     logic  \@1$cyc_cnt ;
                     assign \@1$cyc_cnt = RingStop_BP0_Entry_ReadMasked_Trans_cyc_cnt_a1[ring_stop][entry];
                     logic [1:0] \@1$dest ;
                     assign \@1$dest = L1_RingStop[ring_stop].L2b_BP0_Entry[entry].L2_ReadMasked_Trans_dest_a1;
                     logic [1:0] \@1$sender ;
                     assign \@1$sender = L1_RingStop[ring_stop].L2b_BP0_Entry[entry].L2_ReadMasked_Trans_sender_a1;
                  end
               end
            end

            </span><span class="tlx_comments">//
            // Scope: /fifo_head
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/fifo_head 
               logic  \@1$avail ;
               assign \@1$avail = L1_RingStop[ring_stop].L1_BP0_FifoHead_avail_a1;

               </span><span class="tlx_comments">//
               // Scope: /trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = RingStop_BP0_FifoHead_Trans_cyc_cnt_a1[ring_stop];
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_RingStop[ring_stop].L1_BP0_FifoHead_Trans_dest_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_RingStop[ring_stop].L1_BP0_FifoHead_Trans_sender_a1;
               end
            end

            </span><span class="tlx_comments">//
            // Scope: /head
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/head 
               logic  \@1$avail ;
               assign \@1$avail = L1_RingStop[ring_stop].L1_BP0_Head_avail_a1;

               </span><span class="tlx_comments">//
               // Scope: /trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = RingStop_BP0_Head_Trans_cyc_cnt_a1[ring_stop];
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_RingStop[ring_stop].L1_BP0_Head_Trans_dest_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_RingStop[ring_stop].L1_BP0_Head_Trans_sender_a1;
               end
            end

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_BP0_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_BP0_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_BP0_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |bp1
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|bp1 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_BP1_accepted_a1;
            logic  \@0$avail ;
            assign \@0$avail = L1_RingStop[ring_stop].L1_BP1_avail_a0;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_BP1_blocked_a1;
            logic  \@1$recirc ;
            assign \@1$recirc = L1_RingStop[ring_stop].L1_BP1_recirc_a1;
            logic  \@0$reset ;
            assign \@0$reset = L1_RingStop[ring_stop].L1_BP1_reset_a0;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_BP1_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@0$cyc_cnt ;
               assign \@0$cyc_cnt = RingStop_BP1_Trans_cyc_cnt_a0[ring_stop];
               logic [1:0] \@0$dest ;
               assign \@0$dest = L1_RingStop[ring_stop].L1_BP1_Trans_dest_a0;
               logic [1:0] \@0$sender ;
               assign \@0$sender = L1_RingStop[ring_stop].L1_BP1_Trans_sender_a0;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |bp2
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|bp2 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_BP2_accepted_a1;
            logic  \@0$avail ;
            assign \@0$avail = L1_RingStop[ring_stop].L1_BP2_avail_a0;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_BP2_blocked_a1;
            logic  \@1$recirc ;
            assign \@1$recirc = L1_RingStop[ring_stop].L1_BP2_recirc_a1;
            logic  \@0$reset ;
            assign \@0$reset = L1_RingStop[ring_stop].L1_BP2_reset_a0;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_BP2_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@0$cyc_cnt ;
               assign \@0$cyc_cnt = RingStop_BP2_Trans_cyc_cnt_a0[ring_stop];
               logic [1:0] \@0$dest ;
               assign \@0$dest = L1_RingStop[ring_stop].L1_BP2_Trans_dest_a0;
               logic [1:0] \@0$sender ;
               assign \@0$sender = L1_RingStop[ring_stop].L1_BP2_Trans_sender_a0;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |bp3
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|bp3 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_BP3_accepted_a1;
            logic  \@0$avail ;
            assign \@0$avail = L1_RingStop[ring_stop].L1_BP3_avail_a0;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_BP3_blocked_a1;
            logic  \@1$local ;
            assign \@1$local = L1_RingStop[ring_stop].L1_BP3_local_a1;
            logic  \@1$recirc ;
            assign \@1$recirc = L1_RingStop[ring_stop].L1_BP3_recirc_a1;
            logic  \@0$reset ;
            assign \@0$reset = L1_RingStop[ring_stop].L1_BP3_reset_a0;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_BP3_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@0$cyc_cnt ;
               assign \@0$cyc_cnt = RingStop_BP3_Trans_cyc_cnt_a0[ring_stop];
               logic [1:0] \@0$dest ;
               assign \@0$dest = L1_RingStop[ring_stop].L1_BP3_Trans_dest_a0;
               logic [1:0] \@0$sender ;
               assign \@0$sender = L1_RingStop[ring_stop].L1_BP3_Trans_sender_a0;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |bypass
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|bypass 
            logic  \@1$accepted ;
            assign \@1$accepted = L1c_RingStop[ring_stop].L1_BYPASS_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_BYPASS_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1c_RingStop[ring_stop].L1_BYPASS_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_BYPASS_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1c_RingStop[ring_stop].L1_BYPASS_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1_RingStop[ring_stop].L1_BYPASS_Trans_cyc_cnt_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_BYPASS_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |fifo2_out
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|fifo2_out 
            logic  \@1$accepted ;
            assign \@1$accepted = L1d_RingStop[ring_stop].L1_FIFO2_OUT_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1c_RingStop[ring_stop].L1_FIFO2_OUT_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1e_RingStop[ring_stop].L1_FIFO2_OUT_blocked_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1d_RingStop[ring_stop].L1_FIFO2_OUT_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1c_RingStop[ring_stop].L1_FIFO2_OUT_Trans_cyc_cnt_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1c_RingStop[ring_stop].L1_FIFO2_OUT_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |rg
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|rg 
            logic [1:0] \@1$dest ;
            assign \@1$dest = RingStop_RG_dest_a1[ring_stop];
            logic  \@1$pass_on ;
            assign \@1$pass_on = RingStop_RG_pass_on_a1[ring_stop];
            logic  \@1$passed_on ;
            assign \@1$passed_on = L1b_RingStop[ring_stop].L1_RG_passed_on_a1;
            logic  \@1$valid ;
            assign \@1$valid = L1b_RingStop[ring_stop].L1_RG_valid_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_RG_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$sender ;
               assign \@1$sender = RingStop_RG_Trans_sender_a1[ring_stop];
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |ring_in
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|ring_in 
            logic  \@1$accepted ;
            assign \@1$accepted = L1b_RingStop[ring_stop].L1_RING_IN_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_RING_IN_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1b_RingStop[ring_stop].L1_RING_IN_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_RING_IN_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1b_RingStop[ring_stop].L1_RING_IN_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1_RingStop[ring_stop].L1_RING_IN_Trans_cyc_cnt_a1;
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_RING_IN_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_RING_IN_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |ring_out
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|ring_out 
            logic  \@4$accepted ;
            assign \@4$accepted = L1c_RingStop[ring_stop].L1_RING_OUT_accepted_a4;
            logic  \@1$avail ;
            assign \@1$avail = L1b_RingStop[ring_stop].L1_RING_OUT_avail_a1;
            logic  \@4$blocked ;
            assign \@4$blocked = L1c_RingStop[ring_stop].L1_RING_OUT_blocked_a4;
            logic  \@1$reset ;
            assign \@1$reset = L1b_RingStop[ring_stop].L1_RING_OUT_reset_a1;
            logic  \@4$reset_in ;
            assign \@4$reset_in = L1c_RingStop[ring_stop].L1_RING_OUT_reset_in_a4;
            logic  \@1$trans_valid ;
            assign \@1$trans_valid = L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |stall0
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|stall0 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_STALL0_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1e_RingStop[ring_stop].L1_STALL0_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_STALL0_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1e_RingStop[ring_stop].L1_STALL0_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_STALL0_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_STALL0_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a1;
               logic  \@1$response_debug ;
               assign \@1$response_debug = L1e_RingStop[ring_stop].L1_STALL0_Trans_response_debug_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |stall1
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|stall1 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_STALL1_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_STALL1_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_STALL1_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_STALL1_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_STALL1_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_STALL1_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_STALL1_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_STALL1_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |stall2
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|stall2 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_STALL2_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_STALL2_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_STALL2_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_STALL2_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_STALL2_reset_in_a1;

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_STALL2_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_STALL2_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_STALL2_Trans_sender_a1;
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |stall3
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|stall3 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_STALL3_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_STALL3_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_STALL3_blocked_a1;
            logic  \@1$bypass ;
            assign \@1$bypass = L1_RingStop[ring_stop].L1_STALL3_bypass_a1;
            logic  \@2$empty ;
            assign \@2$empty = L1_RingStop[ring_stop].L1_STALL3_empty_a2;
            logic  \@2$full ;
            assign \@2$full = L1_RingStop[ring_stop].L1_STALL3_full_a2;
            logic  \@1$grow ;
            assign \@1$grow = L1_RingStop[ring_stop].L1_STALL3_grow_a1;
            logic  \@1$out_blocked ;
            assign \@1$out_blocked = L1_RingStop[ring_stop].L1_STALL3_out_blocked_a1;
            logic  \@1$push ;
            assign \@1$push = L1_RingStop[ring_stop].L1_STALL3_push_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_STALL3_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_STALL3_reset_in_a1;
            logic  \@1$shrink ;
            assign \@1$shrink = L1_RingStop[ring_stop].L1_STALL3_shrink_a1;
            logic  \@1$two_valid ;
            assign \@1$two_valid = L1_RingStop[ring_stop].L1_STALL3_two_valid_a1;
            logic [$clog2((4)+1)-1:0] \@1$valid_count ;
            assign \@1$valid_count = L1_RingStop[ring_stop].L1_STALL3_valid_count_a1;
            logic  \@1$would_bypass ;
            assign \@1$would_bypass = L1_RingStop[ring_stop].L1_STALL3_would_bypass_a1;

            </span><span class="tlx_comments">//
            // Scope: /entry[(4)-1:0]
            //
            </span><span class="tlx_instrumentation">for (entry = 0; entry &lt;= (4)-1; entry++) begin : \/entry 
               logic  \@2$is_head ;
               assign \@2$is_head = L1_RingStop[ring_stop].L2c_STALL3_Entry[entry].L2_is_head_a2;
               logic  \@1$is_tail ;
               assign \@1$is_tail = L1_RingStop[ring_stop].L2b_STALL3_Entry[entry].L2_is_tail_a1;
               logic  \@2$next_entry_state ;
               assign \@2$next_entry_state = L1_RingStop[ring_stop].L2c_STALL3_Entry[entry].L2_next_entry_state_a2;
               logic  \@2$prev_entry_state ;
               assign \@2$prev_entry_state = L1_RingStop[ring_stop].L2c_STALL3_Entry[entry].L2_prev_entry_state_a2;
               logic  \@1$prev_entry_was_tail ;
               assign \@1$prev_entry_was_tail = L1_RingStop[ring_stop].L1_STALL3_Entry_prev_entry_was_tail_a1[entry];
               logic  \@1$push ;
               assign \@1$push = L1_RingStop[ring_stop].L1_STALL3_Entry_push_a1[entry];
               logic  \@2$reconstructed_is_tail ;
               assign \@2$reconstructed_is_tail = L1_RingStop[ring_stop].L1_STALL3_Entry_reconstructed_is_tail_a2[entry];
               logic  \@2$reconstructed_valid ;
               assign \@2$reconstructed_valid = L1_RingStop[ring_stop].L2c_STALL3_Entry[entry].L2_reconstructed_valid_a2;
               logic  \@1$state ;
               assign \@1$state = L1_RingStop[ring_stop].L1_STALL3_Entry_state_a1[entry];
               logic  \@1$valid ;
               assign \@1$valid = L1_RingStop[ring_stop].L2b_STALL3_Entry[entry].L2_valid_a1;

               </span><span class="tlx_comments">//
               // Scope: /trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = RingStop_STALL3_Entry_Trans_cyc_cnt_a1[ring_stop][entry];
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_dest_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_sender_a1;
               end
            end

            </span><span class="tlx_comments">//
            // Scope: /trans
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_STALL3_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_STALL3_Trans_sender_a1;
            end
         end
      end

      </span><span class="tlx_comments">//
      // Scope: /tb
      //
      </span><span class="tlx_instrumentation">if (1) begin : \/tb 
</span><span class="tlx_comments">
         //
         // Scope: /ring_stop[3:0]
         //
         </span><span class="tlx_instrumentation">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : \/ring_stop 
</span><span class="tlx_comments">
            //
            // Scope: |passed
            //
            </span><span class="tlx_instrumentation">if (1) begin : \|passed 
               logic  \@1$passed ;
               assign \@1$passed = Tb_RingStop_PASSED_passed_a1[ring_stop];
            end

            </span><span class="tlx_comments">//
            // Scope: |receive1
            //
            </span><span class="tlx_instrumentation">if (1) begin : \|receive1 
               logic  \@1$accepted ;
               assign \@1$accepted = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_accepted_a1;
               logic  \@1$avail ;
               assign \@1$avail = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_avail_a1;
               logic  \@1$blocked ;
               assign \@1$blocked = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_blocked_a1;
               logic  \@1$reset ;
               assign \@1$reset = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_reset_a1;
               logic  \@1$reset_in ;
               assign \@1$reset_in = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_reset_in_a1;

               </span><span class="tlx_comments">//
               // Scope: /trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_dest_a1;
                  logic  \@1$request ;
                  assign \@1$request = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_request_a1;
                  logic  \@1$response ;
                  assign \@1$response = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_response_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_sender_a1;
               end
            end

            </span><span class="tlx_comments">//
            // Scope: |receive2
            //
            </span><span class="tlx_instrumentation">if (1) begin : \|receive2 
               logic [16-1:0] \@0$OutstandingPackets ;
               assign \@0$OutstandingPackets = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_OutstandingPackets_a0;
               logic  \@1$accepted ;
               assign \@1$accepted = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_accepted_a1;
               logic  \@0$avail ;
               assign \@0$avail = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a0;
               logic  \@1$blocked ;
               assign \@1$blocked = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_blocked_a1;
               logic  \@1$generated_request ;
               assign \@1$generated_request = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_generated_request_a1;
               logic  \@1$recirc ;
               assign \@1$recirc = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_recirc_a1;
               logic  \@0$reset ;
               assign \@0$reset = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a0;
               logic  \@1$valid_request ;
               assign \@1$valid_request = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_valid_request_a1;
               logic  \@1$valid_response ;
               assign \@1$valid_response = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_valid_response_a1;

               </span><span class="tlx_comments">//
               // Scope: /trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans 
                  logic  \@0$cyc_cnt ;
                  assign \@0$cyc_cnt = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_cyc_cnt_a0;
                  logic [1:0] \@0$dest ;
                  assign \@0$dest = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_dest_a0;
                  logic  \@0$request ;
                  assign \@0$request = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_request_a0;
                  logic  \@0$response ;
                  assign \@0$response = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_a0;
                  logic  \@0$response_debug ;
                  assign \@0$response_debug = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_debug_a0;
                  logic  \@0$sender ;
                  assign \@0$sender = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_sender_a0;
               end
            end

            </span><span class="tlx_comments">//
            // Scope: |send
            //
            </span><span class="tlx_instrumentation">if (1) begin : \|send 
               logic  \@1$avail ;
               assign \@1$avail = L1_Tb_RingStop[ring_stop].L1_SEND_avail_a1;
               logic  \@1$reset ;
               assign \@1$reset = L1_Tb_RingStop[ring_stop].L1_SEND_reset_a1;
               logic  \@1$valid_in ;
               assign \@1$valid_in = L1_Tb_RingStop[ring_stop].L1_SEND_valid_in_a1;

               </span><span class="tlx_comments">//
               // Scope: /gen_trans
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/gen_trans 
                  logic [15:0] \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_dest_a1;
                  logic [1:0] \@1$dest_tmp ;
                  assign \@1$dest_tmp = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_dest_tmp_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_sender_a1;
               end

               </span><span class="tlx_comments">//
               // Scope: /trans_out
               //
               </span><span class="tlx_instrumentation">if (1) begin : \/trans_out 
                  logic [15:0] \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_dest_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_sender_a1;
               end
            end
         end

         </span><span class="tlx_comments">//
         // Scope: |count
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|count 
            logic [15:0] \@0$CycCount ;
            assign \@0$CycCount = Tb_COUNT_CycCount_a0;
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
</span><span class="tlx_comments">/*
Copyright (c) 2018, Steve Hoover
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//m4_include_url(['http://localhost:8080/wip/viz.tlv'])
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/5a8c0387be80b2deccfcd1506299b36049e0663e/fundamentals_lib.tlv&quot;
// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflow_lib.tlv&quot;

// Include BaseJump STL FIFO files.
/* verilator lint_off CMPCONST */
/* verilator lint_off WIDTH */
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_defines.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_misc/bsg_defines.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_fifo_tracker.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_dataflow/bsg_fifo_tracker.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_circular_ptr.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_misc/bsg_circular_ptr.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_fifo_1r1w_small.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_dataflow/bsg_fifo_1r1w_small.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_mem_1r1w.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_mem/bsg_mem_1r1w.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_mem_1r1w_synth.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_mem/bsg_mem_1r1w_synth.v&quot;
/* verilator lint_on WIDTH */
/* verilator lint_on CMPCONST */


</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */



</span><span class="tlx_structure">\TLV
   </span><span class="tlx_logic">$reset = *reset;
   
   
   </span><span class="tlx_comments">// DUT
   
   </span><span class="tlx_structure">/ring_stop[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
      \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 511   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+stall_pipeline(/ring_stop, |stall, 0, 3, /trans)
         
         </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 464   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall0, @1'], [' |stall1, @1'], )
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall0, @1'], )
                  // Avail/Blocked Input:
                  </span><span class="tlx_structure">|stall0
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">$reset_in = $reset;
                        `BOGUS_USE($accepted $reset_in)
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall0, @1))), m4_quote(m4_shift(_resets)))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
               \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall1, @1'])
                  // Avail/Blocked Output:
                  </span><span class="tlx_structure">|stall1
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall1, @1))))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
            \end_source
            
            |stall0
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|stall1</span><span class="tlx_logic">&gt;&gt;0$blocked;
            </span><span class="tlx_structure">|stall1
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_comments">// Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|stall0</span><span class="tlx_logic">&gt;&gt;0$reset_in;
                  
                  $avail = $reset      ? 1'b0 :
                           &gt;&gt;1$blocked ? &gt;&gt;1$avail :
                                         </span><span class="tlx_structure">/ring_stop|stall0</span><span class="tlx_logic">&gt;&gt;1$avail;
                  </span><span class="tlx_validity">?$avail
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">|stall1</span><span class="tlx_logic">&gt;&gt;1$blocked ? &gt;&gt;1$ANY : </span><span class="tlx_structure">/ring_stop|stall0/trans</span><span class="tlx_logic">&gt;&gt;1$ANY;
            
         </span><span class="tlx_structure">\end_source
         
         \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 464   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall1, @1'], [' |stall2, @1'], )
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall1, @1'], )
                  // Avail/Blocked Input:
                  </span><span class="tlx_structure">|stall1
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">$reset_in = $reset;
                        `BOGUS_USE($accepted $reset_in)
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall1, @1))), m4_quote(m4_shift(_resets)))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
               \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall2, @1'])
                  // Avail/Blocked Output:
                  </span><span class="tlx_structure">|stall2
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall2, @1))))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
            \end_source
            
            |stall1
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|stall2</span><span class="tlx_logic">&gt;&gt;0$blocked;
            </span><span class="tlx_structure">|stall2
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_comments">// Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|stall1</span><span class="tlx_logic">&gt;&gt;0$reset_in;
                  
                  $avail = $reset      ? 1'b0 :
                           &gt;&gt;1$blocked ? &gt;&gt;1$avail :
                                         </span><span class="tlx_structure">/ring_stop|stall1</span><span class="tlx_logic">&gt;&gt;1$avail;
                  </span><span class="tlx_validity">?$avail
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">|stall2</span><span class="tlx_logic">&gt;&gt;1$blocked ? &gt;&gt;1$ANY : </span><span class="tlx_structure">/ring_stop|stall1/trans</span><span class="tlx_logic">&gt;&gt;1$ANY;
            
         </span><span class="tlx_structure">\end_source
         
         \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 464   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall2, @1'], [' |stall3, @1'], )
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall2, @1'], )
                  // Avail/Blocked Input:
                  </span><span class="tlx_structure">|stall2
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">$reset_in = $reset;
                        `BOGUS_USE($accepted $reset_in)
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall2, @1))), m4_quote(m4_shift(_resets)))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
               \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall3, @1'])
                  // Avail/Blocked Output:
                  </span><span class="tlx_structure">|stall3
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall3, @1))))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
            \end_source
            
            |stall2
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|stall3</span><span class="tlx_logic">&gt;&gt;0$blocked;
            </span><span class="tlx_structure">|stall3
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_comments">// Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|stall2</span><span class="tlx_logic">&gt;&gt;0$reset_in;
                  
                  $avail = $reset      ? 1'b0 :
                           &gt;&gt;1$blocked ? &gt;&gt;1$avail :
                                         </span><span class="tlx_structure">/ring_stop|stall2</span><span class="tlx_logic">&gt;&gt;1$avail;
                  </span><span class="tlx_validity">?$avail
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">|stall3</span><span class="tlx_logic">&gt;&gt;1$blocked ? &gt;&gt;1$ANY : </span><span class="tlx_structure">/ring_stop|stall2/trans</span><span class="tlx_logic">&gt;&gt;1$ANY;
            
         </span><span class="tlx_structure">\end_source
         
         </span><span class="tlx_comments">//
      </span><span class="tlx_structure">\end_source
      \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 575   </span><span class="tlx_comments">// Instantiated from top.tlv, 65 as: m4+flop_fifo_v2(/ring_stop, |stall3, @1, |bp0, @1, 4, /trans)
         </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 576 as: m4+flow_interface(/ring_stop, [' |stall3, @1'], [' |bp0, @1'], )
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall3, @1'], )
               // Avail/Blocked Input:
               </span><span class="tlx_structure">|stall3
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">$reset_in = $reset;
                     `BOGUS_USE($accepted $reset_in)
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 65 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall3, @1))), m4_quote(m4_shift(_resets)))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
            \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp0, @1'])
               // Avail/Blocked Output:
               </span><span class="tlx_structure">|bp0
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 65 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp0, @1))))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
         \end_source
         
         
         
         
         
         </span><span class="tlx_comments">//   @0
         </span><span class="tlx_structure">\SV_plus
            </span><span class="tlx_logic">localparam bit [\$clog2((4)+1)-1:0] full_mark_25 = 4 - 0;
         </span><span class="tlx_comments">// FIFO Instantiation
         // Hierarchy declarations
         </span><span class="tlx_structure">|stall3
            /entry[</span><span class="tlx_logic">(4)-1</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         |bp0
            /entry[</span><span class="tlx_logic">(4)-1</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         |stall3
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$out_blocked = </span><span class="tlx_structure">/ring_stop|bp0</span><span class="tlx_logic">&gt;&gt;0$blocked;
               $blocked = &gt;&gt;1$full &amp;&amp; $out_blocked;
               `BOGUS_USE($blocked)   </span><span class="tlx_comments">// Not required to be consumed elsewhere.
               </span><span class="tlx_logic">$would_bypass = &gt;&gt;1$empty;
               $bypass = $would_bypass &amp;&amp; ! $out_blocked;
               $push = $accepted &amp;&amp; ! $bypass;
               $grow   =   $accepted &amp;&amp;   $out_blocked;
               $shrink = ! $avail &amp;&amp; ! $out_blocked &amp;&amp; ! &gt;&gt;1$empty;
               $valid_count[\$clog2((4)+1)-1:0] = $reset ? '0
                                                           : &gt;&gt;1$valid_count + (
                                                                $grow   ? { {(\$clog2((4)+1)-1){1'b0}}, 1'b1} :
                                                                $shrink ? '1
                                                                        : '0
                                                             );
               </span><span class="tlx_comments">// At least 2 valid entries.
               //$two_valid = | $ValidCount[m4_counter_width-1:1];
               // but logic depth minimized by taking advantage of prev count &gt;= 4.
               </span><span class="tlx_logic">$two_valid = | &gt;&gt;1$valid_count[\$clog2((4)+1)-1:2] || | $valid_count[2:1];
               </span><span class="tlx_comments">// These are an optimization of the commented block below to operate on vectors, rather than bits.
               // TODO: Keep optimizing...
               </span><span class="tlx_logic">{</span><span class="tlx_structure">/entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$$prev_entry_was_tail} = {</span><span class="tlx_structure">/entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$reconstructed_is_tail\[2:0], </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">3</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$reconstructed_is_tail} </span><span class="tlx_comments">/* circular &lt;&lt; */</span><span class="tlx_logic">;
               {</span><span class="tlx_structure">/entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$$push} = {4{$push}} &amp; </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$prev_entry_was_tail;
               </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
                  </span><span class="tlx_comments">// Replaced with optimized versions above:
                  // $prev_entry_was_tail = /entry[(entry+(m4_depth)-1)%(m4_depth)]&gt;&gt;1$reconstructed_is_tail;
                  // $push = |stall3$push &amp;&amp; $prev_entry_was_tail;
                  </span><span class="tlx_logic">$valid = (&gt;&gt;1$reconstructed_valid &amp;&amp; ! </span><span class="tlx_structure">/ring_stop|bp0/entry</span><span class="tlx_logic">&gt;&gt;0$pop) || $push;
                  $is_tail = </span><span class="tlx_structure">|stall3</span><span class="tlx_logic">$accepted ? $prev_entry_was_tail  </span><span class="tlx_comments">// shift tail
                                                  </span><span class="tlx_logic">: &gt;&gt;1$reconstructed_is_tail;  </span><span class="tlx_comments">// retain tail
                  </span><span class="tlx_logic">$state = </span><span class="tlx_structure">|stall3</span><span class="tlx_logic">$reset ? 1'b0
                                             : $valid &amp;&amp; ! (</span><span class="tlx_structure">|stall3</span><span class="tlx_logic">$two_valid &amp;&amp; $is_tail);
            </span><span class="tlx_staging">@2
               </span><span class="tlx_logic">$empty = ! $two_valid &amp;&amp; ! $valid_count[0];
               $full = ($valid_count == full_mark_25);  </span><span class="tlx_comments">// Could optimize for power-of-two depth.
            </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
               </span><span class="tlx_staging">@2
                  </span><span class="tlx_logic">$prev_entry_state = </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">(entry+(4)-1)%(4)</span><span class="tlx_structure">]</span><span class="tlx_logic">$state;
                  $next_entry_state = </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">(entry+1)%(4)</span><span class="tlx_structure">]</span><span class="tlx_logic">$state;
                  $reconstructed_is_tail = (  </span><span class="tlx_structure">/ring_stop|stall3</span><span class="tlx_logic">$two_valid &amp;&amp; (!$state &amp;&amp; $prev_entry_state)) ||
                                           (! </span><span class="tlx_structure">/ring_stop|stall3</span><span class="tlx_logic">$two_valid &amp;&amp; (!$next_entry_state &amp;&amp; $state)) ||
                                           (</span><span class="tlx_structure">|stall3</span><span class="tlx_logic">$empty &amp;&amp; (entry == 0));  </span><span class="tlx_comments">// need a tail when empty for push
                  </span><span class="tlx_logic">$is_head = $state &amp;&amp; ! $prev_entry_state;
                  $reconstructed_valid = $state || (</span><span class="tlx_structure">/ring_stop|stall3</span><span class="tlx_logic">$two_valid &amp;&amp; $prev_entry_state);
            </span><span class="tlx_comments">// Write data
         </span><span class="tlx_structure">|stall3
            </span><span class="tlx_staging">@1
               </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
                     </span><span class="tlx_comments">//?$push
                     //   $aNY = |m4_in_pipe['']m4_trans$ANY;
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/entry</span><span class="tlx_logic">$push ? </span><span class="tlx_structure">/ring_stop|stall3/trans</span><span class="tlx_logic">$ANY : &gt;&gt;1$ANY </span><span class="tlx_comments">/* RETAIN */</span><span class="tlx_logic">;
            </span><span class="tlx_comments">// Read data
         </span><span class="tlx_structure">|bp0
            </span><span class="tlx_staging">@1
                  </span><span class="tlx_comments">//$pop  = ! /m4_top|m4_in_pipe&gt;&gt;m4_align(m4_in_at + 1, m4_out_at)$empty &amp;&amp; ! $blocked;
               </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
                  </span><span class="tlx_logic">$is_head = </span><span class="tlx_structure">/ring_stop|stall3/entry</span><span class="tlx_logic">&gt;&gt;1$is_head;
                  $pop  = $is_head &amp;&amp; ! </span><span class="tlx_structure">|bp0</span><span class="tlx_logic">$blocked;
                  </span><span class="tlx_structure">/read_masked
                     /trans
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/entry</span><span class="tlx_logic">$is_head ? </span><span class="tlx_structure">/ring_stop|stall3/entry/trans</span><span class="tlx_logic">&gt;&gt;1$ANY </span><span class="tlx_comments">/* $aNY */ </span><span class="tlx_logic">: '0;
                  </span><span class="tlx_structure">/accum
                     /trans
                        </span><span class="tlx_logic">$ANY = ((entry == 0) ? '0 : </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">(entry+(4)-1)%(4)</span><span class="tlx_structure">]/accum/trans</span><span class="tlx_logic">$ANY) |
                                   </span><span class="tlx_structure">/entry/read_masked/trans</span><span class="tlx_logic">$ANY;
               </span><span class="tlx_structure">/head
                  </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">|bp0</span><span class="tlx_logic">$avail;
                  </span><span class="tlx_validity">?$avail
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/ring_stop|bp0/entry[</span><span class="tlx_logic">(4)-1</span><span class="tlx_structure">]/accum/trans</span><span class="tlx_logic">$ANY;
         </span><span class="tlx_comments">// Bypass
         </span><span class="tlx_structure">|bp0
            </span><span class="tlx_staging">@1
               </span><span class="tlx_comments">// Available output.  Sometimes it's necessary to know what would be coming to determined
               // if it's blocked.  This can be used externally in that case.
               </span><span class="tlx_structure">/fifo_head
                  </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">|bp0</span><span class="tlx_logic">$avail;
                  </span><span class="tlx_validity">?$avail
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/ring_stop|stall3</span><span class="tlx_logic">&gt;&gt;0$would_bypass
                                     ? </span><span class="tlx_structure">/ring_stop|stall3/trans</span><span class="tlx_logic">&gt;&gt;0$ANY
                                     : </span><span class="tlx_structure">|bp0/head/trans</span><span class="tlx_logic">$ANY;
               $avail = ! </span><span class="tlx_structure">/ring_stop|stall3</span><span class="tlx_logic">&gt;&gt;0$would_bypass || </span><span class="tlx_structure">/ring_stop|stall3</span><span class="tlx_logic">&gt;&gt;0$avail;
               $trans_valid = $avail &amp;&amp; ! $blocked;
               </span><span class="tlx_validity">?$trans_valid
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">|bp0/fifo_head/trans</span><span class="tlx_logic">$ANY;
               
               </span><span class="tlx_comments">// Deliver reset.
               </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|stall3</span><span class="tlx_logic">&gt;&gt;0$reset_in;
      
         
         
         
         
         
         </span><span class="tlx_comments">/* Alternate code for pointer indexing.  Replaces $ANY expression above.
      
         // Hierarchy
         |m4_in_pipe
            /entry2[(m4_depth)-1:0]
      
         // Head/Tail ptrs.
         |m4_in_pipe
            @m4_in_at
               &gt;&gt;1$WrPtr[m4_ptr_width-1:0] =
                   $reset       ? '0 :
                   $trans_valid ? ($WrPtr == (m4_depth - 1))
                                    ? '0
                                    : $WrPtr + {{(m4_ptr_width-1){1'b0}}, 1'b1} :
                                  $RETAIN;
         |m4_out_pipe
            @m4_out_at
               &gt;&gt;1$RdPtr[m4_ptr_width-1:0] =
                   /m4_top|m4_in_pipe&gt;&gt;m4_reverse_bypass_align$reset
                                ? '0 :
                   $trans_valid ? ($RdPtr == (m4_depth - 1))
                                    ? '0
                                    : $RdPtr + {{(m4_ptr_width-1){1'b0}}, 1'b1} :
                                  $RETAIN;
         // Write FIFO
         |m4_in_pipe
            @m4_in_at
               $dummy = '0;
               ?$trans_valid
                  // This doesn't work because SV complains for FIFOs in replicated context that
                  // there are multiple procedures that assign the signals.
                  // Array writes can be done in an SV module.
                  // The only long-term resolutions are support for module generation and use
                  // signals declared within for loops with cross-hierarchy references in SV.
                  // TODO: To make a simulation-efficient FIFO, use DesignWare.
                  {/entry2[$WrPtr]$$ANY} = $ANY;
         // Read FIFO
         |m4_out_pipe
            @m4_out_at
               /read2
                  $trans_valid = |m4_out_pipe$trans_valid;
                  ?$trans_valid
                     $ANY = /m4_top|m4_in_pipe/entry2[|m4_out_pipe$RdPtr]&gt;&gt;m4_reverse_bypass_align$ANY;
                  `BOGUS_USE($dummy)
               ?$trans_valid
                  $ANY = /read2$ANY;
         */
      
  
    
    
    
  

      </span><span class="tlx_structure">\end_source
      </span><span class="tlx_comments">//m4+simple_bypass_fifo_v2(/ring_stop, |stall3, @1, |bp0, @1, 4, 100, /trans)
      </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 416   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+bp_pipeline(/ring_stop, |bp, 0, 3, /trans)
         
         </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 342   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp0, @1'], [' |bp1, @1'], )
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp0, @1'], )
                  // Avail/Blocked Input:
                  </span><span class="tlx_structure">|bp0
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">$reset_in = $reset;
                        `BOGUS_USE($accepted $reset_in)
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp0, @1))), m4_quote(m4_shift(_resets)))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
               \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp1, @1'])
                  // Avail/Blocked Output:
                  </span><span class="tlx_structure">|bp1
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp1, @1))))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
            \end_source
            |bp1
               </span><span class="tlx_staging">@0
                  </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|bp0</span><span class="tlx_logic">&gt;&gt;1$reset_in;
                  
                  $avail = $reset ? 1'b0 :
                                    (&gt;&gt;1$avail &amp;&amp; &gt;&gt;1$blocked) ||  </span><span class="tlx_comments">// Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    </span><span class="tlx_structure">/ring_stop|bp0</span><span class="tlx_logic">&gt;&gt;1$avail; </span><span class="tlx_comments">// Incoming available
                  //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
               </span><span class="tlx_staging">@0
                  </span><span class="tlx_validity">?$avail  </span><span class="tlx_comments">// Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                           // place of recirculation.
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$ANY =
                           </span><span class="tlx_structure">|bp1</span><span class="tlx_logic">&gt;&gt;1$recirc ? &gt;&gt;1$ANY
                                                : </span><span class="tlx_structure">/ring_stop|bp0/trans</span><span class="tlx_logic">&gt;&gt;1$ANY;
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$recirc = $avail &amp;&amp; $blocked;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
            </span><span class="tlx_structure">|bp0
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|bp1</span><span class="tlx_logic">&gt;&gt;0$recirc;
                  </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         </span><span class="tlx_structure">\end_source
         
         \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 342   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp1, @1'], [' |bp2, @1'], )
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp1, @1'], )
                  // Avail/Blocked Input:
                  </span><span class="tlx_structure">|bp1
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">$reset_in = $reset;
                        `BOGUS_USE($accepted $reset_in)
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp1, @1))), m4_quote(m4_shift(_resets)))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
               \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp2, @1'])
                  // Avail/Blocked Output:
                  </span><span class="tlx_structure">|bp2
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp2, @1))))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
            \end_source
            |bp2
               </span><span class="tlx_staging">@0
                  </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|bp1</span><span class="tlx_logic">&gt;&gt;1$reset_in;
                  
                  $avail = $reset ? 1'b0 :
                                    (&gt;&gt;1$avail &amp;&amp; &gt;&gt;1$blocked) ||  </span><span class="tlx_comments">// Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    </span><span class="tlx_structure">/ring_stop|bp1</span><span class="tlx_logic">&gt;&gt;1$avail; </span><span class="tlx_comments">// Incoming available
                  //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
               </span><span class="tlx_staging">@0
                  </span><span class="tlx_validity">?$avail  </span><span class="tlx_comments">// Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                           // place of recirculation.
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$ANY =
                           </span><span class="tlx_structure">|bp2</span><span class="tlx_logic">&gt;&gt;1$recirc ? &gt;&gt;1$ANY
                                                : </span><span class="tlx_structure">/ring_stop|bp1/trans</span><span class="tlx_logic">&gt;&gt;1$ANY;
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$recirc = $avail &amp;&amp; $blocked;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
            </span><span class="tlx_structure">|bp1
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|bp2</span><span class="tlx_logic">&gt;&gt;0$recirc;
                  </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         </span><span class="tlx_structure">\end_source
         
         \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 342   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp2, @1'], [' |bp3, @1'], )
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp2, @1'], )
                  // Avail/Blocked Input:
                  </span><span class="tlx_structure">|bp2
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">$reset_in = $reset;
                        `BOGUS_USE($accepted $reset_in)
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp2, @1))), m4_quote(m4_shift(_resets)))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
               \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp3, @1'])
                  // Avail/Blocked Output:
                  </span><span class="tlx_structure">|bp3
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp3, @1))))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
            \end_source
            |bp3
               </span><span class="tlx_staging">@0
                  </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|bp2</span><span class="tlx_logic">&gt;&gt;1$reset_in;
                  
                  $avail = $reset ? 1'b0 :
                                    (&gt;&gt;1$avail &amp;&amp; &gt;&gt;1$blocked) ||  </span><span class="tlx_comments">// Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    </span><span class="tlx_structure">/ring_stop|bp2</span><span class="tlx_logic">&gt;&gt;1$avail; </span><span class="tlx_comments">// Incoming available
                  //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
               </span><span class="tlx_staging">@0
                  </span><span class="tlx_validity">?$avail  </span><span class="tlx_comments">// Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                           // place of recirculation.
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$ANY =
                           </span><span class="tlx_structure">|bp3</span><span class="tlx_logic">&gt;&gt;1$recirc ? &gt;&gt;1$ANY
                                                : </span><span class="tlx_structure">/ring_stop|bp2/trans</span><span class="tlx_logic">&gt;&gt;1$ANY;
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$recirc = $avail &amp;&amp; $blocked;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
            </span><span class="tlx_structure">|bp2
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|bp3</span><span class="tlx_logic">&gt;&gt;0$recirc;
                  </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         </span><span class="tlx_structure">\end_source
         
      \end_source
      |bp3
         </span><span class="tlx_staging">@1
            </span><span class="tlx_logic">$local = </span><span class="tlx_structure">/trans</span><span class="tlx_logic">$dest == #ring_stop;
      </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 179   </span><span class="tlx_comments">// Instantiated from top.tlv, 71 as: m4+opportunistic_flow(/ring_stop, |bp3, @1, |bypass, @1, $local, |ring_in, @1, /trans)
         </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 180 as: m4+flow_interface(/ring_stop, [' |bp3, @1'], [' |bypass, @1, |ring_in, @1'], )
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp3, @1'], )
               // Avail/Blocked Input:
               </span><span class="tlx_structure">|bp3
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">$reset_in = $reset;
                     `BOGUS_USE($accepted $reset_in)
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 71 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp3, @1))), m4_quote(m4_shift(_resets)))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
            \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bypass, @1, |ring_in, @1'])
               // Avail/Blocked Output:
               </span><span class="tlx_structure">|bypass
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 71 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bypass, @1, |ring_in, @1))))
                  // Avail/Blocked Output:
                  </span><span class="tlx_structure">|ring_in
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 71 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift(|ring_in,@1))))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
               
            \end_source
         \end_source
         
         |bypass
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">/ring_stop|bp3</span><span class="tlx_logic">&gt;&gt;0$avail &amp;&amp;
                        </span><span class="tlx_structure">/ring_stop|bp3</span><span class="tlx_logic">&gt;&gt;0$local;
               $reset = </span><span class="tlx_structure">/ring_stop|bp3</span><span class="tlx_logic">&gt;&gt;0$reset_in;
               </span><span class="tlx_validity">?$avail
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/ring_stop|bp3/trans</span><span class="tlx_logic">&gt;&gt;0$ANY;
         </span><span class="tlx_structure">|ring_in
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">/ring_stop|bp3</span><span class="tlx_logic">&gt;&gt;0$avail &amp;&amp;
                        (! </span><span class="tlx_structure">/ring_stop|bp3</span><span class="tlx_logic">&gt;&gt;0$local ||
                         </span><span class="tlx_structure">/ring_stop|bypass</span><span class="tlx_logic">&gt;&gt;0$blocked);
               $reset = </span><span class="tlx_structure">/ring_stop|bp3</span><span class="tlx_logic">&gt;&gt;0$reset_in;
               </span><span class="tlx_validity">?$avail
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/ring_stop|bp3/trans</span><span class="tlx_logic">&gt;&gt;0$ANY;
         </span><span class="tlx_structure">|bp3
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$blocked = (</span><span class="tlx_structure">/ring_stop|ring_in</span><span class="tlx_logic">&gt;&gt;0$blocked ||
                           ! $local) &amp;&amp;
                          </span><span class="tlx_structure">/ring_stop|bypass</span><span class="tlx_logic">&gt;&gt;0$blocked;
         
      </span><span class="tlx_structure">\end_source
   \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 1017   </span><span class="tlx_comments">// Instantiated from top.tlv, 72 as: m4+simple_ring(/ring_stop, |ring_in, @1, |ring_out, @1, /top&lt;&gt;0$reset, |rg, /trans)
      
      
      
      
      
      
      // Logic
      </span><span class="tlx_structure">/ring_stop[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
         \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 1026 as: m4+flow_interface(/ring_stop, [' |ring_in, @1'], [' |ring_out, @1'], /top&lt;&gt;0$reset)
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |ring_in, @1'], /top&lt;&gt;0$reset)
               // Avail/Blocked Input:
               </span><span class="tlx_structure">|ring_in
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">$reset_in =  </span><span class="tlx_structure">/top</span><span class="tlx_logic">&lt;&gt;0$reset;
                     `BOGUS_USE($accepted $reset_in)
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 72 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_in, @1))), m4_quote(m4_shift(_resets)))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
            \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |ring_out, @1'])
               // Avail/Blocked Output:
               </span><span class="tlx_structure">|ring_out
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 72 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_out, @1))))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
         \end_source
         |default
            </span><span class="tlx_staging">@0
               </span><span class="tlx_structure">\SV_plus
                  </span><span class="tlx_logic">int prev_hop = (ring_stop + 4 - 1) % 4;
         </span><span class="tlx_structure">|ring_in
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|rg</span><span class="tlx_logic">&lt;&gt;0$passed_on;
         </span><span class="tlx_structure">|rg
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$passed_on = </span><span class="tlx_structure">/ring_stop[</span><span class="tlx_logic">prev_hop</span><span class="tlx_structure">]|rg</span><span class="tlx_logic">&gt;&gt;1$pass_on;
               $valid = ! </span><span class="tlx_structure">/ring_stop|ring_in</span><span class="tlx_logic">&lt;&gt;0$reset_in &amp;&amp;
                        ($passed_on || </span><span class="tlx_structure">/ring_stop|ring_in</span><span class="tlx_logic">&lt;&gt;0$avail);
               $pass_on = $valid &amp;&amp; ! </span><span class="tlx_structure">/ring_stop|ring_out</span><span class="tlx_logic">&gt;&gt;0$trans_valid;
               $dest[1:0] =
                  $passed_on
                     ? </span><span class="tlx_structure">/ring_stop[</span><span class="tlx_logic">prev_hop</span><span class="tlx_structure">]|rg</span><span class="tlx_logic">&gt;&gt;1$dest
                     : </span><span class="tlx_structure">/ring_stop|ring_in/trans</span><span class="tlx_logic">&lt;&gt;0$dest;
            </span><span class="tlx_staging">@1
               </span><span class="tlx_validity">?$valid
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY =
                       </span><span class="tlx_structure">|rg</span><span class="tlx_logic">$passed_on
                           ? </span><span class="tlx_structure">/ring_stop[</span><span class="tlx_logic">prev_hop</span><span class="tlx_structure">]|rg/trans</span><span class="tlx_logic">&gt;&gt;1$ANY
                           : </span><span class="tlx_structure">/ring_stop|ring_in/trans</span><span class="tlx_logic">&lt;&gt;0$ANY;
         </span><span class="tlx_structure">|ring_out
            </span><span class="tlx_comments">// Ring out
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">/ring_stop|rg</span><span class="tlx_logic">&gt;&gt;0$valid &amp;&amp; (</span><span class="tlx_structure">/ring_stop|rg</span><span class="tlx_logic">&gt;&gt;0$dest == #ring_stop);
               </span><span class="tlx_comments">//$blocked = 1'b0;
               </span><span class="tlx_logic">$trans_valid = $avail; </span><span class="tlx_comments">// &amp;&amp; ! $blocked;
               </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|ring_in</span><span class="tlx_logic">&gt;&gt;0$reset_in;
            </span><span class="tlx_validity">?$trans_valid
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/ring_stop|rg/trans</span><span class="tlx_logic">&gt;&gt;0$ANY;
      
      
      
      
      
   </span><span class="tlx_structure">\end_source
   
   /ring_stop[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
      \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 150   </span><span class="tlx_comments">// Instantiated from top.tlv, 75 as: m4+arb2(/ring_stop, |ring_out, @4, |bypass, @1, |arb_out, @1, /trans)
         </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 151 as: m4+flow_interface(/ring_stop, [' |ring_out, @4, |bypass, @1'], [' |arb_out, @1'], )
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |ring_out, @4, |bypass, @1'], )
               // Avail/Blocked Input:
               </span><span class="tlx_structure">|ring_out
                  </span><span class="tlx_staging">@4
                     </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">$reset_in = $reset;
                     `BOGUS_USE($accepted $reset_in)
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 75 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_out, @4, |bypass, @1))), m4_quote(m4_shift(_resets)))
                  // Avail/Blocked Input:
                  </span><span class="tlx_structure">|bypass
                     </span><span class="tlx_staging">@1
                        </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">$reset_in = $reset;
                        `BOGUS_USE($accepted $reset_in)
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 75 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift(|bypass,@1))), m4_quote(m4_shift(_resets)))
                     
                  </span><span class="tlx_structure">\end_source
                  
               \end_source
               
            \end_source
            \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |arb_out, @1'])
               // Avail/Blocked Output:
               </span><span class="tlx_structure">|arb_out
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 75 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |arb_out, @1))))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
         \end_source
         
         </span><span class="tlx_comments">// In1 is blocked if output is blocked.
         </span><span class="tlx_structure">|ring_out
            </span><span class="tlx_staging">@4
               </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|arb_out</span><span class="tlx_logic">&gt;&gt;-3$blocked;
         </span><span class="tlx_comments">// In2 is blocked if output is blocked or in1 is available.
         </span><span class="tlx_structure">|bypass
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|arb_out</span><span class="tlx_logic">&gt;&gt;0$blocked ||
                          </span><span class="tlx_structure">/ring_stop|ring_out</span><span class="tlx_logic">&gt;&gt;3$avail;
         </span><span class="tlx_comments">// Output comes from in1 if available, otherwise, in2.
         </span><span class="tlx_structure">|arb_out
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|ring_out</span><span class="tlx_logic">&gt;&gt;3$reset_in;
               </span><span class="tlx_comments">// Output is available if either input is available.
               </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">/ring_stop|ring_out</span><span class="tlx_logic">&gt;&gt;3$avail ||
                        </span><span class="tlx_structure">/ring_stop|bypass</span><span class="tlx_logic">&gt;&gt;0$avail;
               </span><span class="tlx_validity">?$avail
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/ring_stop|ring_out</span><span class="tlx_logic">&gt;&gt;3$avail ? </span><span class="tlx_structure">/ring_stop|ring_out/trans</span><span class="tlx_logic">&gt;&gt;3$ANY :
                                                                                </span><span class="tlx_structure">/ring_stop|bypass/trans</span><span class="tlx_logic">&gt;&gt;0$ANY;
         
      </span><span class="tlx_structure">\end_source
      </span><span class="tlx_comments">// FIFO2
      // To use BaseJump STL, this line:
      //m4+simple_bypass_fifo_v2(/ring_stop, |arb_out, @1, |fifo2_out, @1, 4, 100, /trans)        
      // Becomes:
      //----------------
      </span><span class="tlx_structure">|arb_out
         </span><span class="tlx_staging">@1
            </span><span class="tlx_structure">\SV_plus
               </span><span class="tlx_logic">bsg_fifo_1r1w_small #(.width_p(100)) my_fifo(
                  *clk, $reset,
                  $avail, $$ready, </span><span class="tlx_structure">/trans</span><span class="tlx_logic">$ANY,
                  </span><span class="tlx_structure">/ring_stop|fifo2_out</span><span class="tlx_logic">&lt;&gt;0$$avail, </span><span class="tlx_structure">/ring_stop|fifo2_out/trans</span><span class="tlx_logic">&lt;&gt;0$$ANY, </span><span class="tlx_structure">/ring_stop|fifo2_out</span><span class="tlx_logic">&lt;&gt;0$accepted
               );
            $blocked = ! $ready;
      </span><span class="tlx_comments">//----------------
   
   
   //m4+trans()
   
   
   // Testbench
   </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 1305   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+router_testbench(/top, /ring_stop, |stall0, @1, |fifo2_out, @1, /trans, /top&lt;&gt;0$reset)
        // Otherwise we can have a cyclic reset loop through flow.
      </span><span class="tlx_structure">/ring_stop[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
         </span><span class="tlx_comments">// Define flow interface. Note that router ins are tb outs and outs are ins.
         </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 1309 as: m4+flow_interface(/ring_stop, [' |fifo2_out, @1'], [' |stall0, @1'], /top&lt;&gt;0$reset)
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |fifo2_out, @1'], /top&lt;&gt;0$reset)
               // Avail/Blocked Input:
               </span><span class="tlx_structure">|fifo2_out
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">$reset_in =  </span><span class="tlx_structure">/top</span><span class="tlx_logic">&lt;&gt;0$reset;
                     `BOGUS_USE($accepted $reset_in)
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |fifo2_out, @1))), m4_quote(m4_shift(_resets)))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
            \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall0, @1'])
               // Avail/Blocked Output:
               </span><span class="tlx_structure">|stall0
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall0, @1))))
                  
               </span><span class="tlx_structure">\end_source
               
            \end_source
         \end_source
      
      
      
   
      /tb
         |count
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$CycCount[15:0] &lt;= </span><span class="tlx_structure">/top/ring_stop[</span><span class="tlx_logic">0</span><span class="tlx_structure">]|stall0</span><span class="tlx_logic">&gt;&gt;1$reset
                                     ? 16'b0 :
                                       $CycCount + 1;
               </span><span class="tlx_structure">\SV_plus
                  </span><span class="tlx_logic">always_ff @(posedge clk) begin
                     \$display(&quot;Cycle: %0d&quot;, $CycCount);
                  end
         </span><span class="tlx_structure">/ring_stop[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            </span><span class="tlx_comments">// STIMULUS
            </span><span class="tlx_structure">|send
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_comments">// Generate a transaction to inject sometimes (if needed)
                  </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|receive2</span><span class="tlx_logic">&gt;&gt;0$reset;
                  $valid_in = </span><span class="tlx_structure">/tb|count</span><span class="tlx_logic">&lt;&gt;0$CycCount == 3;
                  </span><span class="tlx_validity">?$valid_in
                     </span><span class="tlx_structure">/gen_trans
                        </span><span class="tlx_logic">$cyc_cnt[15:0] = </span><span class="tlx_structure">/tb|count</span><span class="tlx_logic">&lt;&gt;0$CycCount;
                        $response_debug = 1'b0;  </span><span class="tlx_comments">// Not a response (for debug)
                        </span><span class="tlx_logic">$sender[1:0] = #ring_stop;
                        </span><span class="tlx_comments">//m4_rand($size, M4_PACKET_SIZE-1, 0, #m4_port) // unused
                        </span><span class="tlx_logic">$dest_tmp[1:0] = *RW_rand_vect[(0 + (ring_stop)) % 257 +: 2];
                        $dest[1:0] = $dest_tmp % 4;
                        </span><span class="tlx_comments">//$dest[M4_['']M4_PORT['']_INDEX_RANGE] = #m4_port;
                        //$packet_valid = #m4_port == 0 ? 1'b1 : 1'b0; // valid for only first port - unused
                  </span><span class="tlx_logic">$avail = $valid_in || </span><span class="tlx_structure">/ring_stop|receive2</span><span class="tlx_logic">&gt;&gt;0$valid_request;
                  </span><span class="tlx_validity">?$avail
                     </span><span class="tlx_structure">/trans_out
                        </span><span class="tlx_comments">// Loopback requests as responses or use gen_trans.
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/ring_stop|receive2</span><span class="tlx_logic">&gt;&gt;0$valid_request
                                    ? </span><span class="tlx_structure">/ring_stop|receive2/trans</span><span class="tlx_logic">&gt;&gt;0$ANY :
                                      </span><span class="tlx_structure">|send/gen_trans</span><span class="tlx_logic">$ANY;
                        
                        </span><span class="tlx_structure">\SV_plus
                           </span><span class="tlx_logic">always_ff @(posedge clk) begin
                              if (! </span><span class="tlx_structure">|send</span><span class="tlx_logic">$reset &amp;&amp; ! *reset &amp;&amp; </span><span class="tlx_structure">/top/ring_stop|stall0</span><span class="tlx_logic">&lt;&gt;0$accepted) begin
                                 \$display(&quot;\|send[%0d]&quot;, #ring_stop);
                                 \$display(&quot;Sender: %0d, Orig. Cyc: %0d, Dest: %0d, Resp: %0d&quot;, $sender, $cyc_cnt, $dest, $response_debug);
                              end
                           end
            </span><span class="tlx_comments">// Hook router out to |receive1 and determine transaction response routing (within the transaction).
            </span><span class="tlx_structure">|receive1
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$avail = </span><span class="tlx_structure">/top/ring_stop|fifo2_out</span><span class="tlx_logic">&lt;&gt;0$avail;
                  $reset = </span><span class="tlx_structure">/top/ring_stop|fifo2_out</span><span class="tlx_logic">&lt;&gt;0$reset_in;
                  </span><span class="tlx_validity">?$accepted
                     </span><span class="tlx_structure">/trans
                        </span><span class="tlx_logic">$response_debug = 1'b1; </span><span class="tlx_comments">// Turn this around as a response.
                        </span><span class="tlx_logic">$request = $sender != #ring_stop;  </span><span class="tlx_comments">// Arrived as request?
                        </span><span class="tlx_logic">$response = $sender == #ring_stop; </span><span class="tlx_comments">// Arrived as response?
                        </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top/ring_stop|fifo2_out/trans</span><span class="tlx_logic">&lt;&gt;0$ANY;
                        $dest[1:0] = $request ? $sender : $dest;
            </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 342   </span><span class="tlx_comments">// Instantiated from top.tlv, 1368 as: m4+bp_stage(/ring_stop, |receive1, @1, |receive2, @1, /trans)
               
               
               
               
               
               
               </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 114   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |receive1, @1'], [' |receive2, @1'], )
                  </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |receive1, @1'], )
                     // Avail/Blocked Input:
                     </span><span class="tlx_structure">|receive1
                        </span><span class="tlx_staging">@1
                           </span><span class="tlx_logic">$accepted = $avail &amp;&amp; ! $blocked;  </span><span class="tlx_comments">// provided for optional upstream use.
                           </span><span class="tlx_logic">$reset_in = $reset;
                           `BOGUS_USE($accepted $reset_in)
                     </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 119   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |receive1, @1))), m4_quote(m4_shift(_resets)))
                        
                     </span><span class="tlx_structure">\end_source
                     
                  \end_source
                  \source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |receive2, @1'])
                     // Avail/Blocked Output:
                     </span><span class="tlx_structure">|receive2
                        </span><span class="tlx_staging">@1
                           </span><span class="tlx_logic">`BOGUS_USE($reset) </span><span class="tlx_comments">// Output pipes must provide $reset.
                     </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv 129   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |receive2, @1))))
                        
                     </span><span class="tlx_structure">\end_source
                     
                  \end_source
               \end_source
               |receive2
                  </span><span class="tlx_staging">@0
                     </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/ring_stop|receive1</span><span class="tlx_logic">&gt;&gt;1$reset_in;
                     
                     $avail = $reset ? 1'b0 :
                                       (&gt;&gt;1$avail &amp;&amp; &gt;&gt;1$blocked) ||  </span><span class="tlx_comments">// Recirc'ed or
                                       // Above is recomputation of $recirc to avoid a flop.
                                       // For SELF, its in the same stage, and is redundant computation.
                                       </span><span class="tlx_structure">/ring_stop|receive1</span><span class="tlx_logic">&gt;&gt;1$avail; </span><span class="tlx_comments">// Incoming available
                     //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
                  </span><span class="tlx_staging">@0
                     </span><span class="tlx_validity">?$avail  </span><span class="tlx_comments">// Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                              // place of recirculation.
                        </span><span class="tlx_structure">/trans
                           </span><span class="tlx_logic">$ANY =
                              </span><span class="tlx_structure">|receive2</span><span class="tlx_logic">&gt;&gt;1$recirc ? &gt;&gt;1$ANY
                                                   : </span><span class="tlx_structure">/ring_stop|receive1/trans</span><span class="tlx_logic">&gt;&gt;1$ANY;
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$recirc = $avail &amp;&amp; $blocked;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
               </span><span class="tlx_structure">|receive1
                  </span><span class="tlx_staging">@1
                     </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/ring_stop|receive2</span><span class="tlx_logic">&gt;&gt;0$recirc;
                     </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
               
               
               
               
               
               
            </span><span class="tlx_structure">\end_source
            </span><span class="tlx_comments">// A one-cycle backpressured stage to avoid 0-cycle loopback.
            </span><span class="tlx_structure">|receive2
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$valid_request = $accepted &amp;&amp; </span><span class="tlx_structure">/trans</span><span class="tlx_logic">$request;
                  $valid_response = $accepted &amp;&amp; </span><span class="tlx_structure">/trans</span><span class="tlx_logic">$response;
                  </span><span class="tlx_comments">// Block requests that cannot loopback a response .
                  </span><span class="tlx_logic">$blocked = $valid_request &amp;&amp; </span><span class="tlx_structure">/top/ring_stop|stall0</span><span class="tlx_logic">&gt;&gt;0$blocked;
                  $accepted = $avail &amp;&amp; ! $blocked;
                  $generated_request =   </span><span class="tlx_structure">/top/ring_stop|stall0</span><span class="tlx_logic">&gt;&gt;0$accepted &amp;&amp;
                                       ! </span><span class="tlx_structure">/top/ring_stop|stall0/trans</span><span class="tlx_logic">&gt;&gt;0$response_debug;
                  $OutstandingPackets[16-1:0] &lt;=
                       $reset ? '0 :
                         ($OutstandingPackets +
                          ($generated_request ? 16'b1 : '0) -
                          ($valid_response ? 16'b1 : '0)
                         );
            </span><span class="tlx_structure">|passed  </span><span class="tlx_comments">// Aligned to |receive2, but given a new pipeline name to provide a cleaner interface for this $passed output.
               </span><span class="tlx_staging">@1
                  </span><span class="tlx_logic">$passed = ! </span><span class="tlx_structure">/ring_stop|receive2</span><span class="tlx_logic">&lt;&gt;0$reset &amp;&amp; </span><span class="tlx_structure">/ring_stop|receive2</span><span class="tlx_logic">&lt;&gt;0$OutstandingPackets == '0 &amp;&amp; </span><span class="tlx_structure">/tb|count</span><span class="tlx_logic">&gt;&gt;0$CycCount &gt; 12;
      </span><span class="tlx_comments">// Connect with DUT.
      </span><span class="tlx_structure">/ring_stop[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         |stall0
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$avail = ! $reset &amp;&amp; </span><span class="tlx_structure">/top/tb/ring_stop|send</span><span class="tlx_logic">&lt;&gt;0$avail;
               </span><span class="tlx_validity">?$avail
                  </span><span class="tlx_structure">/trans
                     </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top/tb/ring_stop|send/trans_out</span><span class="tlx_logic">&lt;&gt;0$ANY;
               $reset = </span><span class="tlx_structure">/top/tb/ring_stop|receive2</span><span class="tlx_logic">&gt;&gt;0$reset;
         </span><span class="tlx_structure">|fifo2_out
            </span><span class="tlx_staging">@1
               </span><span class="tlx_logic">$blocked = </span><span class="tlx_structure">/top/tb/ring_stop|receive1</span><span class="tlx_logic">&lt;&gt;0$blocked;
            </span><span class="tlx_structure">/trans
      
      
   \end_source
   
   
   </span><span class="tlx_comments">// Simulation control.
   </span><span class="tlx_logic">*passed = &amp; </span><span class="tlx_structure">/top/tb/ring_stop[</span><span class="tlx_logic">*</span><span class="tlx_structure">]|passed</span><span class="tlx_logic">&gt;&gt;1$passed;
   *failed = *cyc_cnt &gt; 80;
</span><span class="tlx_structure">\SV
</span><span class="tlx_untouched">endmodule 
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
/*
Copyright (c) 2018, Steve Hoover
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//m4_include_url(['http://localhost:8080/wip/viz.tlv'])
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/5a8c0387be80b2deccfcd1506299b36049e0663e/fundamentals_lib.tlv&quot;
// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflow_lib.tlv&quot;

// Include BaseJump STL FIFO files.
/* verilator lint_off CMPCONST */
/* verilator lint_off WIDTH */
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_defines.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_misc/bsg_defines.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_fifo_tracker.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_dataflow/bsg_fifo_tracker.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_circular_ptr.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_misc/bsg_circular_ptr.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_fifo_1r1w_small.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_dataflow/bsg_fifo_1r1w_small.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_mem_1r1w.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_mem/bsg_mem_1r1w.v&quot;
</span><span class="tlx_untouched">`include &quot;./sv_url_inc/bsg_mem_1r1w_synth.v&quot;  </span><span class="tlx_comments">// From: &quot;https://bitbucket.org/taylor-bsg/bsg_ip_cores/raw/0c76d71f1e06cf844f767448e4df376b112b831f/bsg_mem/bsg_mem_1r1w_synth.v&quot;
/* verilator lint_on WIDTH */
/* verilator lint_on CMPCONST */


</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */



</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   </span><span class="tlx_logic">assign L0_reset_a0 = reset;
   
   
   </span><span class="tlx_comments">// DUT
   
   </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1_RingStop </span><span class="tlx_declarations">logic L1_BP0_accepted_a1; logic L1_BP0_avail_a1; logic L1_BP0_blocked_a1; logic L1_BP0_reset_a1; logic L1_BP0_reset_in_a1; logic L1_BP0_trans_valid_a1; logic [1:0] L1_BP0_Entry_Accum_Trans_dest_a1 [(4)-1:0]; logic [1:0] L1_BP0_Entry_Accum_Trans_sender_a1 [(4)-1:0]; logic L1_BP0_FifoHead_avail_a1; logic [1:0] L1_BP0_FifoHead_Trans_dest_a1; logic [1:0] L1_BP0_FifoHead_Trans_sender_a1; logic L1_BP0_Head_avail_a1; logic [1:0] L1_BP0_Head_Trans_dest_a1; logic [1:0] L1_BP0_Head_Trans_sender_a1; logic [1:0] L1_BP0_Trans_dest_a1; logic [1:0] L1_BP0_Trans_sender_a1; logic L1_BP1_accepted_a1; logic L1_BP1_avail_a0, L1_BP1_avail_a1; logic L1_BP1_blocked_a1; logic L1_BP1_recirc_a1; logic L1_BP1_reset_a0, L1_BP1_reset_a1; logic L1_BP1_reset_in_a1; logic [1:0] L1_BP1_Trans_dest_a0, L1_BP1_Trans_dest_a1; logic [1:0] L1_BP1_Trans_sender_a0, L1_BP1_Trans_sender_a1; logic L1_BP2_accepted_a1; logic L1_BP2_avail_a0, L1_BP2_avail_a1; logic L1_BP2_blocked_a1; logic L1_BP2_recirc_a1; logic L1_BP2_reset_a0, L1_BP2_reset_a1; logic L1_BP2_reset_in_a1; logic [1:0] L1_BP2_Trans_dest_a0, L1_BP2_Trans_dest_a1; logic [1:0] L1_BP2_Trans_sender_a0, L1_BP2_Trans_sender_a1; logic L1_BP3_accepted_a1; logic L1_BP3_avail_a0, L1_BP3_avail_a1; logic L1_BP3_blocked_a1; logic L1_BP3_local_a1; logic L1_BP3_recirc_a1; logic L1_BP3_reset_a0, L1_BP3_reset_a1; logic L1_BP3_reset_in_a1; logic [1:0] L1_BP3_Trans_dest_a0, L1_BP3_Trans_dest_a1; logic [1:0] L1_BP3_Trans_sender_a0, L1_BP3_Trans_sender_a1; logic L1_BYPASS_avail_a1; logic L1_BYPASS_reset_a1; logic L1_BYPASS_Trans_cyc_cnt_a1; logic [1:0] L1_BYPASS_Trans_sender_a1; logic L1_RING_IN_avail_a1; logic L1_RING_IN_reset_a1; logic L1_RING_IN_Trans_cyc_cnt_a1; logic [1:0] L1_RING_IN_Trans_dest_a1; logic [1:0] L1_RING_IN_Trans_sender_a1; logic L1_STALL0_accepted_a1; logic L1_STALL0_blocked_a1; logic L1_STALL0_reset_in_a1; logic L1_STALL1_accepted_a1; logic L1_STALL1_avail_a1, L1_STALL1_avail_a2; logic L1_STALL1_blocked_a1, L1_STALL1_blocked_a2; logic L1_STALL1_reset_a1; logic L1_STALL1_reset_in_a1; logic [1:0] L1_STALL1_Trans_dest_a1, L1_STALL1_Trans_dest_a2; logic [1:0] L1_STALL1_Trans_sender_a1, L1_STALL1_Trans_sender_a2; logic L1_STALL2_accepted_a1; logic L1_STALL2_avail_a1, L1_STALL2_avail_a2; logic L1_STALL2_blocked_a1, L1_STALL2_blocked_a2; logic L1_STALL2_reset_a1; logic L1_STALL2_reset_in_a1; logic [1:0] L1_STALL2_Trans_dest_a1, L1_STALL2_Trans_dest_a2; logic [1:0] L1_STALL2_Trans_sender_a1, L1_STALL2_Trans_sender_a2; logic L1_STALL3_accepted_a1; logic L1_STALL3_avail_a1, L1_STALL3_avail_a2; logic L1_STALL3_blocked_a1, L1_STALL3_blocked_a2; logic L1_STALL3_bypass_a1; logic L1_STALL3_empty_a2; logic L1_STALL3_full_a2; logic L1_STALL3_grow_a1; logic L1_STALL3_out_blocked_a1; logic L1_STALL3_push_a1; logic L1_STALL3_reset_a1; logic L1_STALL3_reset_in_a1; logic L1_STALL3_shrink_a1; logic L1_STALL3_two_valid_a1, L1_STALL3_two_valid_a2; logic [$clog2((4)+1)-1:0] L1_STALL3_valid_count_a1, L1_STALL3_valid_count_a2; logic L1_STALL3_would_bypass_a1; logic [(4)-1:0] L1_STALL3_Entry_prev_entry_was_tail_a1; logic [(4)-1:0] L1_STALL3_Entry_push_a1; logic [(4)-1:0] L1_STALL3_Entry_reconstructed_is_tail_a2; logic L1_STALL3_Entry_state_a1 [(4)-1:0], L1_STALL3_Entry_state_a2 [(4)-1:0]; logic [1:0] L1_STALL3_Trans_dest_a1, L1_STALL3_Trans_dest_a2; logic [1:0] L1_STALL3_Trans_sender_a1, L1_STALL3_Trans_sender_a2; </span><span class="tlx_comments">//_/ring_stop
      </span><span class="tlx_structure">`line 512 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+stall_pipeline(/ring_stop, |stall, 0, 3, /trans)
         
         </span><span class="tlx_structure">`line 465 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall0, @1'], [' |stall1, @1'], )
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall0, @1'], )
                  // Avail/Blocked Input:
                  //_|stall0
                     //_@1
                        </span><span class="tlx_logic">assign L1_STALL0_accepted_a1 = L1e_RingStop[ring_stop].L1_STALL0_avail_a1 &amp;&amp; ! L1_STALL0_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">assign L1_STALL0_reset_in_a1 = L1e_RingStop[ring_stop].L1_STALL0_reset_a1;
                        `BOGUS_USE(L1_STALL0_accepted_a1 L1_STALL0_reset_in_a1)
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall0, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall1, @1'])
                  // Avail/Blocked Output:
                  //_|stall1
                     //_@1
                        </span><span class="tlx_logic">`BOGUS_USE(L1_STALL1_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall1, @1))))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 466 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            
            </span><span class="tlx_comments">//_|stall0
               //_@1
                  </span><span class="tlx_logic">assign L1_STALL0_blocked_a1 = L1_STALL1_blocked_a1;
            </span><span class="tlx_comments">//_|stall1
               //_@1
                  // Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  </span><span class="tlx_logic">assign L1_STALL1_reset_a1 = L1_STALL0_reset_in_a1;
                  
                  assign L1_STALL1_avail_a1 = L1_STALL1_reset_a1      ? 1'b0 :
                           L1_STALL1_blocked_a2 ? L1_STALL1_avail_a2 :
                                         L1e_RingStop[ring_stop].L1_STALL0_avail_a2;
                  </span><span class="tlx_comments">//_?$avail
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_STALL1_Trans_cyc_cnt_a1[ring_stop], L1_STALL1_Trans_dest_a1[1:0], L1_STALL1_Trans_sender_a1[1:0]} = L1_STALL1_blocked_a2 ? {RingStop_STALL1_Trans_cyc_cnt_a2[ring_stop], L1_STALL1_Trans_dest_a2, L1_STALL1_Trans_sender_a2} : {RingStop_STALL0_Trans_cyc_cnt_a2[ring_stop], L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a2, L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a2};
            
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 514 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
         `line 465 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall1, @1'], [' |stall2, @1'], )
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall1, @1'], )
                  // Avail/Blocked Input:
                  //_|stall1
                     //_@1
                        </span><span class="tlx_logic">assign L1_STALL1_accepted_a1 = L1_STALL1_avail_a1 &amp;&amp; ! L1_STALL1_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">assign L1_STALL1_reset_in_a1 = L1_STALL1_reset_a1;
                        `BOGUS_USE(L1_STALL1_accepted_a1 L1_STALL1_reset_in_a1)
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall1, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall2, @1'])
                  // Avail/Blocked Output:
                  //_|stall2
                     //_@1
                        </span><span class="tlx_logic">`BOGUS_USE(L1_STALL2_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall2, @1))))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 466 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            
            </span><span class="tlx_comments">//_|stall1
               //_@1
                  </span><span class="tlx_logic">assign L1_STALL1_blocked_a1 = L1_STALL2_blocked_a1;
            </span><span class="tlx_comments">//_|stall2
               //_@1
                  // Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  </span><span class="tlx_logic">assign L1_STALL2_reset_a1 = L1_STALL1_reset_in_a1;
                  
                  assign L1_STALL2_avail_a1 = L1_STALL2_reset_a1      ? 1'b0 :
                           L1_STALL2_blocked_a2 ? L1_STALL2_avail_a2 :
                                         L1_STALL1_avail_a2;
                  </span><span class="tlx_comments">//_?$avail
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_STALL2_Trans_cyc_cnt_a1[ring_stop], L1_STALL2_Trans_dest_a1[1:0], L1_STALL2_Trans_sender_a1[1:0]} = L1_STALL2_blocked_a2 ? {RingStop_STALL2_Trans_cyc_cnt_a2[ring_stop], L1_STALL2_Trans_dest_a2, L1_STALL2_Trans_sender_a2} : {RingStop_STALL1_Trans_cyc_cnt_a2[ring_stop], L1_STALL1_Trans_dest_a2, L1_STALL1_Trans_sender_a2};
            
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 516 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
         `line 465 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+stall_stage(/ring_stop, |stall['']m4_stage, @1, |stall['']m4_eval(m4_stage + 1), @1, /trans, )
            </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 465 as: m4+flow_interface(/ring_stop, [' |stall2, @1'], [' |stall3, @1'], )
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall2, @1'], )
                  // Avail/Blocked Input:
                  //_|stall2
                     //_@1
                        </span><span class="tlx_logic">assign L1_STALL2_accepted_a1 = L1_STALL2_avail_a1 &amp;&amp; ! L1_STALL2_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">assign L1_STALL2_reset_in_a1 = L1_STALL2_reset_a1;
                        `BOGUS_USE(L1_STALL2_accepted_a1 L1_STALL2_reset_in_a1)
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall2, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall3, @1'])
                  // Avail/Blocked Output:
                  //_|stall3
                     //_@1
                        </span><span class="tlx_logic">`BOGUS_USE(L1_STALL3_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 64 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall3, @1))))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 466 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            
            </span><span class="tlx_comments">//_|stall2
               //_@1
                  </span><span class="tlx_logic">assign L1_STALL2_blocked_a1 = L1_STALL3_blocked_a1;
            </span><span class="tlx_comments">//_|stall3
               //_@1
                  // Propagate $reset to next stage with no delay (may create timing pressure,
                  //   but similar to reverse path for $blocked).
                  </span><span class="tlx_logic">assign L1_STALL3_reset_a1 = L1_STALL2_reset_in_a1;
                  
                  assign L1_STALL3_avail_a1 = L1_STALL3_reset_a1      ? 1'b0 :
                           L1_STALL3_blocked_a2 ? L1_STALL3_avail_a2 :
                                         L1_STALL2_avail_a2;
                  </span><span class="tlx_comments">//_?$avail
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop], L1_STALL3_Trans_dest_a1[1:0], L1_STALL3_Trans_sender_a1[1:0]} = L1_STALL3_blocked_a2 ? {RingStop_STALL3_Trans_cyc_cnt_a2[ring_stop], L1_STALL3_Trans_dest_a2, L1_STALL3_Trans_sender_a2} : {RingStop_STALL2_Trans_cyc_cnt_a2[ring_stop], L1_STALL2_Trans_dest_a2, L1_STALL2_Trans_sender_a2};
            
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 518 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
         </span><span class="tlx_comments">//
      //_\end_source
      </span><span class="tlx_structure">`line 65 &quot;top.tlv&quot; 2
      `line 576 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 65 as: m4+flop_fifo_v2(/ring_stop, |stall3, @1, |bp0, @1, 4, /trans)
         </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 576 as: m4+flow_interface(/ring_stop, [' |stall3, @1'], [' |bp0, @1'], )
            </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |stall3, @1'], )
               // Avail/Blocked Input:
               //_|stall3
                  //_@1
                     </span><span class="tlx_logic">assign L1_STALL3_accepted_a1 = L1_STALL3_avail_a1 &amp;&amp; ! L1_STALL3_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">assign L1_STALL3_reset_in_a1 = L1_STALL3_reset_a1;
                     `BOGUS_USE(L1_STALL3_accepted_a1 L1_STALL3_reset_in_a1)
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 65 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall3, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp0, @1'])
               // Avail/Blocked Output:
               //_|bp0
                  //_@1
                     </span><span class="tlx_logic">`BOGUS_USE(L1_BP0_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 65 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp0, @1))))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 577 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
         
         
         
         
         </span><span class="tlx_comments">//   @0
         /*SV_plus*/
            </span><span class="tlx_logic">localparam bit [$clog2((4)+1)-1:0] full_mark_25 = 4 - 0;
         </span><span class="tlx_comments">// FIFO Instantiation
         // Hierarchy declarations
         //_|stall3
            //_/entry
         //_|bp0
            //_/entry
         //_|stall3
            //_@1
               </span><span class="tlx_logic">assign L1_STALL3_out_blocked_a1 = L1_BP0_blocked_a1;
               assign L1_STALL3_blocked_a1 = L1_STALL3_full_a2 &amp;&amp; L1_STALL3_out_blocked_a1;
               `BOGUS_USE(L1_STALL3_blocked_a1)   </span><span class="tlx_comments">// Not required to be consumed elsewhere.
               </span><span class="tlx_logic">assign L1_STALL3_would_bypass_a1 = L1_STALL3_empty_a2;
               assign L1_STALL3_bypass_a1 = L1_STALL3_would_bypass_a1 &amp;&amp; ! L1_STALL3_out_blocked_a1;
               assign L1_STALL3_push_a1 = L1_STALL3_accepted_a1 &amp;&amp; ! L1_STALL3_bypass_a1;
               assign L1_STALL3_grow_a1   =   L1_STALL3_accepted_a1 &amp;&amp;   L1_STALL3_out_blocked_a1;
               assign L1_STALL3_shrink_a1 = ! L1_STALL3_avail_a1 &amp;&amp; ! L1_STALL3_out_blocked_a1 &amp;&amp; ! L1_STALL3_empty_a2;
               assign L1_STALL3_valid_count_a1[$clog2((4)+1)-1:0] = L1_STALL3_reset_a1 ? '0
                                                           : L1_STALL3_valid_count_a2 + (
                                                                L1_STALL3_grow_a1   ? { {($clog2((4)+1)-1){1'b0}}, 1'b1} :
                                                                L1_STALL3_shrink_a1 ? '1
                                                                        : '0
                                                             );
               </span><span class="tlx_comments">// At least 2 valid entries.
               //$two_valid = | $ValidCount[m4_counter_width-1:1];
               // but logic depth minimized by taking advantage of prev count &gt;= 4.
               </span><span class="tlx_logic">assign L1_STALL3_two_valid_a1 = | L1_STALL3_valid_count_a2[$clog2((4)+1)-1:2] || | L1_STALL3_valid_count_a1[2:1];
               </span><span class="tlx_comments">// These are an optimization of the commented block below to operate on vectors, rather than bits.
               // TODO: Keep optimizing...
               </span><span class="tlx_logic">assign {L1_STALL3_Entry_prev_entry_was_tail_a1} = {L1_STALL3_Entry_reconstructed_is_tail_a2[2:0], L1_STALL3_Entry_reconstructed_is_tail_a2[3]} </span><span class="tlx_comments">/* circular &lt;&lt; */</span><span class="tlx_logic">;
               assign {L1_STALL3_Entry_push_a1} = {4{L1_STALL3_push_a1}} &amp; L1_STALL3_Entry_prev_entry_was_tail_a1;
               </span><span class="tlx_structure">for (entry = 0; entry &lt;= (4)-1; entry++) begin : L2b_STALL3_Entry </span><span class="tlx_declarations">logic L2_is_tail_a1; logic L2_valid_a1; </span><span class="tlx_comments">//_/entry
                  // Replaced with optimized versions above:
                  // $prev_entry_was_tail = /entry[(entry+(m4_depth)-1)%(m4_depth)]&gt;&gt;1$reconstructed_is_tail;
                  // $push = |stall3$push &amp;&amp; $prev_entry_was_tail;
                  </span><span class="tlx_logic">assign L2_valid_a1 = (L2c_STALL3_Entry[entry].L2_reconstructed_valid_a2 &amp;&amp; ! L2b_BP0_Entry[entry].L2_pop_a1) || L1_STALL3_Entry_push_a1[entry];
                  assign L2_is_tail_a1 = L1_STALL3_accepted_a1 ? L1_STALL3_Entry_prev_entry_was_tail_a1[entry]  </span><span class="tlx_comments">// shift tail
                                                  </span><span class="tlx_logic">: L1_STALL3_Entry_reconstructed_is_tail_a2[entry];  </span><span class="tlx_comments">// retain tail
                  </span><span class="tlx_logic">assign L1_STALL3_Entry_state_a1[entry] = L1_STALL3_reset_a1 ? 1'b0
                                             : L2_valid_a1 &amp;&amp; ! (L1_STALL3_two_valid_a1 &amp;&amp; L2_is_tail_a1); </span><span class="tlx_structure">end
            </span><span class="tlx_comments">//_@2
               </span><span class="tlx_logic">assign L1_STALL3_empty_a2 = ! L1_STALL3_two_valid_a2 &amp;&amp; ! L1_STALL3_valid_count_a2[0];
               assign L1_STALL3_full_a2 = (L1_STALL3_valid_count_a2 == full_mark_25);  </span><span class="tlx_comments">// Could optimize for power-of-two depth.
            </span><span class="tlx_structure">for (entry = 0; entry &lt;= (4)-1; entry++) begin : L2c_STALL3_Entry </span><span class="tlx_declarations">logic L2_is_head_a2; logic L2_next_entry_state_a2; logic L2_prev_entry_state_a2; logic L2_reconstructed_valid_a2; </span><span class="tlx_comments">//_/entry
               //_@2
                  </span><span class="tlx_logic">assign L2_prev_entry_state_a2 = L1_STALL3_Entry_state_a2[(entry+(4)-1)%(4)];
                  assign L2_next_entry_state_a2 = L1_STALL3_Entry_state_a2[(entry+1)%(4)];
                  assign L1_STALL3_Entry_reconstructed_is_tail_a2[entry] = (  L1_STALL3_two_valid_a2 &amp;&amp; (!L1_STALL3_Entry_state_a2[entry] &amp;&amp; L2_prev_entry_state_a2)) ||
                                           (! L1_STALL3_two_valid_a2 &amp;&amp; (!L2_next_entry_state_a2 &amp;&amp; L1_STALL3_Entry_state_a2[entry])) ||
                                           (L1_STALL3_empty_a2 &amp;&amp; (entry == 0));  </span><span class="tlx_comments">// need a tail when empty for push
                  </span><span class="tlx_logic">assign L2_is_head_a2 = L1_STALL3_Entry_state_a2[entry] &amp;&amp; ! L2_prev_entry_state_a2;
                  assign L2_reconstructed_valid_a2 = L1_STALL3_Entry_state_a2[entry] || (L1_STALL3_two_valid_a2 &amp;&amp; L2_prev_entry_state_a2); </span><span class="tlx_structure">end
            </span><span class="tlx_comments">// Write data
         //_|stall3
            //_@1
               </span><span class="tlx_structure">for (entry = 0; entry &lt;= (4)-1; entry++) begin : L2d_STALL3_Entry </span><span class="tlx_declarations">logic [1:0] L2_Trans_dest_a1, L2_Trans_dest_a2; logic [1:0] L2_Trans_sender_a1, L2_Trans_sender_a2; </span><span class="tlx_comments">//_/entry
                     //?$push
                     //   $aNY = |m4_in_pipe['']m4_trans$ANY;
                  //_/trans
                     </span><span class="tlx_logic">assign {RingStop_STALL3_Entry_Trans_cyc_cnt_a1[ring_stop][entry], L2_Trans_dest_a1[1:0], L2_Trans_sender_a1[1:0]} = L1_STALL3_Entry_push_a1[entry] ? {RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop], L1_STALL3_Trans_dest_a1[1:0], L1_STALL3_Trans_sender_a1[1:0]} : {RingStop_STALL3_Entry_Trans_cyc_cnt_a2[ring_stop][entry], L2_Trans_dest_a2[1:0], L2_Trans_sender_a2[1:0]} </span><span class="tlx_comments">/* RETAIN */</span><span class="tlx_logic">; </span><span class="tlx_structure">end
            </span><span class="tlx_comments">// Read data
         //_|bp0
            //_@1
                  //$pop  = ! /m4_top|m4_in_pipe&gt;&gt;m4_align(m4_in_at + 1, m4_out_at)$empty &amp;&amp; ! $blocked;
               </span><span class="tlx_structure">for (entry = 0; entry &lt;= (4)-1; entry++) begin : L2b_BP0_Entry </span><span class="tlx_declarations">logic L2_is_head_a1; logic L2_pop_a1; logic [1:0] L2_ReadMasked_Trans_dest_a1; logic [1:0] L2_ReadMasked_Trans_sender_a1; </span><span class="tlx_comments">//_/entry
                  </span><span class="tlx_logic">assign L2_is_head_a1 = L2c_STALL3_Entry[entry].L2_is_head_a2;
                  assign L2_pop_a1  = L2_is_head_a1 &amp;&amp; ! L1_BP0_blocked_a1;
                  </span><span class="tlx_comments">//_/read_masked
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_BP0_Entry_ReadMasked_Trans_cyc_cnt_a1[ring_stop][entry], L2_ReadMasked_Trans_dest_a1[1:0], L2_ReadMasked_Trans_sender_a1[1:0]} = L2_is_head_a1 ? {RingStop_STALL3_Entry_Trans_cyc_cnt_a2[ring_stop][entry], L2d_STALL3_Entry[entry].L2_Trans_dest_a2[1:0], L2d_STALL3_Entry[entry].L2_Trans_sender_a2[1:0]} </span><span class="tlx_comments">/* $aNY */ </span><span class="tlx_logic">: '0;
                  </span><span class="tlx_comments">//_/accum
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1[ring_stop][entry], L1_BP0_Entry_Accum_Trans_dest_a1[entry][1:0], L1_BP0_Entry_Accum_Trans_sender_a1[entry][1:0]} = ((entry == 0) ? '0 : {RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1[ring_stop][(entry+(4)-1)%(4)], L1_BP0_Entry_Accum_Trans_dest_a1[(entry+(4)-1)%(4)][1:0], L1_BP0_Entry_Accum_Trans_sender_a1[(entry+(4)-1)%(4)][1:0]}) |
                                   {RingStop_BP0_Entry_ReadMasked_Trans_cyc_cnt_a1[ring_stop][entry], L2_ReadMasked_Trans_dest_a1[1:0], L2_ReadMasked_Trans_sender_a1[1:0]}; </span><span class="tlx_structure">end
               </span><span class="tlx_comments">//_/head
                  </span><span class="tlx_logic">assign L1_BP0_Head_avail_a1 = L1_BP0_avail_a1;
                  </span><span class="tlx_comments">//_?$avail
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_BP0_Head_Trans_cyc_cnt_a1[ring_stop], L1_BP0_Head_Trans_dest_a1[1:0], L1_BP0_Head_Trans_sender_a1[1:0]} = {RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1[ring_stop][(4)-1], L1_BP0_Entry_Accum_Trans_dest_a1[(4)-1][1:0], L1_BP0_Entry_Accum_Trans_sender_a1[(4)-1][1:0]};
         </span><span class="tlx_comments">// Bypass
         //_|bp0
            //_@1
               // Available output.  Sometimes it's necessary to know what would be coming to determined
               // if it's blocked.  This can be used externally in that case.
               //_/fifo_head
                  </span><span class="tlx_logic">assign L1_BP0_FifoHead_avail_a1 = L1_BP0_avail_a1;
                  </span><span class="tlx_comments">//_?$avail
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_BP0_FifoHead_Trans_cyc_cnt_a1[ring_stop], L1_BP0_FifoHead_Trans_dest_a1[1:0], L1_BP0_FifoHead_Trans_sender_a1[1:0]} = L1_STALL3_would_bypass_a1
                                     ? {RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop], L1_STALL3_Trans_dest_a1, L1_STALL3_Trans_sender_a1}
                                     : {RingStop_BP0_Head_Trans_cyc_cnt_a1[ring_stop], L1_BP0_Head_Trans_dest_a1[1:0], L1_BP0_Head_Trans_sender_a1[1:0]};
               assign L1_BP0_avail_a1 = ! L1_STALL3_would_bypass_a1 || L1_STALL3_avail_a1;
               assign L1_BP0_trans_valid_a1 = L1_BP0_avail_a1 &amp;&amp; ! L1_BP0_blocked_a1;
               </span><span class="tlx_comments">//_?$trans_valid
                  //_/trans
                     </span><span class="tlx_logic">assign {RingStop_BP0_Trans_cyc_cnt_a1[ring_stop], L1_BP0_Trans_dest_a1[1:0], L1_BP0_Trans_sender_a1[1:0]} = {RingStop_BP0_FifoHead_Trans_cyc_cnt_a1[ring_stop], L1_BP0_FifoHead_Trans_dest_a1, L1_BP0_FifoHead_Trans_sender_a1};
               
               </span><span class="tlx_comments">// Deliver reset.
               </span><span class="tlx_logic">assign L1_BP0_reset_a1 = L1_STALL3_reset_in_a1;
      
         
         
         
         
         
         </span><span class="tlx_comments">/* Alternate code for pointer indexing.  Replaces $ANY expression above.
      
         // Hierarchy
         |m4_in_pipe
            /entry2[(m4_depth)-1:0]
      
         // Head/Tail ptrs.
         |m4_in_pipe
            @m4_in_at
               &gt;&gt;1$WrPtr[m4_ptr_width-1:0] =
                   $reset       ? '0 :
                   $trans_valid ? ($WrPtr == (m4_depth - 1))
                                    ? '0
                                    : $WrPtr + {{(m4_ptr_width-1){1'b0}}, 1'b1} :
                                  $RETAIN;
         |m4_out_pipe
            @m4_out_at
               &gt;&gt;1$RdPtr[m4_ptr_width-1:0] =
                   /m4_top|m4_in_pipe&gt;&gt;m4_reverse_bypass_align$reset
                                ? '0 :
                   $trans_valid ? ($RdPtr == (m4_depth - 1))
                                    ? '0
                                    : $RdPtr + {{(m4_ptr_width-1){1'b0}}, 1'b1} :
                                  $RETAIN;
         // Write FIFO
         |m4_in_pipe
            @m4_in_at
               $dummy = '0;
               ?$trans_valid
                  // This doesn't work because SV complains for FIFOs in replicated context that
                  // there are multiple procedures that assign the signals.
                  // Array writes can be done in an SV module.
                  // The only long-term resolutions are support for module generation and use
                  // signals declared within for loops with cross-hierarchy references in SV.
                  // TODO: To make a simulation-efficient FIFO, use DesignWare.
                  {/entry2[$WrPtr]$$ANY} = $ANY;
         // Read FIFO
         |m4_out_pipe
            @m4_out_at
               /read2
                  $trans_valid = |m4_out_pipe$trans_valid;
                  ?$trans_valid
                     $ANY = /m4_top|m4_in_pipe/entry2[|m4_out_pipe$RdPtr]&gt;&gt;m4_reverse_bypass_align$ANY;
                  `BOGUS_USE($dummy)
               ?$trans_valid
                  $ANY = /read2$ANY;
         */
      
  
    
    
    
  

      //_\end_source
      </span><span class="tlx_structure">`line 66 &quot;top.tlv&quot; 2
      </span><span class="tlx_comments">//m4+simple_bypass_fifo_v2(/ring_stop, |stall3, @1, |bp0, @1, 4, 100, /trans)
      </span><span class="tlx_structure">`line 417 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+bp_pipeline(/ring_stop, |bp, 0, 3, /trans)
         
         </span><span class="tlx_structure">`line 343 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp0, @1'], [' |bp1, @1'], )
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp0, @1'], )
                  // Avail/Blocked Input:
                  //_|bp0
                     //_@1
                        </span><span class="tlx_logic">assign L1_BP0_accepted_a1 = L1_BP0_avail_a1 &amp;&amp; ! L1_BP0_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">assign L1_BP0_reset_in_a1 = L1_BP0_reset_a1;
                        `BOGUS_USE(L1_BP0_accepted_a1 L1_BP0_reset_in_a1)
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp0, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp1, @1'])
                  // Avail/Blocked Output:
                  //_|bp1
                     //_@1
                        </span><span class="tlx_logic">`BOGUS_USE(L1_BP1_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp1, @1))))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 350 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_|bp1
               //_@0
                  </span><span class="tlx_logic">assign L1_BP1_reset_a0 = L1_BP0_reset_in_a1;
                  
                  assign L1_BP1_avail_a0 = L1_BP1_reset_a0 ? 1'b0 :
                                    (L1_BP1_avail_a1 &amp;&amp; L1_BP1_blocked_a1) ||  </span><span class="tlx_comments">// Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    </span><span class="tlx_logic">L1_BP0_avail_a1; </span><span class="tlx_comments">// Incoming available
                  //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
               //_@0
                  //_?$avail  // Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                           // place of recirculation.
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_BP1_Trans_cyc_cnt_a0[ring_stop], L1_BP1_Trans_dest_a0[1:0], L1_BP1_Trans_sender_a0[1:0]} =
                           L1_BP1_recirc_a1 ? {RingStop_BP1_Trans_cyc_cnt_a1[ring_stop], L1_BP1_Trans_dest_a1, L1_BP1_Trans_sender_a1}
                                                : {RingStop_BP0_Trans_cyc_cnt_a1[ring_stop], L1_BP0_Trans_dest_a1, L1_BP0_Trans_sender_a1};
               </span><span class="tlx_comments">//_@1
                  </span><span class="tlx_logic">assign L1_BP1_recirc_a1 = L1_BP1_avail_a1 &amp;&amp; L1_BP1_blocked_a1;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
            //_|bp0
               //_@1
                  </span><span class="tlx_logic">assign L1_BP0_blocked_a1 = L1_BP1_recirc_a1;
                  </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         //_\end_source
         </span><span class="tlx_structure">`line 419 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
         `line 343 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp1, @1'], [' |bp2, @1'], )
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp1, @1'], )
                  // Avail/Blocked Input:
                  //_|bp1
                     //_@1
                        </span><span class="tlx_logic">assign L1_BP1_accepted_a1 = L1_BP1_avail_a1 &amp;&amp; ! L1_BP1_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">assign L1_BP1_reset_in_a1 = L1_BP1_reset_a1;
                        `BOGUS_USE(L1_BP1_accepted_a1 L1_BP1_reset_in_a1)
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp1, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp2, @1'])
                  // Avail/Blocked Output:
                  //_|bp2
                     //_@1
                        </span><span class="tlx_logic">`BOGUS_USE(L1_BP2_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp2, @1))))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 350 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_|bp2
               //_@0
                  </span><span class="tlx_logic">assign L1_BP2_reset_a0 = L1_BP1_reset_in_a1;
                  
                  assign L1_BP2_avail_a0 = L1_BP2_reset_a0 ? 1'b0 :
                                    (L1_BP2_avail_a1 &amp;&amp; L1_BP2_blocked_a1) ||  </span><span class="tlx_comments">// Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    </span><span class="tlx_logic">L1_BP1_avail_a1; </span><span class="tlx_comments">// Incoming available
                  //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
               //_@0
                  //_?$avail  // Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                           // place of recirculation.
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_BP2_Trans_cyc_cnt_a0[ring_stop], L1_BP2_Trans_dest_a0[1:0], L1_BP2_Trans_sender_a0[1:0]} =
                           L1_BP2_recirc_a1 ? {RingStop_BP2_Trans_cyc_cnt_a1[ring_stop], L1_BP2_Trans_dest_a1, L1_BP2_Trans_sender_a1}
                                                : {RingStop_BP1_Trans_cyc_cnt_a1[ring_stop], L1_BP1_Trans_dest_a1, L1_BP1_Trans_sender_a1};
               </span><span class="tlx_comments">//_@1
                  </span><span class="tlx_logic">assign L1_BP2_recirc_a1 = L1_BP2_avail_a1 &amp;&amp; L1_BP2_blocked_a1;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
            //_|bp1
               //_@1
                  </span><span class="tlx_logic">assign L1_BP1_blocked_a1 = L1_BP2_recirc_a1;
                  </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         //_\end_source
         </span><span class="tlx_structure">`line 421 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
         `line 343 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+bp_stage(/ring_stop, |bp['']m4_stage, @1, |bp['']m4_eval(m4_stage + 1), @1, /trans, 0, 0, , )
            
            
            
            
            
            
            </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |bp2, @1'], [' |bp3, @1'], )
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp2, @1'], )
                  // Avail/Blocked Input:
                  //_|bp2
                     //_@1
                        </span><span class="tlx_logic">assign L1_BP2_accepted_a1 = L1_BP2_avail_a1 &amp;&amp; ! L1_BP2_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">assign L1_BP2_reset_in_a1 = L1_BP2_reset_a1;
                        `BOGUS_USE(L1_BP2_accepted_a1 L1_BP2_reset_in_a1)
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp2, @1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bp3, @1'])
                  // Avail/Blocked Output:
                  //_|bp3
                     //_@1
                        </span><span class="tlx_logic">`BOGUS_USE(L1_BP3_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 67 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp3, @1))))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 350 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">//_|bp3
               //_@0
                  </span><span class="tlx_logic">assign L1_BP3_reset_a0 = L1_BP2_reset_in_a1;
                  
                  assign L1_BP3_avail_a0 = L1_BP3_reset_a0 ? 1'b0 :
                                    (L1_BP3_avail_a1 &amp;&amp; L1_BP3_blocked_a1) ||  </span><span class="tlx_comments">// Recirc'ed or
                                    // Above is recomputation of $recirc to avoid a flop.
                                    // For SELF, its in the same stage, and is redundant computation.
                                    </span><span class="tlx_logic">L1_BP2_avail_a1; </span><span class="tlx_comments">// Incoming available
                  //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
               //_@0
                  //_?$avail  // Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                           // place of recirculation.
                     //_/trans
                        </span><span class="tlx_logic">assign {RingStop_BP3_Trans_cyc_cnt_a0[ring_stop], L1_BP3_Trans_dest_a0[1:0], L1_BP3_Trans_sender_a0[1:0]} =
                           L1_BP3_recirc_a1 ? {RingStop_BP3_Trans_cyc_cnt_a1[ring_stop], L1_BP3_Trans_dest_a1, L1_BP3_Trans_sender_a1}
                                                : {RingStop_BP2_Trans_cyc_cnt_a1[ring_stop], L1_BP2_Trans_dest_a1, L1_BP2_Trans_sender_a1};
               </span><span class="tlx_comments">//_@1
                  </span><span class="tlx_logic">assign L1_BP3_recirc_a1 = L1_BP3_avail_a1 &amp;&amp; L1_BP3_blocked_a1;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
            //_|bp2
               //_@1
                  </span><span class="tlx_logic">assign L1_BP2_blocked_a1 = L1_BP3_recirc_a1;
                  </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
            
            
            
            
            
            
         //_\end_source
         </span><span class="tlx_structure">`line 423 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
      </span><span class="tlx_comments">//_\end_source
      </span><span class="tlx_structure">`line 68 &quot;top.tlv&quot; 2
      </span><span class="tlx_comments">//_|bp3
         //_@1
            </span><span class="tlx_logic">assign L1_BP3_local_a1 = L1_BP3_Trans_dest_a1 == ring_stop;
      </span><span class="tlx_structure">`line 180 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 71 as: m4+opportunistic_flow(/ring_stop, |bp3, @1, |bypass, @1, $local, |ring_in, @1, /trans)
         </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 180 as: m4+flow_interface(/ring_stop, [' |bp3, @1'], [' |bypass, @1, |ring_in, @1'], )
            </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |bp3, @1'], )
               // Avail/Blocked Input:
               //_|bp3
                  //_@1
                     </span><span class="tlx_logic">assign L1_BP3_accepted_a1 = L1_BP3_avail_a1 &amp;&amp; ! L1_BP3_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">assign L1_BP3_reset_in_a1 = L1_BP3_reset_a1;
                     `BOGUS_USE(L1_BP3_accepted_a1 L1_BP3_reset_in_a1)
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 71 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bp3, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |bypass, @1, |ring_in, @1'])
               // Avail/Blocked Output:
               //_|bypass
                  //_@1
                     </span><span class="tlx_logic">`BOGUS_USE(L1_BYPASS_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 71 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |bypass, @1, |ring_in, @1))))
                  // Avail/Blocked Output:
                  //_|ring_in
                     //_@1
                        </span><span class="tlx_logic">`BOGUS_USE(L1_RING_IN_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                  </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 71 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift(|ring_in,@1))))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 181 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
         </span><span class="tlx_comments">//_|bypass
            //_@1
               </span><span class="tlx_logic">assign L1_BYPASS_avail_a1 = L1_BP3_avail_a1 &amp;&amp;
                        L1_BP3_local_a1;
               assign L1_BYPASS_reset_a1 = L1_BP3_reset_in_a1;
               </span><span class="tlx_comments">//_?$avail
                  //_/trans
                     </span><span class="tlx_logic">assign {L1_BYPASS_Trans_cyc_cnt_a1, L1_BYPASS_Trans_sender_a1[1:0]} = {RingStop_BP3_Trans_cyc_cnt_a1[ring_stop], L1_BP3_Trans_sender_a1[1:0]};
         </span><span class="tlx_comments">//_|ring_in
            //_@1
               </span><span class="tlx_logic">assign L1_RING_IN_avail_a1 = L1_BP3_avail_a1 &amp;&amp;
                        (! L1_BP3_local_a1 ||
                         L1c_RingStop[ring_stop].L1_BYPASS_blocked_a1);
               assign L1_RING_IN_reset_a1 = L1_BP3_reset_in_a1;
               </span><span class="tlx_comments">//_?$avail
                  //_/trans
                     </span><span class="tlx_logic">assign {L1_RING_IN_Trans_cyc_cnt_a1, L1_RING_IN_Trans_dest_a1[1:0], L1_RING_IN_Trans_sender_a1[1:0]} = {RingStop_BP3_Trans_cyc_cnt_a1[ring_stop], L1_BP3_Trans_dest_a1, L1_BP3_Trans_sender_a1};
         </span><span class="tlx_comments">//_|bp3
            //_@1
               </span><span class="tlx_logic">assign L1_BP3_blocked_a1 = (L1b_RingStop[ring_stop].L1_RING_IN_blocked_a1 ||
                           ! L1_BP3_local_a1) &amp;&amp;
                          L1c_RingStop[ring_stop].L1_BYPASS_blocked_a1;
         
      </span><span class="tlx_structure">end </span><span class="tlx_comments">//_\end_source
      </span><span class="tlx_structure">`line 72 &quot;top.tlv&quot; 2
   `line 1018 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 72 as: m4+simple_ring(/ring_stop, |ring_in, @1, |ring_out, @1, /top&lt;&gt;0$reset, |rg, /trans)
      
      
      
      
      
      
      // Logic
      </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1b_RingStop </span><span class="tlx_declarations">logic L1_RG_passed_on_a1; logic L1_RG_valid_a1; logic L1_RING_IN_accepted_a1; logic L1_RING_IN_blocked_a1; logic L1_RING_IN_reset_in_a1; logic L1_RING_OUT_avail_a1, L1_RING_OUT_avail_a2, L1_RING_OUT_avail_a3, L1_RING_OUT_avail_a4; logic L1_RING_OUT_reset_a1, L1_RING_OUT_reset_a2, L1_RING_OUT_reset_a3, L1_RING_OUT_reset_a4; logic L1_RING_OUT_trans_valid_a1, L1_RING_OUT_trans_valid_a2, L1_RING_OUT_trans_valid_a3; logic L1_RING_OUT_Trans_cyc_cnt_a1, L1_RING_OUT_Trans_cyc_cnt_a2, L1_RING_OUT_Trans_cyc_cnt_a3, L1_RING_OUT_Trans_cyc_cnt_a4; logic [1:0] L1_RING_OUT_Trans_sender_a1, L1_RING_OUT_Trans_sender_a2, L1_RING_OUT_Trans_sender_a3, L1_RING_OUT_Trans_sender_a4; </span><span class="tlx_comments">//_/ring_stop
         </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 1026 as: m4+flow_interface(/ring_stop, [' |ring_in, @1'], [' |ring_out, @1'], /top&lt;&gt;0$reset)
            </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |ring_in, @1'], /top&lt;&gt;0$reset)
               // Avail/Blocked Input:
               //_|ring_in
                  //_@1
                     </span><span class="tlx_logic">assign L1_RING_IN_accepted_a1 = L1_RingStop[ring_stop].L1_RING_IN_avail_a1 &amp;&amp; ! L1_RING_IN_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">assign L1_RING_IN_reset_in_a1 =  L0_reset_a1;
                     `BOGUS_USE(L1_RING_IN_accepted_a1 L1_RING_IN_reset_in_a1)
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 72 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_in, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |ring_out, @1'])
               // Avail/Blocked Output:
               //_|ring_out
                  //_@1
                     </span><span class="tlx_logic">`BOGUS_USE(L1_RING_OUT_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 72 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_out, @1))))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 1027 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         </span><span class="tlx_comments">//_|default
            //_@0
               /*SV_plus*/
                  </span><span class="tlx_logic">int prev_hop = (ring_stop + 4 - 1) % 4;
         </span><span class="tlx_comments">//_|ring_in
            //_@1
               </span><span class="tlx_logic">assign L1_RING_IN_blocked_a1 = L1_RG_passed_on_a1;
         </span><span class="tlx_comments">//_|rg
            //_@1
               </span><span class="tlx_logic">assign L1_RG_passed_on_a1 = RingStop_RG_pass_on_a2[prev_hop];
               assign L1_RG_valid_a1 = ! L1_RING_IN_reset_in_a1 &amp;&amp;
                        (L1_RG_passed_on_a1 || L1_RingStop[ring_stop].L1_RING_IN_avail_a1);
               assign RingStop_RG_pass_on_a1[ring_stop] = L1_RG_valid_a1 &amp;&amp; ! L1_RING_OUT_trans_valid_a1;
               assign RingStop_RG_dest_a1[ring_stop][1:0] =
                  L1_RG_passed_on_a1
                     ? RingStop_RG_dest_a2[prev_hop]
                     : L1_RingStop[ring_stop].L1_RING_IN_Trans_dest_a1;
            </span><span class="tlx_comments">//_@1
               //_?$valid
                  //_/trans
                     </span><span class="tlx_logic">assign {RingStop_RG_Trans_cyc_cnt_a1[ring_stop], RingStop_RG_Trans_sender_a1[ring_stop][1:0]} =
                       L1_RG_passed_on_a1
                           ? {RingStop_RG_Trans_cyc_cnt_a2[prev_hop], RingStop_RG_Trans_sender_a2[prev_hop]}
                           : {L1_RingStop[ring_stop].L1_RING_IN_Trans_cyc_cnt_a1, L1_RingStop[ring_stop].L1_RING_IN_Trans_sender_a1};
         </span><span class="tlx_comments">//_|ring_out
            // Ring out
            //_@1
               </span><span class="tlx_logic">assign L1_RING_OUT_avail_a1 = L1_RG_valid_a1 &amp;&amp; (RingStop_RG_dest_a1[ring_stop] == ring_stop);
               </span><span class="tlx_comments">//$blocked = 1'b0;
               </span><span class="tlx_logic">assign L1_RING_OUT_trans_valid_a1 = L1_RING_OUT_avail_a1; </span><span class="tlx_comments">// &amp;&amp; ! $blocked;
               </span><span class="tlx_logic">assign L1_RING_OUT_reset_a1 = L1_RING_IN_reset_in_a1;
            </span><span class="tlx_comments">//_?$trans_valid
               //_@1
                  //_/trans
                     </span><span class="tlx_logic">assign {L1_RING_OUT_Trans_cyc_cnt_a1, L1_RING_OUT_Trans_sender_a1[1:0]} = {RingStop_RG_Trans_cyc_cnt_a1[ring_stop], RingStop_RG_Trans_sender_a1[ring_stop]}; </span><span class="tlx_structure">end
      
      
      
      
      
   </span><span class="tlx_comments">//_\end_source
   </span><span class="tlx_structure">`line 73 &quot;top.tlv&quot; 2
   
   for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1c_RingStop </span><span class="tlx_declarations">logic L1_ARB_OUT_avail_a1; logic L1_ARB_OUT_blocked_a1; logic L1_ARB_OUT_ready_a1; logic L1_ARB_OUT_reset_a1; logic L1_ARB_OUT_Trans_cyc_cnt_a1; logic [1:0] L1_ARB_OUT_Trans_sender_a1; logic L1_BYPASS_accepted_a1; logic L1_BYPASS_blocked_a1; logic L1_BYPASS_reset_in_a1; logic L1_FIFO2_OUT_avail_a1; logic L1_FIFO2_OUT_Trans_cyc_cnt_a1; logic [1:0] L1_FIFO2_OUT_Trans_sender_a1; logic L1_RING_OUT_accepted_a4; logic L1_RING_OUT_blocked_a4; logic L1_RING_OUT_reset_in_a4; </span><span class="tlx_comments">//_/ring_stop
      </span><span class="tlx_structure">`line 151 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 75 as: m4+arb2(/ring_stop, |ring_out, @4, |bypass, @1, |arb_out, @1, /trans)
         </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 151 as: m4+flow_interface(/ring_stop, [' |ring_out, @4, |bypass, @1'], [' |arb_out, @1'], )
            </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |ring_out, @4, |bypass, @1'], )
               // Avail/Blocked Input:
               //_|ring_out
                  //_@4
                     </span><span class="tlx_logic">assign L1_RING_OUT_accepted_a4 = L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 &amp;&amp; ! L1_RING_OUT_blocked_a4;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">assign L1_RING_OUT_reset_in_a4 = L1b_RingStop[ring_stop].L1_RING_OUT_reset_a4;
                     `BOGUS_USE(L1_RING_OUT_accepted_a4 L1_RING_OUT_reset_in_a4)
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 75 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |ring_out, @4, |bypass, @1))), m4_quote(m4_shift(_resets)))
                  // Avail/Blocked Input:
                  //_|bypass
                     //_@1
                        </span><span class="tlx_logic">assign L1_BYPASS_accepted_a1 = L1_RingStop[ring_stop].L1_BYPASS_avail_a1 &amp;&amp; ! L1_BYPASS_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                        </span><span class="tlx_logic">assign L1_BYPASS_reset_in_a1 = L1_RingStop[ring_stop].L1_BYPASS_reset_a1;
                        `BOGUS_USE(L1_BYPASS_accepted_a1 L1_BYPASS_reset_in_a1)
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 75 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift(|bypass,@1))), m4_quote(m4_shift(_resets)))
                     
                  //_\end_source
                  </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |arb_out, @1'])
               // Avail/Blocked Output:
               //_|arb_out
                  //_@1
                     </span><span class="tlx_logic">`BOGUS_USE(L1_ARB_OUT_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 75 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |arb_out, @1))))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 152 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         
         </span><span class="tlx_comments">// In1 is blocked if output is blocked.
         //_|ring_out
            //_@4
               </span><span class="tlx_logic">assign L1_RING_OUT_blocked_a4 = L1_ARB_OUT_blocked_a1;
         </span><span class="tlx_comments">// In2 is blocked if output is blocked or in1 is available.
         //_|bypass
            //_@1
               </span><span class="tlx_logic">assign L1_BYPASS_blocked_a1 = L1_ARB_OUT_blocked_a1 ||
                          L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4;
         </span><span class="tlx_comments">// Output comes from in1 if available, otherwise, in2.
         //_|arb_out
            //_@1
               </span><span class="tlx_logic">assign L1_ARB_OUT_reset_a1 = L1_RING_OUT_reset_in_a4;
               </span><span class="tlx_comments">// Output is available if either input is available.
               </span><span class="tlx_logic">assign L1_ARB_OUT_avail_a1 = L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 ||
                        L1_RingStop[ring_stop].L1_BYPASS_avail_a1;
               </span><span class="tlx_comments">//_?$avail
                  //_/trans
                     </span><span class="tlx_logic">assign {L1_ARB_OUT_Trans_cyc_cnt_a1, L1_ARB_OUT_Trans_sender_a1[1:0]} = L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 ? {L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a4, L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a4} :
                                                                                {L1_RingStop[ring_stop].L1_BYPASS_Trans_cyc_cnt_a1, L1_RingStop[ring_stop].L1_BYPASS_Trans_sender_a1[1:0]};
         
      </span><span class="tlx_comments">//_\end_source
      </span><span class="tlx_structure">`line 76 &quot;top.tlv&quot; 2
      </span><span class="tlx_comments">// FIFO2
      // To use BaseJump STL, this line:
      //m4+simple_bypass_fifo_v2(/ring_stop, |arb_out, @1, |fifo2_out, @1, 4, 100, /trans)        
      // Becomes:
      //----------------
      //_|arb_out
         //_@1
            /*SV_plus*/
               </span><span class="tlx_logic">bsg_fifo_1r1w_small #(.width_p(100)) my_fifo(
                  clk, L1_ARB_OUT_reset_a1,
                  L1_ARB_OUT_avail_a1, L1_ARB_OUT_ready_a1, {L1_ARB_OUT_Trans_cyc_cnt_a1, L1_ARB_OUT_Trans_sender_a1},
                  L1_FIFO2_OUT_avail_a1, {L1_FIFO2_OUT_Trans_cyc_cnt_a1, L1_FIFO2_OUT_Trans_sender_a1[1:0]}, L1d_RingStop[ring_stop].L1_FIFO2_OUT_accepted_a1
               );
            assign L1_ARB_OUT_blocked_a1 = ! L1_ARB_OUT_ready_a1; </span><span class="tlx_structure">end
      </span><span class="tlx_comments">//----------------
   
   
   //m4+trans()
   
   
   // Testbench
   </span><span class="tlx_structure">`line 1306 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+router_testbench(/top, /ring_stop, |stall0, @1, |fifo2_out, @1, /trans, /top&lt;&gt;0$reset)
        // Otherwise we can have a cyclic reset loop through flow.
      </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1d_RingStop </span><span class="tlx_declarations">logic L1_FIFO2_OUT_accepted_a1; logic L1_FIFO2_OUT_reset_in_a1; </span><span class="tlx_comments">//_/ring_stop
         // Define flow interface. Note that router ins are tb outs and outs are ins.
         </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 1309 as: m4+flow_interface(/ring_stop, [' |fifo2_out, @1'], [' |stall0, @1'], /top&lt;&gt;0$reset)
            </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |fifo2_out, @1'], /top&lt;&gt;0$reset)
               // Avail/Blocked Input:
               //_|fifo2_out
                  //_@1
                     </span><span class="tlx_logic">assign L1_FIFO2_OUT_accepted_a1 = L1c_RingStop[ring_stop].L1_FIFO2_OUT_avail_a1 &amp;&amp; ! L1e_RingStop[ring_stop].L1_FIFO2_OUT_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                     </span><span class="tlx_logic">assign L1_FIFO2_OUT_reset_in_a1 =  L0_reset_a1;
                     `BOGUS_USE(L1_FIFO2_OUT_accepted_a1 L1_FIFO2_OUT_reset_in_a1)
               </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |fifo2_out, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |stall0, @1'])
               // Avail/Blocked Output:
               //_|stall0
                  //_@1
                     </span><span class="tlx_logic">`BOGUS_USE(L1e_RingStop[ring_stop].L1_STALL0_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
               </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |stall0, @1))))
                  
               //_\end_source
               </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               
            </span><span class="tlx_comments">//_\end_source
            </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
         end </span><span class="tlx_comments">//_\end_source
         </span><span class="tlx_structure">`line 1310 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
      
      
      
   
      </span><span class="tlx_comments">//_/tb
         //_|count
            //_@1
               </span><span class="tlx_logic">assign Tb_COUNT_CycCount_a0[15:0] = L1e_RingStop[0].L1_STALL0_reset_a2
                                     ? 16'b0 :
                                       Tb_COUNT_CycCount_a1 + 1;
               </span><span class="tlx_comments">/*SV_plus*/
                  </span><span class="tlx_logic">always_ff @(posedge clk) begin
                     $display(&quot;Cycle: %0d&quot;, Tb_COUNT_CycCount_a1);
                  end
         </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1_Tb_RingStop </span><span class="tlx_declarations">logic L1_RECEIVE1_accepted_a1; logic L1_RECEIVE1_avail_a1; logic L1_RECEIVE1_blocked_a1; logic L1_RECEIVE1_reset_a1; logic L1_RECEIVE1_reset_in_a1; logic L1_RECEIVE1_Trans_cyc_cnt_a1; logic [1:0] L1_RECEIVE1_Trans_dest_a1; logic L1_RECEIVE1_Trans_request_a1; logic L1_RECEIVE1_Trans_response_a1; logic L1_RECEIVE1_Trans_response_debug_a1; logic [1:0] L1_RECEIVE1_Trans_sender_a1; logic [16-1:0] L1_RECEIVE2_OutstandingPackets_a0, L1_RECEIVE2_OutstandingPackets_a1; logic L1_RECEIVE2_accepted_a1; logic L1_RECEIVE2_avail_a0, L1_RECEIVE2_avail_a1; logic L1_RECEIVE2_blocked_a1; logic L1_RECEIVE2_generated_request_a1; logic L1_RECEIVE2_recirc_a1; logic L1_RECEIVE2_reset_a0, L1_RECEIVE2_reset_a1; logic L1_RECEIVE2_valid_request_a1; logic L1_RECEIVE2_valid_response_a1; logic L1_RECEIVE2_Trans_cyc_cnt_a0, L1_RECEIVE2_Trans_cyc_cnt_a1; logic [1:0] L1_RECEIVE2_Trans_dest_a0, L1_RECEIVE2_Trans_dest_a1; logic L1_RECEIVE2_Trans_request_a0, L1_RECEIVE2_Trans_request_a1; logic L1_RECEIVE2_Trans_response_a0, L1_RECEIVE2_Trans_response_a1; logic L1_RECEIVE2_Trans_response_debug_a0, L1_RECEIVE2_Trans_response_debug_a1; logic L1_RECEIVE2_Trans_sender_a0, L1_RECEIVE2_Trans_sender_a1; logic L1_SEND_avail_a1; logic L1_SEND_reset_a1; logic L1_SEND_valid_in_a1; logic [15:0] L1_SEND_GenTrans_cyc_cnt_a1; logic [1:0] L1_SEND_GenTrans_dest_a1; logic [1:0] L1_SEND_GenTrans_dest_tmp_a1; logic L1_SEND_GenTrans_response_debug_a1; logic [1:0] L1_SEND_GenTrans_sender_a1; logic [15:0] L1_SEND_TransOut_cyc_cnt_a1; logic [1:0] L1_SEND_TransOut_dest_a1; logic L1_SEND_TransOut_response_debug_a1; logic [1:0] L1_SEND_TransOut_sender_a1; </span><span class="tlx_comments">//_/ring_stop
            // STIMULUS
            //_|send
               //_@1
                  // Generate a transaction to inject sometimes (if needed)
                  </span><span class="tlx_logic">assign L1_SEND_reset_a1 = L1_RECEIVE2_reset_a1;
                  assign L1_SEND_valid_in_a1 = Tb_COUNT_CycCount_a1 == 3;
                  </span><span class="tlx_comments">//_?$valid_in
                     //_/gen_trans
                        </span><span class="tlx_logic">assign L1_SEND_GenTrans_cyc_cnt_a1[15:0] = Tb_COUNT_CycCount_a1;
                        assign L1_SEND_GenTrans_response_debug_a1 = 1'b0;  </span><span class="tlx_comments">// Not a response (for debug)
                        </span><span class="tlx_logic">assign L1_SEND_GenTrans_sender_a1[1:0] = ring_stop;
                        </span><span class="tlx_comments">//m4_rand($size, M4_PACKET_SIZE-1, 0, #m4_port) // unused
                        </span><span class="tlx_logic">assign L1_SEND_GenTrans_dest_tmp_a1[1:0] = RW_rand_vect[(0 + (ring_stop)) % 257 +: 2];
                        assign L1_SEND_GenTrans_dest_a1[1:0] = L1_SEND_GenTrans_dest_tmp_a1 % 4;
                        </span><span class="tlx_comments">//$dest[M4_['']M4_PORT['']_INDEX_RANGE] = #m4_port;
                        //$packet_valid = #m4_port == 0 ? 1'b1 : 1'b0; // valid for only first port - unused
                  </span><span class="tlx_logic">assign L1_SEND_avail_a1 = L1_SEND_valid_in_a1 || L1_RECEIVE2_valid_request_a1;
                  </span><span class="tlx_comments">//_?$avail
                     //_/trans_out
                        // Loopback requests as responses or use gen_trans.
                        </span><span class="tlx_logic">assign {L1_SEND_TransOut_cyc_cnt_a1[15:0], L1_SEND_TransOut_dest_a1[1:0], L1_SEND_TransOut_response_debug_a1, L1_SEND_TransOut_sender_a1[1:0]} = L1_RECEIVE2_valid_request_a1
                                    ? {L1_RECEIVE2_Trans_cyc_cnt_a1, L1_RECEIVE2_Trans_dest_a1, L1_RECEIVE2_Trans_response_debug_a1, L1_RECEIVE2_Trans_sender_a1} :
                                      {L1_SEND_GenTrans_cyc_cnt_a1, L1_SEND_GenTrans_dest_a1[1:0], L1_SEND_GenTrans_response_debug_a1, L1_SEND_GenTrans_sender_a1};
                        
                        </span><span class="tlx_comments">/*SV_plus*/
                           </span><span class="tlx_logic">always_ff @(posedge clk) begin
                              if (! L1_SEND_reset_a1 &amp;&amp; ! reset &amp;&amp; L1_RingStop[ring_stop].L1_STALL0_accepted_a1) begin
                                 $display(&quot;|send[%0d]&quot;, ring_stop);
                                 $display(&quot;Sender: %0d, Orig. Cyc: %0d, Dest: %0d, Resp: %0d&quot;, L1_SEND_TransOut_sender_a1, L1_SEND_TransOut_cyc_cnt_a1, L1_SEND_TransOut_dest_a1, L1_SEND_TransOut_response_debug_a1);
                              end
                           end
            </span><span class="tlx_comments">// Hook router out to |receive1 and determine transaction response routing (within the transaction).
            //_|receive1
               //_@1
                  </span><span class="tlx_logic">assign L1_RECEIVE1_avail_a1 = L1c_RingStop[ring_stop].L1_FIFO2_OUT_avail_a1;
                  assign L1_RECEIVE1_reset_a1 = L1d_RingStop[ring_stop].L1_FIFO2_OUT_reset_in_a1;
                  </span><span class="tlx_comments">//_?$accepted
                     //_/trans
                        </span><span class="tlx_logic">assign L1_RECEIVE1_Trans_response_debug_a1 = 1'b1; </span><span class="tlx_comments">// Turn this around as a response.
                        </span><span class="tlx_logic">assign L1_RECEIVE1_Trans_request_a1 = L1_RECEIVE1_Trans_sender_a1 != ring_stop;  </span><span class="tlx_comments">// Arrived as request?
                        </span><span class="tlx_logic">assign L1_RECEIVE1_Trans_response_a1 = L1_RECEIVE1_Trans_sender_a1 == ring_stop; </span><span class="tlx_comments">// Arrived as response?
                        </span><span class="tlx_logic">assign {L1_RECEIVE1_Trans_cyc_cnt_a1, L1_RECEIVE1_Trans_sender_a1[1:0]} = {L1c_RingStop[ring_stop].L1_FIFO2_OUT_Trans_cyc_cnt_a1, L1c_RingStop[ring_stop].L1_FIFO2_OUT_Trans_sender_a1};
                        assign L1_RECEIVE1_Trans_dest_a1[1:0] = L1_RECEIVE1_Trans_request_a1 ? L1_RECEIVE1_Trans_sender_a1 : L1_RECEIVE1_Trans_dest_a1;
            </span><span class="tlx_structure">`line 343 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 1368 as: m4+bp_stage(/ring_stop, |receive1, @1, |receive2, @1, /trans)
               
               
               
               
               
               
               </span><span class="tlx_structure">`line 115 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 349 as: m4+flow_interface(/ring_stop, [' |receive1, @1'], [' |receive2, @1'], )
                  </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 115 as: m4+flow_inputs(/ring_stop, [' |receive1, @1'], )
                     // Avail/Blocked Input:
                     //_|receive1
                        //_@1
                           </span><span class="tlx_logic">assign L1_RECEIVE1_accepted_a1 = L1_RECEIVE1_avail_a1 &amp;&amp; ! L1_RECEIVE1_blocked_a1;  </span><span class="tlx_comments">// provided for optional upstream use.
                           </span><span class="tlx_logic">assign L1_RECEIVE1_reset_in_a1 = L1_RECEIVE1_reset_a1;
                           `BOGUS_USE(L1_RECEIVE1_accepted_a1 L1_RECEIVE1_reset_in_a1)
                     </span><span class="tlx_structure">`line 120 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+flow_inputs(/ring_stop, m4_quote(m4_shift(m4_shift( |receive1, @1))), m4_quote(m4_shift(_resets)))
                        
                     //_\end_source
                     </span><span class="tlx_structure">`line 127 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                     
                  </span><span class="tlx_comments">//_\end_source
                  </span><span class="tlx_structure">`line 116 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                  `line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 116 as: m4+flow_outputs(/ring_stop, [' |receive2, @1'])
                     // Avail/Blocked Output:
                     //_|receive2
                        //_@1
                           </span><span class="tlx_logic">`BOGUS_USE(L1_RECEIVE2_reset_a1) </span><span class="tlx_comments">// Output pipes must provide $reset.
                     </span><span class="tlx_structure">`line 130 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 97 as: m4+flow_outputs(/ring_stop, m4_quote(m4_shift(m4_shift( |receive2, @1))))
                        
                     //_\end_source
                     </span><span class="tlx_structure">`line 135 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
                     
                  </span><span class="tlx_comments">//_\end_source
                  </span><span class="tlx_structure">`line 117 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               </span><span class="tlx_comments">//_\end_source
               </span><span class="tlx_structure">`line 350 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
               </span><span class="tlx_comments">//_|receive2
                  //_@0
                     </span><span class="tlx_logic">assign L1_RECEIVE2_reset_a0 = L1_RECEIVE1_reset_in_a1;
                     
                     assign L1_RECEIVE2_avail_a0 = L1_RECEIVE2_reset_a0 ? 1'b0 :
                                       (L1_RECEIVE2_avail_a1 &amp;&amp; L1_RECEIVE2_blocked_a1) ||  </span><span class="tlx_comments">// Recirc'ed or
                                       // Above is recomputation of $recirc to avoid a flop.
                                       // For SELF, its in the same stage, and is redundant computation.
                                       </span><span class="tlx_logic">L1_RECEIVE1_avail_a1; </span><span class="tlx_comments">// Incoming available
                     //$first_avail = $avail &amp;&amp; ! &gt;&gt;1$blocked;  // Transaction is newly available.
                  //_@0
                     //_?$avail  // Physically, $first_avail &amp;&amp; *reset_b for functional gating in
                              // place of recirculation.
                        //_/trans
                           </span><span class="tlx_logic">assign {L1_RECEIVE2_Trans_cyc_cnt_a0, L1_RECEIVE2_Trans_dest_a0[1:0], L1_RECEIVE2_Trans_request_a0, L1_RECEIVE2_Trans_response_a0, L1_RECEIVE2_Trans_response_debug_a0, L1_RECEIVE2_Trans_sender_a0} =
                              L1_RECEIVE2_recirc_a1 ? {L1_RECEIVE2_Trans_cyc_cnt_a1, L1_RECEIVE2_Trans_dest_a1, L1_RECEIVE2_Trans_request_a1, L1_RECEIVE2_Trans_response_a1, L1_RECEIVE2_Trans_response_debug_a1, L1_RECEIVE2_Trans_sender_a1}
                                                   : {L1_RECEIVE1_Trans_cyc_cnt_a1, L1_RECEIVE1_Trans_dest_a1, L1_RECEIVE1_Trans_request_a1, L1_RECEIVE1_Trans_response_a1, L1_RECEIVE1_Trans_response_debug_a1, L1_RECEIVE1_Trans_sender_a1};
                  </span><span class="tlx_comments">//_@1
                     </span><span class="tlx_logic">assign L1_RECEIVE2_recirc_a1 = L1_RECEIVE2_avail_a1 &amp;&amp; L1_RECEIVE2_blocked_a1;  </span><span class="tlx_comments">// Available transaction that is blocked; must recirc.
               //_|receive1
                  //_@1
                     </span><span class="tlx_logic">assign L1_RECEIVE1_blocked_a1 = L1_RECEIVE2_recirc_a1;
                     </span><span class="tlx_comments">// This trans is blocked (whether valid or not) if the next stage is recirculating.
               
               
               
               
               
               
            //_\end_source
            </span><span class="tlx_structure">`line 1369 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv&quot; 2
            </span><span class="tlx_comments">// A one-cycle backpressured stage to avoid 0-cycle loopback.
            //_|receive2
               //_@1
                  </span><span class="tlx_logic">assign L1_RECEIVE2_valid_request_a1 = L1_RECEIVE2_accepted_a1 &amp;&amp; L1_RECEIVE2_Trans_request_a1;
                  assign L1_RECEIVE2_valid_response_a1 = L1_RECEIVE2_accepted_a1 &amp;&amp; L1_RECEIVE2_Trans_response_a1;
                  </span><span class="tlx_comments">// Block requests that cannot loopback a response .
                  </span><span class="tlx_logic">assign L1_RECEIVE2_blocked_a1 = L1_RECEIVE2_valid_request_a1 &amp;&amp; L1_RingStop[ring_stop].L1_STALL0_blocked_a1;
                  assign L1_RECEIVE2_accepted_a1 = L1_RECEIVE2_avail_a1 &amp;&amp; ! L1_RECEIVE2_blocked_a1;
                  assign L1_RECEIVE2_generated_request_a1 =   L1_RingStop[ring_stop].L1_STALL0_accepted_a1 &amp;&amp;
                                       ! L1e_RingStop[ring_stop].L1_STALL0_Trans_response_debug_a1;
                  assign L1_RECEIVE2_OutstandingPackets_a0[16-1:0] =
                       L1_RECEIVE2_reset_a1 ? '0 :
                         (L1_RECEIVE2_OutstandingPackets_a1 +
                          (L1_RECEIVE2_generated_request_a1 ? 16'b1 : '0) -
                          (L1_RECEIVE2_valid_response_a1 ? 16'b1 : '0)
                         );
            </span><span class="tlx_comments">//_|passed  // Aligned to |receive2, but given a new pipeline name to provide a cleaner interface for this $passed output.
               //_@1
                  </span><span class="tlx_logic">assign Tb_RingStop_PASSED_passed_a1[ring_stop] = ! L1_RECEIVE2_reset_a1 &amp;&amp; L1_RECEIVE2_OutstandingPackets_a1 == '0 &amp;&amp; Tb_COUNT_CycCount_a1 &gt; 12; </span><span class="tlx_structure">end
      </span><span class="tlx_comments">// Connect with DUT.
      </span><span class="tlx_structure">for (ring_stop = 0; ring_stop &lt;= 3; ring_stop++) begin : L1e_RingStop </span><span class="tlx_declarations">logic L1_FIFO2_OUT_blocked_a1; logic L1_STALL0_avail_a1, L1_STALL0_avail_a2; logic L1_STALL0_reset_a1, L1_STALL0_reset_a2; logic [1:0] L1_STALL0_Trans_dest_a1, L1_STALL0_Trans_dest_a2; logic L1_STALL0_Trans_response_debug_a1; logic [1:0] L1_STALL0_Trans_sender_a1, L1_STALL0_Trans_sender_a2; </span><span class="tlx_comments">//_/ring_stop
         //_|stall0
            //_@1
               </span><span class="tlx_logic">assign L1_STALL0_avail_a1 = ! L1_STALL0_reset_a1 &amp;&amp; L1_Tb_RingStop[ring_stop].L1_SEND_avail_a1;
               </span><span class="tlx_comments">//_?$avail
                  //_/trans
                     </span><span class="tlx_logic">assign {RingStop_STALL0_Trans_cyc_cnt_a1[ring_stop], L1_STALL0_Trans_dest_a1[1:0], L1_STALL0_Trans_response_debug_a1, L1_STALL0_Trans_sender_a1[1:0]} = {L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_cyc_cnt_a1, L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_dest_a1, L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_response_debug_a1, L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_sender_a1};
               assign L1_STALL0_reset_a1 = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a1;
         </span><span class="tlx_comments">//_|fifo2_out
            //_@1
               </span><span class="tlx_logic">assign L1_FIFO2_OUT_blocked_a1 = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_blocked_a1;
            </span><span class="tlx_structure">end </span><span class="tlx_comments">//_/trans
      
      
   //_\end_source
   </span><span class="tlx_structure">`line 98 &quot;top.tlv&quot; 2
   
   
   </span><span class="tlx_comments">// Simulation control.
   </span><span class="tlx_logic">assign passed = &amp; Tb_RingStop_PASSED_passed_a1;
   assign failed = cyc_cnt &gt; 80; </span><span class="tlx_structure">endgenerate
</span><span class="tlx_comments">//_\SV
</span><span class="tlx_untouched">endmodule 
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"


genvar entry, ring_stop;


//
// Signals declared top-level.
//

// For $reset.
logic L0_reset_a0,
      L0_reset_a1;

// For /ring_stop|bp0/entry/accum/trans$cyc_cnt.
logic RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1 [3:0][(4)-1:0];

// For /ring_stop|bp0/entry/read_masked/trans$cyc_cnt.
logic RingStop_BP0_Entry_ReadMasked_Trans_cyc_cnt_a1 [3:0][(4)-1:0];

// For /ring_stop|bp0/fifo_head/trans$cyc_cnt.
logic RingStop_BP0_FifoHead_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|bp0/head/trans$cyc_cnt.
logic RingStop_BP0_Head_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|bp0/trans$cyc_cnt.
logic RingStop_BP0_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|bp1/trans$cyc_cnt.
logic RingStop_BP1_Trans_cyc_cnt_a0 [3:0],
      RingStop_BP1_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|bp2/trans$cyc_cnt.
logic RingStop_BP2_Trans_cyc_cnt_a0 [3:0],
      RingStop_BP2_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|bp3/trans$cyc_cnt.
logic RingStop_BP3_Trans_cyc_cnt_a0 [3:0],
      RingStop_BP3_Trans_cyc_cnt_a1 [3:0];

// For /ring_stop|rg$dest.
logic [1:0] RingStop_RG_dest_a1 [3:0],
            RingStop_RG_dest_a2 [3:0];

// For /ring_stop|rg$pass_on.
logic RingStop_RG_pass_on_a1 [3:0],
      RingStop_RG_pass_on_a2 [3:0];

// For /ring_stop|rg/trans$cyc_cnt.
logic RingStop_RG_Trans_cyc_cnt_a1 [3:0] /* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */,
      RingStop_RG_Trans_cyc_cnt_a2 [3:0] /* verilator lint_restore */;

// For /ring_stop|rg/trans$sender.
logic [1:0] RingStop_RG_Trans_sender_a1 [3:0] /* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */,
            RingStop_RG_Trans_sender_a2 [3:0] /* verilator lint_restore */;

// For /ring_stop|stall0/trans$cyc_cnt.
logic RingStop_STALL0_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL0_Trans_cyc_cnt_a2 [3:0];

// For /ring_stop|stall1/trans$cyc_cnt.
logic RingStop_STALL1_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL1_Trans_cyc_cnt_a2 [3:0];

// For /ring_stop|stall2/trans$cyc_cnt.
logic RingStop_STALL2_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL2_Trans_cyc_cnt_a2 [3:0];

// For /ring_stop|stall3/entry/trans$cyc_cnt.
logic RingStop_STALL3_Entry_Trans_cyc_cnt_a1 [3:0][(4)-1:0],
      RingStop_STALL3_Entry_Trans_cyc_cnt_a2 [3:0][(4)-1:0];

// For /ring_stop|stall3/trans$cyc_cnt.
logic RingStop_STALL3_Trans_cyc_cnt_a1 [3:0],
      RingStop_STALL3_Trans_cyc_cnt_a2 [3:0];

// For /tb/ring_stop|passed$passed.
logic [3:0] Tb_RingStop_PASSED_passed_a1;

// For /tb|count$CycCount.
logic [15:0] Tb_COUNT_CycCount_a0,
             Tb_COUNT_CycCount_a1;


//
// Scope: /ring_stop[3:0]
//

//
// Scope: /ring_stop|bp1
//

// Clock signals.
logic clkP_RingStop_BP1_avail_a1 [3:0];

//
// Scope: /ring_stop|bp2
//

// Clock signals.
logic clkP_RingStop_BP2_avail_a1 [3:0];

//
// Scope: /ring_stop|bp3
//

// Clock signals.
logic clkP_RingStop_BP3_avail_a1 [3:0];

//
// Scope: /ring_stop|rg
//

// Clock signals.
logic clkP_RingStop_RG_valid_a2 [3:0];

//
// Scope: /ring_stop|ring_out
//

// Clock signals.
logic clkP_RingStop_RING_OUT_trans_valid_a2 [3:0];
logic clkP_RingStop_RING_OUT_trans_valid_a3 [3:0];
logic clkP_RingStop_RING_OUT_trans_valid_a4 [3:0];

//
// Scope: /ring_stop|stall0
//

// Clock signals.
logic clkP_RingStop_STALL0_avail_a2 [3:0];

//
// Scope: /ring_stop|stall1
//

// Clock signals.
logic clkP_RingStop_STALL1_avail_a2 [3:0];

//
// Scope: /ring_stop|stall2
//

// Clock signals.
logic clkP_RingStop_STALL2_avail_a2 [3:0];

//
// Scope: /ring_stop|stall3
//

// Clock signals.
logic clkP_RingStop_STALL3_avail_a2 [3:0];

//
// Scope: /tb
//

//
// Scope: /tb/ring_stop[3:0]
//

//
// Scope: /tb/ring_stop|receive2
//

// Clock signals.
logic clkP_Tb_RingStop_RECEIVE2_avail_a1 [3:0];


generate

   // For $reset.
   always_ff @(posedge clk) L0_reset_a1 <= L0_reset_a0;


   //
   // Scope: /ring_stop[3:0]
   //
   for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1gen_RingStop

      //
      // Scope: |bp1
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP1_avail_a1 <= L1_RingStop[ring_stop].L1_BP1_avail_a0;

         // For $reset.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP1_reset_a1 <= L1_RingStop[ring_stop].L1_BP1_reset_a0;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_BP1_Trans_cyc_cnt_a1[ring_stop] <= RingStop_BP1_Trans_cyc_cnt_a0[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_BP1_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP1_Trans_dest_a1[1:0] <= L1_RingStop[ring_stop].L1_BP1_Trans_dest_a0[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_BP1_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP1_Trans_sender_a1[1:0] <= L1_RingStop[ring_stop].L1_BP1_Trans_sender_a0[1:0];




      //
      // Scope: |bp2
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP2_avail_a1 <= L1_RingStop[ring_stop].L1_BP2_avail_a0;

         // For $reset.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP2_reset_a1 <= L1_RingStop[ring_stop].L1_BP2_reset_a0;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_BP2_Trans_cyc_cnt_a1[ring_stop] <= RingStop_BP2_Trans_cyc_cnt_a0[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_BP2_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP2_Trans_dest_a1[1:0] <= L1_RingStop[ring_stop].L1_BP2_Trans_dest_a0[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_BP2_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP2_Trans_sender_a1[1:0] <= L1_RingStop[ring_stop].L1_BP2_Trans_sender_a0[1:0];




      //
      // Scope: |bp3
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP3_avail_a1 <= L1_RingStop[ring_stop].L1_BP3_avail_a0;

         // For $reset.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_BP3_reset_a1 <= L1_RingStop[ring_stop].L1_BP3_reset_a0;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_BP3_Trans_cyc_cnt_a1[ring_stop] <= RingStop_BP3_Trans_cyc_cnt_a0[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_BP3_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP3_Trans_dest_a1[1:0] <= L1_RingStop[ring_stop].L1_BP3_Trans_dest_a0[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_BP3_avail_a1[ring_stop]) L1_RingStop[ring_stop].L1_BP3_Trans_sender_a1[1:0] <= L1_RingStop[ring_stop].L1_BP3_Trans_sender_a0[1:0];




      //
      // Scope: |rg
      //

         // For $dest.
         always_ff @(posedge clk) RingStop_RG_dest_a2[ring_stop][1:0] <= RingStop_RG_dest_a1[ring_stop][1:0];

         // For $pass_on.
         always_ff @(posedge clk) RingStop_RG_pass_on_a2[ring_stop] <= RingStop_RG_pass_on_a1[ring_stop];


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clkP_RingStop_RG_valid_a2[ring_stop]) RingStop_RG_Trans_cyc_cnt_a2[ring_stop] <= RingStop_RG_Trans_cyc_cnt_a1[ring_stop];

            // For $sender.
            always_ff @(posedge clkP_RingStop_RG_valid_a2[ring_stop]) RingStop_RG_Trans_sender_a2[ring_stop][1:0] <= RingStop_RG_Trans_sender_a1[ring_stop][1:0];




      //
      // Scope: |ring_out
      //

         // For $avail.
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a2 <= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a3 <= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a2;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_avail_a4 <= L1b_RingStop[ring_stop].L1_RING_OUT_avail_a3;

         // For $reset.
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a2 <= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a3 <= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a2;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_reset_a4 <= L1b_RingStop[ring_stop].L1_RING_OUT_reset_a3;

         // For $trans_valid.
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2 <= L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a1;
         always_ff @(posedge clk) L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a3 <= L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a2 <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a1;
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a3 <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a2;
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a4 <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a3;

            // For $sender.
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a2[1:0] <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a1[1:0];
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a3[1:0] <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a2[1:0];
            always_ff @(posedge clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop]) L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a4[1:0] <= L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a3[1:0];




      //
      // Scope: |stall0
      //

         // For $avail.
         always_ff @(posedge clk) L1e_RingStop[ring_stop].L1_STALL0_avail_a2 <= L1e_RingStop[ring_stop].L1_STALL0_avail_a1;

         // For $reset.
         always_ff @(posedge clk) L1e_RingStop[ring_stop].L1_STALL0_reset_a2 <= L1e_RingStop[ring_stop].L1_STALL0_reset_a1;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_STALL0_Trans_cyc_cnt_a2[ring_stop] <= RingStop_STALL0_Trans_cyc_cnt_a1[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_STALL0_avail_a2[ring_stop]) L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a2[1:0] <= L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a1[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_STALL0_avail_a2[ring_stop]) L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a2[1:0] <= L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a1[1:0];




      //
      // Scope: |stall1
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL1_avail_a2 <= L1_RingStop[ring_stop].L1_STALL1_avail_a1;

         // For $blocked.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL1_blocked_a2 <= L1_RingStop[ring_stop].L1_STALL1_blocked_a1;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_STALL1_Trans_cyc_cnt_a2[ring_stop] <= RingStop_STALL1_Trans_cyc_cnt_a1[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_STALL1_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL1_Trans_dest_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL1_Trans_dest_a1[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_STALL1_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL1_Trans_sender_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL1_Trans_sender_a1[1:0];




      //
      // Scope: |stall2
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL2_avail_a2 <= L1_RingStop[ring_stop].L1_STALL2_avail_a1;

         // For $blocked.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL2_blocked_a2 <= L1_RingStop[ring_stop].L1_STALL2_blocked_a1;


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_STALL2_Trans_cyc_cnt_a2[ring_stop] <= RingStop_STALL2_Trans_cyc_cnt_a1[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_STALL2_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL2_Trans_dest_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL2_Trans_dest_a1[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_STALL2_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL2_Trans_sender_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL2_Trans_sender_a1[1:0];




      //
      // Scope: |stall3
      //

         // For $avail.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_avail_a2 <= L1_RingStop[ring_stop].L1_STALL3_avail_a1;

         // For $blocked.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_blocked_a2 <= L1_RingStop[ring_stop].L1_STALL3_blocked_a1;

         // For $two_valid.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_two_valid_a2 <= L1_RingStop[ring_stop].L1_STALL3_two_valid_a1;

         // For $valid_count.
         always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_valid_count_a2[$clog2((4)+1)-1:0] <= L1_RingStop[ring_stop].L1_STALL3_valid_count_a1[$clog2((4)+1)-1:0];


         //
         // Scope: /entry[(4)-1:0]
         //
         for (entry = 0; entry <= (4)-1; entry++) begin : L2gen_STALL3_Entry
            // For $state.
            always_ff @(posedge clk) L1_RingStop[ring_stop].L1_STALL3_Entry_state_a2[entry] <= L1_RingStop[ring_stop].L1_STALL3_Entry_state_a1[entry];


            //
            // Scope: /trans
            //

               // For $cyc_cnt.
               always_ff @(posedge clk) RingStop_STALL3_Entry_Trans_cyc_cnt_a2[ring_stop][entry] <= RingStop_STALL3_Entry_Trans_cyc_cnt_a1[ring_stop][entry];

               // For $dest.
               always_ff @(posedge clk) L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_dest_a2[1:0] <= L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_dest_a1[1:0];

               // For $sender.
               always_ff @(posedge clk) L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_sender_a2[1:0] <= L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_sender_a1[1:0];


         end

         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clk) RingStop_STALL3_Trans_cyc_cnt_a2[ring_stop] <= RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop];

            // For $dest.
            always_ff @(posedge clkP_RingStop_STALL3_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL3_Trans_dest_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL3_Trans_dest_a1[1:0];

            // For $sender.
            always_ff @(posedge clkP_RingStop_STALL3_avail_a2[ring_stop]) L1_RingStop[ring_stop].L1_STALL3_Trans_sender_a2[1:0] <= L1_RingStop[ring_stop].L1_STALL3_Trans_sender_a1[1:0];



   end

   //
   // Scope: /tb
   //


      //
      // Scope: /ring_stop[3:0]
      //
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1gen_Tb_RingStop

         //
         // Scope: |receive2
         //

            // For $OutstandingPackets.
            always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_OutstandingPackets_a1[16-1:0] <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_OutstandingPackets_a0[16-1:0];

            // For $avail.
            always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a0;

            // For $reset.
            always_ff @(posedge clk) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a0;


            //
            // Scope: /trans
            //

               // For $cyc_cnt.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_cyc_cnt_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_cyc_cnt_a0;

               // For $dest.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_dest_a1[1:0] <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_dest_a0[1:0];

               // For $request.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_request_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_request_a0;

               // For $response.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_a0;

               // For $response_debug.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_debug_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_debug_a0;

               // For $sender.
               always_ff @(posedge clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop]) L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_sender_a1 <= L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_sender_a0;



      end

      //
      // Scope: |count
      //

         // For $CycCount.
         always_ff @(posedge clk) Tb_COUNT_CycCount_a1[15:0] <= Tb_COUNT_CycCount_a0[15:0];





endgenerate



//
// Gated clocks.
//

generate



   //
   // Scope: /ring_stop[3:0]
   //
   for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1clk_RingStop

      //
      // Scope: |bp1
      //

         clk_gate gen_clkP_RingStop_BP1_avail_a1(clkP_RingStop_BP1_avail_a1[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_BP1_avail_a0, 1'b0);


      //
      // Scope: |bp2
      //

         clk_gate gen_clkP_RingStop_BP2_avail_a1(clkP_RingStop_BP2_avail_a1[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_BP2_avail_a0, 1'b0);


      //
      // Scope: |bp3
      //

         clk_gate gen_clkP_RingStop_BP3_avail_a1(clkP_RingStop_BP3_avail_a1[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_BP3_avail_a0, 1'b0);


      //
      // Scope: |rg
      //

         clk_gate gen_clkP_RingStop_RG_valid_a2(clkP_RingStop_RG_valid_a2[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RG_valid_a1, 1'b0);


      //
      // Scope: |ring_out
      //

         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a2(clkP_RingStop_RING_OUT_trans_valid_a2[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a1, 1'b0);
         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a3(clkP_RingStop_RING_OUT_trans_valid_a3[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a2, 1'b0);
         clk_gate gen_clkP_RingStop_RING_OUT_trans_valid_a4(clkP_RingStop_RING_OUT_trans_valid_a4[ring_stop], clk, 1'b1, L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a3, 1'b0);


      //
      // Scope: |stall0
      //

         clk_gate gen_clkP_RingStop_STALL0_avail_a2(clkP_RingStop_STALL0_avail_a2[ring_stop], clk, 1'b1, L1e_RingStop[ring_stop].L1_STALL0_avail_a1, 1'b0);


      //
      // Scope: |stall1
      //

         clk_gate gen_clkP_RingStop_STALL1_avail_a2(clkP_RingStop_STALL1_avail_a2[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_STALL1_avail_a1, 1'b0);


      //
      // Scope: |stall2
      //

         clk_gate gen_clkP_RingStop_STALL2_avail_a2(clkP_RingStop_STALL2_avail_a2[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_STALL2_avail_a1, 1'b0);


      //
      // Scope: |stall3
      //

         clk_gate gen_clkP_RingStop_STALL3_avail_a2(clkP_RingStop_STALL3_avail_a2[ring_stop], clk, 1'b1, L1_RingStop[ring_stop].L1_STALL3_avail_a1, 1'b0);

   end

   //
   // Scope: /tb
   //


      //
      // Scope: /ring_stop[3:0]
      //
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : L1clk_Tb_RingStop

         //
         // Scope: |receive2
         //

            clk_gate gen_clkP_Tb_RingStop_RECEIVE2_avail_a1(clkP_Tb_RingStop_RECEIVE2_avail_a1[ring_stop], clk, 1'b1, L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a0, 1'b0);

      end



endgenerate



//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      //
      // Scope: /ring_stop[3:0]
      //
      for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : \/ring_stop 

         //
         // Scope: |arb_out
         //
         if (1) begin : \|arb_out 
            logic  \@1$avail ;
            assign \@1$avail = L1c_RingStop[ring_stop].L1_ARB_OUT_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1c_RingStop[ring_stop].L1_ARB_OUT_blocked_a1;
            logic  \@1$ready ;
            assign \@1$ready = L1c_RingStop[ring_stop].L1_ARB_OUT_ready_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1c_RingStop[ring_stop].L1_ARB_OUT_reset_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1c_RingStop[ring_stop].L1_ARB_OUT_Trans_cyc_cnt_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1c_RingStop[ring_stop].L1_ARB_OUT_Trans_sender_a1;
            end
         end

         //
         // Scope: |bp0
         //
         if (1) begin : \|bp0 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_BP0_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_BP0_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_BP0_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_BP0_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_BP0_reset_in_a1;
            logic  \@1$trans_valid ;
            assign \@1$trans_valid = L1_RingStop[ring_stop].L1_BP0_trans_valid_a1;

            //
            // Scope: /entry[(4)-1:0]
            //
            for (entry = 0; entry <= (4)-1; entry++) begin : \/entry 
               logic  \@1$is_head ;
               assign \@1$is_head = L1_RingStop[ring_stop].L2b_BP0_Entry[entry].L2_is_head_a1;
               logic  \@1$pop ;
               assign \@1$pop = L1_RingStop[ring_stop].L2b_BP0_Entry[entry].L2_pop_a1;

               //
               // Scope: /accum
               //
               if (1) begin : \/accum 

                  //
                  // Scope: /trans
                  //
                  if (1) begin : \/trans 
                     logic  \@1$cyc_cnt ;
                     assign \@1$cyc_cnt = RingStop_BP0_Entry_Accum_Trans_cyc_cnt_a1[ring_stop][entry];
                     logic [1:0] \@1$dest ;
                     assign \@1$dest = L1_RingStop[ring_stop].L1_BP0_Entry_Accum_Trans_dest_a1[entry];
                     logic [1:0] \@1$sender ;
                     assign \@1$sender = L1_RingStop[ring_stop].L1_BP0_Entry_Accum_Trans_sender_a1[entry];
                  end
               end

               //
               // Scope: /read_masked
               //
               if (1) begin : \/read_masked 

                  //
                  // Scope: /trans
                  //
                  if (1) begin : \/trans 
                     logic  \@1$cyc_cnt ;
                     assign \@1$cyc_cnt = RingStop_BP0_Entry_ReadMasked_Trans_cyc_cnt_a1[ring_stop][entry];
                     logic [1:0] \@1$dest ;
                     assign \@1$dest = L1_RingStop[ring_stop].L2b_BP0_Entry[entry].L2_ReadMasked_Trans_dest_a1;
                     logic [1:0] \@1$sender ;
                     assign \@1$sender = L1_RingStop[ring_stop].L2b_BP0_Entry[entry].L2_ReadMasked_Trans_sender_a1;
                  end
               end
            end

            //
            // Scope: /fifo_head
            //
            if (1) begin : \/fifo_head 
               logic  \@1$avail ;
               assign \@1$avail = L1_RingStop[ring_stop].L1_BP0_FifoHead_avail_a1;

               //
               // Scope: /trans
               //
               if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = RingStop_BP0_FifoHead_Trans_cyc_cnt_a1[ring_stop];
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_RingStop[ring_stop].L1_BP0_FifoHead_Trans_dest_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_RingStop[ring_stop].L1_BP0_FifoHead_Trans_sender_a1;
               end
            end

            //
            // Scope: /head
            //
            if (1) begin : \/head 
               logic  \@1$avail ;
               assign \@1$avail = L1_RingStop[ring_stop].L1_BP0_Head_avail_a1;

               //
               // Scope: /trans
               //
               if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = RingStop_BP0_Head_Trans_cyc_cnt_a1[ring_stop];
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_RingStop[ring_stop].L1_BP0_Head_Trans_dest_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_RingStop[ring_stop].L1_BP0_Head_Trans_sender_a1;
               end
            end

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_BP0_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_BP0_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_BP0_Trans_sender_a1;
            end
         end

         //
         // Scope: |bp1
         //
         if (1) begin : \|bp1 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_BP1_accepted_a1;
            logic  \@0$avail ;
            assign \@0$avail = L1_RingStop[ring_stop].L1_BP1_avail_a0;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_BP1_blocked_a1;
            logic  \@1$recirc ;
            assign \@1$recirc = L1_RingStop[ring_stop].L1_BP1_recirc_a1;
            logic  \@0$reset ;
            assign \@0$reset = L1_RingStop[ring_stop].L1_BP1_reset_a0;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_BP1_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@0$cyc_cnt ;
               assign \@0$cyc_cnt = RingStop_BP1_Trans_cyc_cnt_a0[ring_stop];
               logic [1:0] \@0$dest ;
               assign \@0$dest = L1_RingStop[ring_stop].L1_BP1_Trans_dest_a0;
               logic [1:0] \@0$sender ;
               assign \@0$sender = L1_RingStop[ring_stop].L1_BP1_Trans_sender_a0;
            end
         end

         //
         // Scope: |bp2
         //
         if (1) begin : \|bp2 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_BP2_accepted_a1;
            logic  \@0$avail ;
            assign \@0$avail = L1_RingStop[ring_stop].L1_BP2_avail_a0;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_BP2_blocked_a1;
            logic  \@1$recirc ;
            assign \@1$recirc = L1_RingStop[ring_stop].L1_BP2_recirc_a1;
            logic  \@0$reset ;
            assign \@0$reset = L1_RingStop[ring_stop].L1_BP2_reset_a0;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_BP2_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@0$cyc_cnt ;
               assign \@0$cyc_cnt = RingStop_BP2_Trans_cyc_cnt_a0[ring_stop];
               logic [1:0] \@0$dest ;
               assign \@0$dest = L1_RingStop[ring_stop].L1_BP2_Trans_dest_a0;
               logic [1:0] \@0$sender ;
               assign \@0$sender = L1_RingStop[ring_stop].L1_BP2_Trans_sender_a0;
            end
         end

         //
         // Scope: |bp3
         //
         if (1) begin : \|bp3 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_BP3_accepted_a1;
            logic  \@0$avail ;
            assign \@0$avail = L1_RingStop[ring_stop].L1_BP3_avail_a0;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_BP3_blocked_a1;
            logic  \@1$local ;
            assign \@1$local = L1_RingStop[ring_stop].L1_BP3_local_a1;
            logic  \@1$recirc ;
            assign \@1$recirc = L1_RingStop[ring_stop].L1_BP3_recirc_a1;
            logic  \@0$reset ;
            assign \@0$reset = L1_RingStop[ring_stop].L1_BP3_reset_a0;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_BP3_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@0$cyc_cnt ;
               assign \@0$cyc_cnt = RingStop_BP3_Trans_cyc_cnt_a0[ring_stop];
               logic [1:0] \@0$dest ;
               assign \@0$dest = L1_RingStop[ring_stop].L1_BP3_Trans_dest_a0;
               logic [1:0] \@0$sender ;
               assign \@0$sender = L1_RingStop[ring_stop].L1_BP3_Trans_sender_a0;
            end
         end

         //
         // Scope: |bypass
         //
         if (1) begin : \|bypass 
            logic  \@1$accepted ;
            assign \@1$accepted = L1c_RingStop[ring_stop].L1_BYPASS_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_BYPASS_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1c_RingStop[ring_stop].L1_BYPASS_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_BYPASS_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1c_RingStop[ring_stop].L1_BYPASS_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1_RingStop[ring_stop].L1_BYPASS_Trans_cyc_cnt_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_BYPASS_Trans_sender_a1;
            end
         end

         //
         // Scope: |fifo2_out
         //
         if (1) begin : \|fifo2_out 
            logic  \@1$accepted ;
            assign \@1$accepted = L1d_RingStop[ring_stop].L1_FIFO2_OUT_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1c_RingStop[ring_stop].L1_FIFO2_OUT_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1e_RingStop[ring_stop].L1_FIFO2_OUT_blocked_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1d_RingStop[ring_stop].L1_FIFO2_OUT_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1c_RingStop[ring_stop].L1_FIFO2_OUT_Trans_cyc_cnt_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1c_RingStop[ring_stop].L1_FIFO2_OUT_Trans_sender_a1;
            end
         end

         //
         // Scope: |rg
         //
         if (1) begin : \|rg 
            logic [1:0] \@1$dest ;
            assign \@1$dest = RingStop_RG_dest_a1[ring_stop];
            logic  \@1$pass_on ;
            assign \@1$pass_on = RingStop_RG_pass_on_a1[ring_stop];
            logic  \@1$passed_on ;
            assign \@1$passed_on = L1b_RingStop[ring_stop].L1_RG_passed_on_a1;
            logic  \@1$valid ;
            assign \@1$valid = L1b_RingStop[ring_stop].L1_RG_valid_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_RG_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$sender ;
               assign \@1$sender = RingStop_RG_Trans_sender_a1[ring_stop];
            end
         end

         //
         // Scope: |ring_in
         //
         if (1) begin : \|ring_in 
            logic  \@1$accepted ;
            assign \@1$accepted = L1b_RingStop[ring_stop].L1_RING_IN_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_RING_IN_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1b_RingStop[ring_stop].L1_RING_IN_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_RING_IN_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1b_RingStop[ring_stop].L1_RING_IN_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1_RingStop[ring_stop].L1_RING_IN_Trans_cyc_cnt_a1;
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_RING_IN_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_RING_IN_Trans_sender_a1;
            end
         end

         //
         // Scope: |ring_out
         //
         if (1) begin : \|ring_out 
            logic  \@4$accepted ;
            assign \@4$accepted = L1c_RingStop[ring_stop].L1_RING_OUT_accepted_a4;
            logic  \@1$avail ;
            assign \@1$avail = L1b_RingStop[ring_stop].L1_RING_OUT_avail_a1;
            logic  \@4$blocked ;
            assign \@4$blocked = L1c_RingStop[ring_stop].L1_RING_OUT_blocked_a4;
            logic  \@1$reset ;
            assign \@1$reset = L1b_RingStop[ring_stop].L1_RING_OUT_reset_a1;
            logic  \@4$reset_in ;
            assign \@4$reset_in = L1c_RingStop[ring_stop].L1_RING_OUT_reset_in_a4;
            logic  \@1$trans_valid ;
            assign \@1$trans_valid = L1b_RingStop[ring_stop].L1_RING_OUT_trans_valid_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1b_RingStop[ring_stop].L1_RING_OUT_Trans_cyc_cnt_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1b_RingStop[ring_stop].L1_RING_OUT_Trans_sender_a1;
            end
         end

         //
         // Scope: |stall0
         //
         if (1) begin : \|stall0 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_STALL0_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1e_RingStop[ring_stop].L1_STALL0_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_STALL0_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1e_RingStop[ring_stop].L1_STALL0_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_STALL0_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_STALL0_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1e_RingStop[ring_stop].L1_STALL0_Trans_dest_a1;
               logic  \@1$response_debug ;
               assign \@1$response_debug = L1e_RingStop[ring_stop].L1_STALL0_Trans_response_debug_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1e_RingStop[ring_stop].L1_STALL0_Trans_sender_a1;
            end
         end

         //
         // Scope: |stall1
         //
         if (1) begin : \|stall1 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_STALL1_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_STALL1_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_STALL1_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_STALL1_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_STALL1_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_STALL1_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_STALL1_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_STALL1_Trans_sender_a1;
            end
         end

         //
         // Scope: |stall2
         //
         if (1) begin : \|stall2 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_STALL2_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_STALL2_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_STALL2_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_STALL2_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_STALL2_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_STALL2_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_STALL2_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_STALL2_Trans_sender_a1;
            end
         end

         //
         // Scope: |stall3
         //
         if (1) begin : \|stall3 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_RingStop[ring_stop].L1_STALL3_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_RingStop[ring_stop].L1_STALL3_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_RingStop[ring_stop].L1_STALL3_blocked_a1;
            logic  \@1$bypass ;
            assign \@1$bypass = L1_RingStop[ring_stop].L1_STALL3_bypass_a1;
            logic  \@2$empty ;
            assign \@2$empty = L1_RingStop[ring_stop].L1_STALL3_empty_a2;
            logic  \@2$full ;
            assign \@2$full = L1_RingStop[ring_stop].L1_STALL3_full_a2;
            logic  \@1$grow ;
            assign \@1$grow = L1_RingStop[ring_stop].L1_STALL3_grow_a1;
            logic  \@1$out_blocked ;
            assign \@1$out_blocked = L1_RingStop[ring_stop].L1_STALL3_out_blocked_a1;
            logic  \@1$push ;
            assign \@1$push = L1_RingStop[ring_stop].L1_STALL3_push_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_RingStop[ring_stop].L1_STALL3_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_RingStop[ring_stop].L1_STALL3_reset_in_a1;
            logic  \@1$shrink ;
            assign \@1$shrink = L1_RingStop[ring_stop].L1_STALL3_shrink_a1;
            logic  \@1$two_valid ;
            assign \@1$two_valid = L1_RingStop[ring_stop].L1_STALL3_two_valid_a1;
            logic [$clog2((4)+1)-1:0] \@1$valid_count ;
            assign \@1$valid_count = L1_RingStop[ring_stop].L1_STALL3_valid_count_a1;
            logic  \@1$would_bypass ;
            assign \@1$would_bypass = L1_RingStop[ring_stop].L1_STALL3_would_bypass_a1;

            //
            // Scope: /entry[(4)-1:0]
            //
            for (entry = 0; entry <= (4)-1; entry++) begin : \/entry 
               logic  \@2$is_head ;
               assign \@2$is_head = L1_RingStop[ring_stop].L2c_STALL3_Entry[entry].L2_is_head_a2;
               logic  \@1$is_tail ;
               assign \@1$is_tail = L1_RingStop[ring_stop].L2b_STALL3_Entry[entry].L2_is_tail_a1;
               logic  \@2$next_entry_state ;
               assign \@2$next_entry_state = L1_RingStop[ring_stop].L2c_STALL3_Entry[entry].L2_next_entry_state_a2;
               logic  \@2$prev_entry_state ;
               assign \@2$prev_entry_state = L1_RingStop[ring_stop].L2c_STALL3_Entry[entry].L2_prev_entry_state_a2;
               logic  \@1$prev_entry_was_tail ;
               assign \@1$prev_entry_was_tail = L1_RingStop[ring_stop].L1_STALL3_Entry_prev_entry_was_tail_a1[entry];
               logic  \@1$push ;
               assign \@1$push = L1_RingStop[ring_stop].L1_STALL3_Entry_push_a1[entry];
               logic  \@2$reconstructed_is_tail ;
               assign \@2$reconstructed_is_tail = L1_RingStop[ring_stop].L1_STALL3_Entry_reconstructed_is_tail_a2[entry];
               logic  \@2$reconstructed_valid ;
               assign \@2$reconstructed_valid = L1_RingStop[ring_stop].L2c_STALL3_Entry[entry].L2_reconstructed_valid_a2;
               logic  \@1$state ;
               assign \@1$state = L1_RingStop[ring_stop].L1_STALL3_Entry_state_a1[entry];
               logic  \@1$valid ;
               assign \@1$valid = L1_RingStop[ring_stop].L2b_STALL3_Entry[entry].L2_valid_a1;

               //
               // Scope: /trans
               //
               if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = RingStop_STALL3_Entry_Trans_cyc_cnt_a1[ring_stop][entry];
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_dest_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_RingStop[ring_stop].L2d_STALL3_Entry[entry].L2_Trans_sender_a1;
               end
            end

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = RingStop_STALL3_Trans_cyc_cnt_a1[ring_stop];
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_RingStop[ring_stop].L1_STALL3_Trans_dest_a1;
               logic [1:0] \@1$sender ;
               assign \@1$sender = L1_RingStop[ring_stop].L1_STALL3_Trans_sender_a1;
            end
         end
      end

      //
      // Scope: /tb
      //
      if (1) begin : \/tb 

         //
         // Scope: /ring_stop[3:0]
         //
         for (ring_stop = 0; ring_stop <= 3; ring_stop++) begin : \/ring_stop 

            //
            // Scope: |passed
            //
            if (1) begin : \|passed 
               logic  \@1$passed ;
               assign \@1$passed = Tb_RingStop_PASSED_passed_a1[ring_stop];
            end

            //
            // Scope: |receive1
            //
            if (1) begin : \|receive1 
               logic  \@1$accepted ;
               assign \@1$accepted = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_accepted_a1;
               logic  \@1$avail ;
               assign \@1$avail = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_avail_a1;
               logic  \@1$blocked ;
               assign \@1$blocked = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_blocked_a1;
               logic  \@1$reset ;
               assign \@1$reset = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_reset_a1;
               logic  \@1$reset_in ;
               assign \@1$reset_in = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_reset_in_a1;

               //
               // Scope: /trans
               //
               if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_dest_a1;
                  logic  \@1$request ;
                  assign \@1$request = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_request_a1;
                  logic  \@1$response ;
                  assign \@1$response = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_response_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_RingStop[ring_stop].L1_RECEIVE1_Trans_sender_a1;
               end
            end

            //
            // Scope: |receive2
            //
            if (1) begin : \|receive2 
               logic [16-1:0] \@0$OutstandingPackets ;
               assign \@0$OutstandingPackets = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_OutstandingPackets_a0;
               logic  \@1$accepted ;
               assign \@1$accepted = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_accepted_a1;
               logic  \@0$avail ;
               assign \@0$avail = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_avail_a0;
               logic  \@1$blocked ;
               assign \@1$blocked = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_blocked_a1;
               logic  \@1$generated_request ;
               assign \@1$generated_request = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_generated_request_a1;
               logic  \@1$recirc ;
               assign \@1$recirc = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_recirc_a1;
               logic  \@0$reset ;
               assign \@0$reset = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_reset_a0;
               logic  \@1$valid_request ;
               assign \@1$valid_request = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_valid_request_a1;
               logic  \@1$valid_response ;
               assign \@1$valid_response = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_valid_response_a1;

               //
               // Scope: /trans
               //
               if (1) begin : \/trans 
                  logic  \@0$cyc_cnt ;
                  assign \@0$cyc_cnt = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_cyc_cnt_a0;
                  logic [1:0] \@0$dest ;
                  assign \@0$dest = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_dest_a0;
                  logic  \@0$request ;
                  assign \@0$request = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_request_a0;
                  logic  \@0$response ;
                  assign \@0$response = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_a0;
                  logic  \@0$response_debug ;
                  assign \@0$response_debug = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_response_debug_a0;
                  logic  \@0$sender ;
                  assign \@0$sender = L1_Tb_RingStop[ring_stop].L1_RECEIVE2_Trans_sender_a0;
               end
            end

            //
            // Scope: |send
            //
            if (1) begin : \|send 
               logic  \@1$avail ;
               assign \@1$avail = L1_Tb_RingStop[ring_stop].L1_SEND_avail_a1;
               logic  \@1$reset ;
               assign \@1$reset = L1_Tb_RingStop[ring_stop].L1_SEND_reset_a1;
               logic  \@1$valid_in ;
               assign \@1$valid_in = L1_Tb_RingStop[ring_stop].L1_SEND_valid_in_a1;

               //
               // Scope: /gen_trans
               //
               if (1) begin : \/gen_trans 
                  logic [15:0] \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_dest_a1;
                  logic [1:0] \@1$dest_tmp ;
                  assign \@1$dest_tmp = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_dest_tmp_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_RingStop[ring_stop].L1_SEND_GenTrans_sender_a1;
               end

               //
               // Scope: /trans_out
               //
               if (1) begin : \/trans_out 
                  logic [15:0] \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_dest_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_response_debug_a1;
                  logic [1:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_RingStop[ring_stop].L1_SEND_TransOut_sender_a1;
               end
            end
         end

         //
         // Scope: |count
         //
         if (1) begin : \|count 
            logic [15:0] \@0$CycCount ;
            assign \@0$CycCount = Tb_COUNT_CycCount_a0;
         end
      end


   end

endgenerate




generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.

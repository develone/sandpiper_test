<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 4055, 47, 0, 0, 33, 0, 0, 0, 'opacity: 0.1', 7653, 'opacity: 0.1', 3726, 'opacity: 0.1'],
      ['top.sv', 0, 4055, 66, 0, 0, 70, 0, 0, 0, 'opacity: 0.1', 7748, 'opacity: 0.1', 3736, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 17, 0, 34, 0, 0, 86, 'opacity: 0.1', 450, 'opacity: 0.1', 75, 'opacity: 0.1'],
      ['SV Total', 0, 4055, 66, 17, 0, 104, 0, 0, 86, 'opacity: 0.1', 8198, 'opacity: 0.1', 3811, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;





</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0;





</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
</span><span class="tlx_comments">/*
 The MIT License (MIT)
 Copyright (c) 2019 Yuya Kudo.
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the &quot;Software&quot;), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

</span><span class="tlx_untouched">interface uart_if
  #(parameter
    DATA_WIDTH = 8);

   logic                  sig;
   logic [DATA_WIDTH-1:0] data;
   logic                  valid;
   logic                  ready;

   modport tx(output sig,
              input  data,
              input  valid,
              output ready);

   modport rx(input  sig,
              output data,
              output valid,
              input  ready);

endinterface

</span><span class="tlx_comments">/*
 The MIT License (MIT)

 Copyright (c) 2019 Yuya Kudo.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the &quot;Software&quot;), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

//`include &quot;uart_if.sv&quot;

</span><span class="tlx_untouched">module uart
  #(parameter
    </span><span class="tlx_comments">/*
     You can specify the following three parameters.
     1. DATA_WIDTH : width of data that is transmited by this module
     2. BAUD_RATE  : baud rate of output uart signal
     3. CLK_FREQ   : freqency of input clock signal
    */
    </span><span class="tlx_untouched">DATA_WIDTH = 8,
    BAUD_RATE  = 115200,
    CLK_FREQ   = 100_000_000)
   (uart_if.rx   rxif,
    uart_if.tx   txif,
    input logic  clk,
    input logic  rstn);

   uart_tx #(DATA_WIDTH, BAUD_RATE, CLK_FREQ)
   </span><span class="tlx_comments">/* verilator lint_off PINMISSING */
   </span><span class="tlx_untouched">uart_tx_inst(.rxif(rxif),
   </span><span class="tlx_comments">/* verilator lint_off PINMISSING */
                </span><span class="tlx_untouched">.clk(clk),
                .rstn(rstn));

   uart_rx #(DATA_WIDTH, BAUD_RATE, CLK_FREQ)
   </span><span class="tlx_comments">/* verilator lint_off PINMISSING */
   </span><span class="tlx_untouched">uart_rx_inst(.txif(txif),
   </span><span class="tlx_comments">/* verilator lint_off PINMISSING */
                </span><span class="tlx_untouched">.clk(clk),
                .rstn(rstn));
endmodule
</span><span class="tlx_comments">/*
 The MIT License (MIT)

 Copyright (c) 2019 Yuya Kudo.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the &quot;Software&quot;), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

//`include &quot;uart_if.sv&quot;

</span><span class="tlx_untouched">module uart_rx
  #(parameter
    </span><span class="tlx_comments">/*
     You can specify the following three parameters.
     1. DATA_WIDTH : width of data that is transmited by this module
     2. BAUD_RATE  : baud rate of output uart signal
     3. CLK_FREQ   : freqency of input clock signal
    */
    </span><span class="tlx_untouched">DATA_WIDTH = 8,
    BAUD_RATE  = 115200,
    CLK_FREQ   = 100_000_000,

    localparam
    LB_DATA_WIDTH    = $clog2(DATA_WIDTH),
    PULSE_WIDTH      = CLK_FREQ / BAUD_RATE,
    LB_PULSE_WIDTH   = $clog2(PULSE_WIDTH),
    HALF_PULSE_WIDTH = PULSE_WIDTH / 2)
   (uart_if.rx  rxif,
    input logic clk,
    input logic rstn);

   </span><span class="tlx_comments">//-----------------------------------------------------------------------------
   // noise removing filter
   </span><span class="tlx_untouched">function majority5(input [4:0] val);
      case(val)
        5'b00000: majority5 = 0;
        5'b00001: majority5 = 0;
        5'b00010: majority5 = 0;
        5'b00100: majority5 = 0;
        5'b01000: majority5 = 0;
        5'b10000: majority5 = 0;
        5'b00011: majority5 = 0;
        5'b00101: majority5 = 0;
        5'b01001: majority5 = 0;
        5'b10001: majority5 = 0;
        5'b00110: majority5 = 0;
        5'b01010: majority5 = 0;
        5'b10010: majority5 = 0;
        5'b01100: majority5 = 0;
        5'b10100: majority5 = 0;
        5'b11000: majority5 = 0;
        default:  majority5 = 1;
      endcase
   endfunction

   </span><span class="tlx_comments">//-----------------------------------------------------------------------------
   // description about input signal
   </span><span class="tlx_untouched">logic [1:0] sampling_cnt;
   logic [4:0] sig_q;
   logic       sig_r;

   always_ff @(posedge clk) begin
      if(!rstn) begin
         sampling_cnt &lt;= 0;
         sig_q        &lt;= 5'b11111;
         sig_r        &lt;= 1;
      end
      else begin
         </span><span class="tlx_comments">// connect to deserializer after removing noise
         </span><span class="tlx_untouched">if(sampling_cnt == 0) begin
            sig_q &lt;= {rxif.sig, sig_q[4:1]};
         end

         sig_r        &lt;= majority5(sig_q);
         sampling_cnt &lt;= sampling_cnt + 1;
      end
   end

   </span><span class="tlx_comments">//----------------------------------------------------------------
   // description about receive UART signal
   </span><span class="tlx_untouched">typedef enum logic [1:0] {STT_DATA,
                             STT_STOP,
                             STT_WAIT
                             } statetype;

   statetype                 state;

   logic [DATA_WIDTH-1:0]   data_tmp_r;
   logic [LB_DATA_WIDTH:0]  data_cnt;
   logic [LB_PULSE_WIDTH:0] clk_cnt;
   logic                    rx_done;

   always_ff @(posedge clk) begin
      if(!rstn) begin
         state      &lt;= STT_WAIT;
         data_tmp_r &lt;= 0;
         data_cnt   &lt;= 0;
         clk_cnt    &lt;= 0;
      end
      else begin

         </span><span class="tlx_comments">//-----------------------------------------------------------------------------
         // 3-state FSM
         </span><span class="tlx_untouched">case(state)

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_DATA
           // behavior   : deserialize and recieve data
           // next state : when all data have recieved -&gt; STT_STOP
           </span><span class="tlx_untouched">STT_DATA: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else begin
                 data_tmp_r &lt;= {sig_r, data_tmp_r[DATA_WIDTH-1:1]};
                 clk_cnt    &lt;= PULSE_WIDTH;

                 if(data_cnt == DATA_WIDTH - 1) begin
                    state &lt;= STT_STOP;
                 end
                 else begin
                    data_cnt &lt;= data_cnt + 1;
                 end
              end
           end

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_STOP
           // behavior   : watch stop bit
           // next state : STT_WAIT
           </span><span class="tlx_untouched">STT_STOP: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else if(sig_r) begin
                 state &lt;= STT_WAIT;
              end
           end

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_WAIT
           // behavior   : watch start bit
           // next state : when start bit is observed -&gt; STT_DATA
           </span><span class="tlx_untouched">STT_WAIT: begin
              if(sig_r == 0) begin
                 clk_cnt  &lt;= PULSE_WIDTH + HALF_PULSE_WIDTH;
                 data_cnt &lt;= 0;
                 state    &lt;= STT_DATA;
              end
           end

           default: begin
              state &lt;= STT_WAIT;
           end
         endcase
      end
   end

   assign rx_done = (state == STT_STOP) &amp;&amp; (clk_cnt == 0);

   </span><span class="tlx_comments">//-----------------------------------------------------------------------------
   // description about output signal
   </span><span class="tlx_untouched">logic [DATA_WIDTH-1:0] data_r;
   logic                  valid_r;

   always_ff @(posedge clk) begin
      if(!rstn) begin
         data_r  &lt;= 0;
         valid_r &lt;= 0;
      end
      else if(rx_done &amp;&amp; !valid_r) begin
         valid_r &lt;= 1;
         data_r  &lt;= data_tmp_r;
      end
      else if(valid_r &amp;&amp; rxif.ready) begin
         valid_r &lt;= 0;
      end
   end

   assign rxif.data  = data_r;
   assign rxif.valid = valid_r;

endmodule
</span><span class="tlx_comments">/*
 The MIT License (MIT)

 Copyright (c) 2019 Yuya Kudo.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the &quot;Software&quot;), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

//`include &quot;uart_if.sv&quot;

</span><span class="tlx_untouched">module uart_tx
  #(parameter
    </span><span class="tlx_comments">/*
     You can specify the following three parameters.
     1. DATA_WIDTH : width of data that is transmited by this module
     2. BAUD_RATE  : baud rate of output uart signal
     3. CLK_FREQ   : freqency of input clock signal
    */
    </span><span class="tlx_untouched">DATA_WIDTH = 8,
    BAUD_RATE  = 115200,
    CLK_FREQ   = 100_000_000,

    localparam
    LB_DATA_WIDTH    = $clog2(DATA_WIDTH),
    PULSE_WIDTH      = CLK_FREQ / BAUD_RATE,
    LB_PULSE_WIDTH   = $clog2(PULSE_WIDTH),
    HALF_PULSE_WIDTH = PULSE_WIDTH / 2)
   (uart_if.tx   txif,
    input logic  clk,
    input logic  rstn);

   typedef enum logic [1:0] {STT_DATA,
                             STT_STOP,
                             STT_WAIT
                             } statetype;

   statetype                 state;

   logic [DATA_WIDTH-1:0]     data_r;
   logic                      sig_r;
   logic                      ready_r;
   logic [LB_DATA_WIDTH-1:0]  data_cnt;
   logic [LB_PULSE_WIDTH:0]   clk_cnt;

   always_ff @(posedge clk) begin
      if(!rstn) begin
         state    &lt;= STT_WAIT;
         sig_r    &lt;= 1;
         data_r   &lt;= 0;
         ready_r  &lt;= 1;
         data_cnt &lt;= 0;
         clk_cnt  &lt;= 0;
      end
      else begin

         </span><span class="tlx_comments">//-----------------------------------------------------------------------------
         // 3-state FSM
         </span><span class="tlx_untouched">case(state)

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_DATA
           // behavior   : serialize and transmit data
           // next state : when all data have transmited -&gt; STT_STOP
           </span><span class="tlx_untouched">STT_DATA: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else begin
                 sig_r   &lt;= data_r[data_cnt];
                 clk_cnt &lt;= PULSE_WIDTH;

                 if(data_cnt == DATA_WIDTH - 1) begin
                    state &lt;= STT_STOP;
                 end
                 else begin
                    data_cnt &lt;= data_cnt + 1;
                 end
              end
           end

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_STOP
           // behavior   : assert stop bit
           // next state : STT_WAIT
           </span><span class="tlx_untouched">STT_STOP: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else begin
                 state   &lt;= STT_WAIT;
                 sig_r   &lt;= 1;
                 clk_cnt &lt;= PULSE_WIDTH + HALF_PULSE_WIDTH;
              end
           end

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_WAIT
           // behavior   : watch valid signal, and assert start bit when valid signal assert
           // next state : when valid signal assert -&gt; STT_STAT
           </span><span class="tlx_untouched">STT_WAIT: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else if(!ready_r) begin
                 ready_r &lt;= 1;
              end
              else if(txif.valid) begin
                 state    &lt;= STT_DATA;
                 sig_r    &lt;= 0;
                 data_r   &lt;= txif.data;
                 ready_r  &lt;= 0;
                 data_cnt &lt;= 0;
                 clk_cnt  &lt;= PULSE_WIDTH;
              end
           end

           default: begin
              state &lt;= STT_WAIT;
           end
         endcase
      end
   end

   assign txif.sig   = sig_r;
   assign txif.ready = ready_r;

endmodule   </span><span class="tlx_comments">// =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
</span><span class="tlx_structure">\TLV
   </span><span class="tlx_logic">$reset = *reset;

   </span><span class="tlx_comments">//...

   // Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">*passed = *cyc_cnt &gt; 40;
   *failed = 1'b0;
</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
/*
 The MIT License (MIT)
 Copyright (c) 2019 Yuya Kudo.
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the &quot;Software&quot;), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

</span><span class="tlx_untouched">interface uart_if
  #(parameter
    DATA_WIDTH = 8);

   logic                  sig;
   logic [DATA_WIDTH-1:0] data;
   logic                  valid;
   logic                  ready;

   modport tx(output sig,
              input  data,
              input  valid,
              output ready);

   modport rx(input  sig,
              output data,
              output valid,
              input  ready);

endinterface

</span><span class="tlx_comments">/*
 The MIT License (MIT)

 Copyright (c) 2019 Yuya Kudo.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the &quot;Software&quot;), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

//`include &quot;uart_if.sv&quot;

</span><span class="tlx_untouched">module uart
  #(parameter
    </span><span class="tlx_comments">/*
     You can specify the following three parameters.
     1. DATA_WIDTH : width of data that is transmited by this module
     2. BAUD_RATE  : baud rate of output uart signal
     3. CLK_FREQ   : freqency of input clock signal
    */
    </span><span class="tlx_untouched">DATA_WIDTH = 8,
    BAUD_RATE  = 115200,
    CLK_FREQ   = 100_000_000)
   (uart_if.rx   rxif,
    uart_if.tx   txif,
    input logic  clk,
    input logic  rstn);

   uart_tx #(DATA_WIDTH, BAUD_RATE, CLK_FREQ)
   </span><span class="tlx_comments">/* verilator lint_off PINMISSING */
   </span><span class="tlx_untouched">uart_tx_inst(.rxif(rxif),
   </span><span class="tlx_comments">/* verilator lint_off PINMISSING */
                </span><span class="tlx_untouched">.clk(clk),
                .rstn(rstn));

   uart_rx #(DATA_WIDTH, BAUD_RATE, CLK_FREQ)
   </span><span class="tlx_comments">/* verilator lint_off PINMISSING */
   </span><span class="tlx_untouched">uart_rx_inst(.txif(txif),
   </span><span class="tlx_comments">/* verilator lint_off PINMISSING */
                </span><span class="tlx_untouched">.clk(clk),
                .rstn(rstn));
endmodule
</span><span class="tlx_comments">/*
 The MIT License (MIT)

 Copyright (c) 2019 Yuya Kudo.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the &quot;Software&quot;), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

//`include &quot;uart_if.sv&quot;

</span><span class="tlx_untouched">module uart_rx
  #(parameter
    </span><span class="tlx_comments">/*
     You can specify the following three parameters.
     1. DATA_WIDTH : width of data that is transmited by this module
     2. BAUD_RATE  : baud rate of output uart signal
     3. CLK_FREQ   : freqency of input clock signal
    */
    </span><span class="tlx_untouched">DATA_WIDTH = 8,
    BAUD_RATE  = 115200,
    CLK_FREQ   = 100_000_000,

    localparam
    LB_DATA_WIDTH    = $clog2(DATA_WIDTH),
    PULSE_WIDTH      = CLK_FREQ / BAUD_RATE,
    LB_PULSE_WIDTH   = $clog2(PULSE_WIDTH),
    HALF_PULSE_WIDTH = PULSE_WIDTH / 2)
   (uart_if.rx  rxif,
    input logic clk,
    input logic rstn);

   </span><span class="tlx_comments">//-----------------------------------------------------------------------------
   // noise removing filter
   </span><span class="tlx_untouched">function majority5(input [4:0] val);
      case(val)
        5'b00000: majority5 = 0;
        5'b00001: majority5 = 0;
        5'b00010: majority5 = 0;
        5'b00100: majority5 = 0;
        5'b01000: majority5 = 0;
        5'b10000: majority5 = 0;
        5'b00011: majority5 = 0;
        5'b00101: majority5 = 0;
        5'b01001: majority5 = 0;
        5'b10001: majority5 = 0;
        5'b00110: majority5 = 0;
        5'b01010: majority5 = 0;
        5'b10010: majority5 = 0;
        5'b01100: majority5 = 0;
        5'b10100: majority5 = 0;
        5'b11000: majority5 = 0;
        default:  majority5 = 1;
      endcase
   endfunction

   </span><span class="tlx_comments">//-----------------------------------------------------------------------------
   // description about input signal
   </span><span class="tlx_untouched">logic [1:0] sampling_cnt;
   logic [4:0] sig_q;
   logic       sig_r;

   always_ff @(posedge clk) begin
      if(!rstn) begin
         sampling_cnt &lt;= 0;
         sig_q        &lt;= 5'b11111;
         sig_r        &lt;= 1;
      end
      else begin
         </span><span class="tlx_comments">// connect to deserializer after removing noise
         </span><span class="tlx_untouched">if(sampling_cnt == 0) begin
            sig_q &lt;= {rxif.sig, sig_q[4:1]};
         end

         sig_r        &lt;= majority5(sig_q);
         sampling_cnt &lt;= sampling_cnt + 1;
      end
   end

   </span><span class="tlx_comments">//----------------------------------------------------------------
   // description about receive UART signal
   </span><span class="tlx_untouched">typedef enum logic [1:0] {STT_DATA,
                             STT_STOP,
                             STT_WAIT
                             } statetype;

   statetype                 state;

   logic [DATA_WIDTH-1:0]   data_tmp_r;
   logic [LB_DATA_WIDTH:0]  data_cnt;
   logic [LB_PULSE_WIDTH:0] clk_cnt;
   logic                    rx_done;

   always_ff @(posedge clk) begin
      if(!rstn) begin
         state      &lt;= STT_WAIT;
         data_tmp_r &lt;= 0;
         data_cnt   &lt;= 0;
         clk_cnt    &lt;= 0;
      end
      else begin

         </span><span class="tlx_comments">//-----------------------------------------------------------------------------
         // 3-state FSM
         </span><span class="tlx_untouched">case(state)

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_DATA
           // behavior   : deserialize and recieve data
           // next state : when all data have recieved -&gt; STT_STOP
           </span><span class="tlx_untouched">STT_DATA: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else begin
                 data_tmp_r &lt;= {sig_r, data_tmp_r[DATA_WIDTH-1:1]};
                 clk_cnt    &lt;= PULSE_WIDTH;

                 if(data_cnt == DATA_WIDTH - 1) begin
                    state &lt;= STT_STOP;
                 end
                 else begin
                    data_cnt &lt;= data_cnt + 1;
                 end
              end
           end

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_STOP
           // behavior   : watch stop bit
           // next state : STT_WAIT
           </span><span class="tlx_untouched">STT_STOP: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else if(sig_r) begin
                 state &lt;= STT_WAIT;
              end
           end

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_WAIT
           // behavior   : watch start bit
           // next state : when start bit is observed -&gt; STT_DATA
           </span><span class="tlx_untouched">STT_WAIT: begin
              if(sig_r == 0) begin
                 clk_cnt  &lt;= PULSE_WIDTH + HALF_PULSE_WIDTH;
                 data_cnt &lt;= 0;
                 state    &lt;= STT_DATA;
              end
           end

           default: begin
              state &lt;= STT_WAIT;
           end
         endcase
      end
   end

   assign rx_done = (state == STT_STOP) &amp;&amp; (clk_cnt == 0);

   </span><span class="tlx_comments">//-----------------------------------------------------------------------------
   // description about output signal
   </span><span class="tlx_untouched">logic [DATA_WIDTH-1:0] data_r;
   logic                  valid_r;

   always_ff @(posedge clk) begin
      if(!rstn) begin
         data_r  &lt;= 0;
         valid_r &lt;= 0;
      end
      else if(rx_done &amp;&amp; !valid_r) begin
         valid_r &lt;= 1;
         data_r  &lt;= data_tmp_r;
      end
      else if(valid_r &amp;&amp; rxif.ready) begin
         valid_r &lt;= 0;
      end
   end

   assign rxif.data  = data_r;
   assign rxif.valid = valid_r;

endmodule
</span><span class="tlx_comments">/*
 The MIT License (MIT)

 Copyright (c) 2019 Yuya Kudo.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the &quot;Software&quot;), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

//`include &quot;uart_if.sv&quot;

</span><span class="tlx_untouched">module uart_tx
  #(parameter
    </span><span class="tlx_comments">/*
     You can specify the following three parameters.
     1. DATA_WIDTH : width of data that is transmited by this module
     2. BAUD_RATE  : baud rate of output uart signal
     3. CLK_FREQ   : freqency of input clock signal
    */
    </span><span class="tlx_untouched">DATA_WIDTH = 8,
    BAUD_RATE  = 115200,
    CLK_FREQ   = 100_000_000,

    localparam
    LB_DATA_WIDTH    = $clog2(DATA_WIDTH),
    PULSE_WIDTH      = CLK_FREQ / BAUD_RATE,
    LB_PULSE_WIDTH   = $clog2(PULSE_WIDTH),
    HALF_PULSE_WIDTH = PULSE_WIDTH / 2)
   (uart_if.tx   txif,
    input logic  clk,
    input logic  rstn);

   typedef enum logic [1:0] {STT_DATA,
                             STT_STOP,
                             STT_WAIT
                             } statetype;

   statetype                 state;

   logic [DATA_WIDTH-1:0]     data_r;
   logic                      sig_r;
   logic                      ready_r;
   logic [LB_DATA_WIDTH-1:0]  data_cnt;
   logic [LB_PULSE_WIDTH:0]   clk_cnt;

   always_ff @(posedge clk) begin
      if(!rstn) begin
         state    &lt;= STT_WAIT;
         sig_r    &lt;= 1;
         data_r   &lt;= 0;
         ready_r  &lt;= 1;
         data_cnt &lt;= 0;
         clk_cnt  &lt;= 0;
      end
      else begin

         </span><span class="tlx_comments">//-----------------------------------------------------------------------------
         // 3-state FSM
         </span><span class="tlx_untouched">case(state)

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_DATA
           // behavior   : serialize and transmit data
           // next state : when all data have transmited -&gt; STT_STOP
           </span><span class="tlx_untouched">STT_DATA: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else begin
                 sig_r   &lt;= data_r[data_cnt];
                 clk_cnt &lt;= PULSE_WIDTH;

                 if(data_cnt == DATA_WIDTH - 1) begin
                    state &lt;= STT_STOP;
                 end
                 else begin
                    data_cnt &lt;= data_cnt + 1;
                 end
              end
           end

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_STOP
           // behavior   : assert stop bit
           // next state : STT_WAIT
           </span><span class="tlx_untouched">STT_STOP: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else begin
                 state   &lt;= STT_WAIT;
                 sig_r   &lt;= 1;
                 clk_cnt &lt;= PULSE_WIDTH + HALF_PULSE_WIDTH;
              end
           end

           </span><span class="tlx_comments">//-----------------------------------------------------------------------------
           // state      : STT_WAIT
           // behavior   : watch valid signal, and assert start bit when valid signal assert
           // next state : when valid signal assert -&gt; STT_STAT
           </span><span class="tlx_untouched">STT_WAIT: begin
              if(0 &lt; clk_cnt) begin
                 clk_cnt &lt;= clk_cnt - 1;
              end
              else if(!ready_r) begin
                 ready_r &lt;= 1;
              end
              else if(txif.valid) begin
                 state    &lt;= STT_DATA;
                 sig_r    &lt;= 0;
                 data_r   &lt;= txif.data;
                 ready_r  &lt;= 0;
                 data_cnt &lt;= 0;
                 clk_cnt  &lt;= PULSE_WIDTH;
              end
           end

           default: begin
              state &lt;= STT_WAIT;
           end
         endcase
      end
   end

   assign txif.sig   = sig_r;
   assign txif.ready = ready_r;

endmodule   </span><span class="tlx_comments">// =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   </span><span class="tlx_logic">assign L0_reset_a0 = reset;

   </span><span class="tlx_comments">//...

   // Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">assign passed = cyc_cnt &gt; 40;
   assign failed = 1'b0; </span><span class="tlx_structure">endgenerate
</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

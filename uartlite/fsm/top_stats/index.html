<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 1741, 2592, 0, 6, 280, 0, 0, 0, 'opacity: 0.1', 5549, 'opacity: 0.1', 4048, 'opacity: 0.1'],
      ['top.sv', 0, 1741, 4418, 115, 0, 176, 0, 0, 0, 'opacity: 0.1', 5713, 'opacity: 0.1', 4117, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 1225, 1026, 119, 0, 0, 2505, 'opacity: 0.1', 1746, 'opacity: 0.1', 1857, 'opacity: 0.1'],
      ['SV Total', 0, 1741, 4418, 1340, 1026, 295, 0, 0, 2505, 'opacity: 0.1', 7459, 'opacity: 0.1', 5974, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar floor;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0;

</span><span class="tlx_comments">// For /version2|ctrl$called_bottom.
</span><span class="tlx_declarations">logic Version2_CTRL_called_bottom_a0;

</span><span class="tlx_comments">// For /version2|ctrl$called_top.
</span><span class="tlx_declarations">logic Version2_CTRL_called_top_a0;

</span><span class="tlx_comments">// For /version2|ctrl$down_light.
</span><span class="tlx_declarations">logic [2:1] Version2_CTRL_down_light_a0;

</span><span class="tlx_comments">// For /version2|ctrl$down_pressed.
</span><span class="tlx_declarations">logic [2:0] Version2_CTRL_down_pressed_a0;

</span><span class="tlx_comments">// For /version2|ctrl$elevator_button_pressed.
</span><span class="tlx_declarations">logic [2:0] Version2_CTRL_elevator_button_pressed_a0;

</span><span class="tlx_comments">// For /version2|ctrl$elevator_light.
</span><span class="tlx_declarations">logic [2:0] Version2_CTRL_elevator_light_a0;

</span><span class="tlx_comments">// For /version2|ctrl$floor_mask.
</span><span class="tlx_declarations">logic [2:0] Version2_CTRL_floor_mask_a0;

</span><span class="tlx_comments">// For /version2|ctrl$next_down_light.
</span><span class="tlx_declarations">logic [2:1] Version2_CTRL_next_down_light_a0,
            Version2_CTRL_next_down_light_a1;

</span><span class="tlx_comments">// For /version2|ctrl$next_elevator_light.
</span><span class="tlx_declarations">logic [2:0] Version2_CTRL_next_elevator_light_a0,
            Version2_CTRL_next_elevator_light_a1;

</span><span class="tlx_comments">// For /version2|ctrl$next_floor_mask.
</span><span class="tlx_declarations">logic [2:0] Version2_CTRL_next_floor_mask_a0,
            Version2_CTRL_next_floor_mask_a1;

</span><span class="tlx_comments">// For /version2|ctrl$next_up_light.
</span><span class="tlx_declarations">logic [1:0] Version2_CTRL_next_up_light_a0,
            Version2_CTRL_next_up_light_a1;

</span><span class="tlx_comments">// For /version2|ctrl$next_went_down.
</span><span class="tlx_declarations">logic Version2_CTRL_next_went_down_a0,
      Version2_CTRL_next_went_down_a1;

</span><span class="tlx_comments">// For /version2|ctrl$reset.
</span><span class="tlx_declarations">logic Version2_CTRL_reset_a0;

</span><span class="tlx_comments">// For /version2|ctrl$up_light.
</span><span class="tlx_declarations">logic [1:0] Version2_CTRL_up_light_a0;

</span><span class="tlx_comments">// For /version2|ctrl$up_pressed.
</span><span class="tlx_declarations">logic [2:0] Version2_CTRL_up_pressed_a0;

</span><span class="tlx_comments">// For /version2|ctrl$went_down.
</span><span class="tlx_declarations">logic Version2_CTRL_went_down_a0;

</span><span class="tlx_comments">// For |ctrl$Error.
</span><span class="tlx_declarations">logic CTRL_Error_n1,
      CTRL_Error_a0;

</span><span class="tlx_comments">// For |ctrl$Floor.
</span><span class="tlx_declarations">logic [1:0] CTRL_Floor_n1,
            CTRL_Floor_a0;

</span><span class="tlx_comments">// For |ctrl$go_down.
</span><span class="tlx_declarations">logic CTRL_go_down_a0,
      CTRL_go_down_a1;

</span><span class="tlx_comments">// For |ctrl$go_up.
</span><span class="tlx_declarations">logic CTRL_go_up_a0;

</span><span class="tlx_comments">// For |ctrl$next_floor.
</span><span class="tlx_declarations">logic [1:0] CTRL_next_floor_a0,
            CTRL_next_floor_a1;

</span><span class="tlx_comments">// For |ctrl$reset.
</span><span class="tlx_declarations">logic CTRL_reset_a0;

</span><span class="tlx_comments">// For |ctrl/floor$called.
</span><span class="tlx_declarations">logic CTRL_Floor_called_a0 [2:0];

</span><span class="tlx_comments">// For |ctrl/floor$called_above.
</span><span class="tlx_declarations">logic CTRL_Floor_called_above_a0 [2:0];

</span><span class="tlx_comments">// For |ctrl/floor$called_below.
</span><span class="tlx_declarations">logic CTRL_Floor_called_below_a0 [2:0];

</span><span class="tlx_comments">// For |ctrl/floor$down_pressed.
</span><span class="tlx_declarations">logic [2:0] CTRL_Floor_down_pressed_a0;

</span><span class="tlx_comments">// For |ctrl/floor$elevator_button_pressed.
</span><span class="tlx_declarations">logic [2:0] CTRL_Floor_elevator_button_pressed_a0;

</span><span class="tlx_comments">// For |ctrl/floor$up_pressed.
</span><span class="tlx_declarations">logic [2:0] CTRL_Floor_up_pressed_a0;


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">

   //
   // Scope: /version2
   //


      //
      // Scope: |ctrl
      //

         // For $next_down_light.
         </span><span class="tlx_staging">always_ff @(posedge clk) Version2_CTRL_next_down_light_a1[2:1] &lt;= Version2_CTRL_next_down_light_a0[2:1];

         </span><span class="tlx_comments">// For $next_elevator_light.
         </span><span class="tlx_staging">always_ff @(posedge clk) Version2_CTRL_next_elevator_light_a1[2:0] &lt;= Version2_CTRL_next_elevator_light_a0[2:0];

         </span><span class="tlx_comments">// For $next_floor_mask.
         </span><span class="tlx_staging">always_ff @(posedge clk) Version2_CTRL_next_floor_mask_a1[2:0] &lt;= Version2_CTRL_next_floor_mask_a0[2:0];

         </span><span class="tlx_comments">// For $next_up_light.
         </span><span class="tlx_staging">always_ff @(posedge clk) Version2_CTRL_next_up_light_a1[1:0] &lt;= Version2_CTRL_next_up_light_a0[1:0];

         </span><span class="tlx_comments">// For $next_went_down.
         </span><span class="tlx_staging">always_ff @(posedge clk) Version2_CTRL_next_went_down_a1 &lt;= Version2_CTRL_next_went_down_a0;




   </span><span class="tlx_comments">//
   // Scope: |ctrl
   //

      // For $Error.
      </span><span class="tlx_staging">always_ff @(posedge clk) CTRL_Error_a0 &lt;= CTRL_Error_n1;

      </span><span class="tlx_comments">// For $Floor.
      </span><span class="tlx_staging">always_ff @(posedge clk) CTRL_Floor_a0[1:0] &lt;= CTRL_Floor_n1[1:0];

      </span><span class="tlx_comments">// For $go_down.
      </span><span class="tlx_staging">always_ff @(posedge clk) CTRL_go_down_a1 &lt;= CTRL_go_down_a0;

      </span><span class="tlx_comments">// For $next_floor.
      </span><span class="tlx_staging">always_ff @(posedge clk) CTRL_next_floor_a1[1:0] &lt;= CTRL_next_floor_a0[1:0];


      </span><span class="tlx_comments">//
      // Scope: /floor[2:0]
      //
      </span><span class="tlx_structure">for (floor = 0; floor &lt;= 2; floor++) begin : L1gen_CTRL_Floor
</span><span class="tlx_comments">         // For $DownLight.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1b_CTRL_Floor[floor].L1_DownLight_a0 &lt;= L1b_CTRL_Floor[floor].L1_DownLight_n1;

         </span><span class="tlx_comments">// For $ElevatorLight.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1b_CTRL_Floor[floor].L1_ElevatorLight_a0 &lt;= L1b_CTRL_Floor[floor].L1_ElevatorLight_n1;

         </span><span class="tlx_comments">// For $UpLight.
         </span><span class="tlx_staging">always_ff @(posedge clk) L1b_CTRL_Floor[floor].L1_UpLight_a0 &lt;= L1b_CTRL_Floor[floor].L1_UpLight_n1;

      </span><span class="tlx_structure">end



endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      </span><span class="tlx_comments">//
      // Scope: /version2
      //
      </span><span class="tlx_instrumentation">if (1) begin : \/version2 
</span><span class="tlx_comments">
         //
         // Scope: |ctrl
         //
         </span><span class="tlx_instrumentation">if (1) begin : \|ctrl 
            logic  \@0$called_bottom ;
            assign \@0$called_bottom = Version2_CTRL_called_bottom_a0;
            logic  \@0$called_top ;
            assign \@0$called_top = Version2_CTRL_called_top_a0;
            logic [2:1] \@0$down_light ;
            assign \@0$down_light = Version2_CTRL_down_light_a0;
            logic [2:0] \@0$down_pressed ;
            assign \@0$down_pressed = Version2_CTRL_down_pressed_a0;
            logic [2:0] \@0$elevator_button_pressed ;
            assign \@0$elevator_button_pressed = Version2_CTRL_elevator_button_pressed_a0;
            logic [2:0] \@0$elevator_light ;
            assign \@0$elevator_light = Version2_CTRL_elevator_light_a0;
            logic [2:0] \@0$floor_mask ;
            assign \@0$floor_mask = Version2_CTRL_floor_mask_a0;
            logic [2:1] \@0$next_down_light ;
            assign \@0$next_down_light = Version2_CTRL_next_down_light_a0;
            logic [2:0] \@0$next_elevator_light ;
            assign \@0$next_elevator_light = Version2_CTRL_next_elevator_light_a0;
            logic [2:0] \@0$next_floor_mask ;
            assign \@0$next_floor_mask = Version2_CTRL_next_floor_mask_a0;
            logic [1:0] \@0$next_up_light ;
            assign \@0$next_up_light = Version2_CTRL_next_up_light_a0;
            logic  \@0$next_went_down ;
            assign \@0$next_went_down = Version2_CTRL_next_went_down_a0;
            logic  \@0$reset ;
            assign \@0$reset = Version2_CTRL_reset_a0;
            logic [1:0] \@0$up_light ;
            assign \@0$up_light = Version2_CTRL_up_light_a0;
            logic [2:0] \@0$up_pressed ;
            assign \@0$up_pressed = Version2_CTRL_up_pressed_a0;
            logic  \@0$went_down ;
            assign \@0$went_down = Version2_CTRL_went_down_a0;
         end
      end

      </span><span class="tlx_comments">//
      // Scope: |ctrl
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|ctrl 
         logic  \@-1$Error ;
         assign \@-1$Error = CTRL_Error_n1;
         logic [1:0] \@-1$Floor ;
         assign \@-1$Floor = CTRL_Floor_n1;
         logic  \@0$go_down ;
         assign \@0$go_down = CTRL_go_down_a0;
         logic  \@0$go_up ;
         assign \@0$go_up = CTRL_go_up_a0;
         logic [1:0] \@0$next_floor ;
         assign \@0$next_floor = CTRL_next_floor_a0;
         logic  \@0$reset ;
         assign \@0$reset = CTRL_reset_a0;

         </span><span class="tlx_comments">//
         // Scope: /floor[2:0]
         //
         </span><span class="tlx_instrumentation">for (floor = 0; floor &lt;= 2; floor++) begin : \/floor 
            logic  \@-1$DownLight ;
            assign \@-1$DownLight = L1b_CTRL_Floor[floor].L1_DownLight_n1;
            logic  \@-1$ElevatorLight ;
            assign \@-1$ElevatorLight = L1b_CTRL_Floor[floor].L1_ElevatorLight_n1;
            logic  \@-1$UpLight ;
            assign \@-1$UpLight = L1b_CTRL_Floor[floor].L1_UpLight_n1;
            logic  \@0$called ;
            assign \@0$called = CTRL_Floor_called_a0[floor];
            logic  \@0$called_above ;
            assign \@0$called_above = CTRL_Floor_called_above_a0[floor];
            logic  \@0$called_below ;
            assign \@0$called_below = CTRL_Floor_called_below_a0[floor];
            logic  \@0$down_pressed ;
            assign \@0$down_pressed = CTRL_Floor_down_pressed_a0[floor];
            logic  \@0$elevator_button_pressed ;
            assign \@0$elevator_button_pressed = CTRL_Floor_elevator_button_pressed_a0[floor];
            logic  \@0$up_pressed ;
            assign \@0$up_pressed = CTRL_Floor_up_pressed_a0[floor];
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
   </span><span class="tlx_comments">// A state machine for a 3-floor elevator controller.
   // Elevator can travel one story each cycle, stopping at each floor (whether necessary or not).

   // This controller is written three ways:
   //   1) in SystemVerilog, in a big always_ff block
   //   2) directly translated to TL-Verilog
   //   3) cleanly rewritten in TL-Verilog with a single assignment for each signal
   //   4) (and the SandPiper(TM)-generated Verilog could be considered a fourth style)
   //
   //   Sequential style: 1) SV -&gt; 2) TLV
   //                        |         |
   //   Parallel style:   4) SV &lt;- 3) TLV

   // Observations:
   //  o Using a nested if-else structure (sequential style) is not better or worse than
   //    individual assignments (parallel style) in terms of code size. With sequential style,
   //    signals are repeated multiple times. With parallel style, cases are repeated
   //    multiple times.
   //  o TL-Verilog lends itself to parallel style. This:
   //     - allows signal declarations to be incorporated into assignments
   //     - provides individual atomic re-timable statements.
   //  o The logic representation chosen for TL-Verilog is less specific to 3 floors, with more
   //    logic replicated per floor, where Verilog logic is coded uniquely per-floor.
   //  o Coding time was roughly the same for Verilog and TL-Verilog (but, for what it's
   //    worth, I had two bugs of any significance in my Verilog and none in TL-Verilog).
   //  o Even though no simplicity benefit is claimed for TL-Verilog for state machines, the code
   //    is about half the size.

   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
   /* verilator lint_on WIDTH */

   // ==========
   // Version 1) SystemVerilog by hand.
   // ==========

   // Inputs:
   </span><span class="tlx_untouched">logic [2:0] up_pressed, down_pressed;  </span><span class="tlx_comments">// Elevator up/down button input on each floor. 1 == pressed.
   </span><span class="tlx_untouched">logic [2:0] elevator_button_pressed;   </span><span class="tlx_comments">// The floor buttons/lights in the elevator. 1 == pressed.

   </span><span class="tlx_untouched">logic [2:0] floor_mask;  </span><span class="tlx_comments">// Floor the elevator is on (1-hot decoded).
   </span><span class="tlx_untouched">logic [1:0] up_light; logic [2:1] down_light;   </span><span class="tlx_comments">// Elevator up/down button lights on each floor. 1 == lit. Cleared after departure.
   </span><span class="tlx_untouched">logic [2:0] elevator_light;  </span><span class="tlx_comments">// The floor lights in the elevator. 1 == lit. Cleared on arrival.
   </span><span class="tlx_untouched">logic went_up, went_down; </span><span class="tlx_comments">// 1 if the elevator just went this direction to reach its current floor.

   </span><span class="tlx_untouched">logic called_top, called_bottom;  </span><span class="tlx_comments">// 1 if there's a reason to go up/down.
   </span><span class="tlx_untouched">always_comb begin
      </span><span class="tlx_comments">// For decisions from floor 1:
      </span><span class="tlx_untouched">called_top = elevator_light[2] || down_light[2] || up_light[1];
      called_bottom = elevator_light[0] || up_light[0] || down_light[1];
   end
   always_ff @(posedge clk) begin
      </span><span class="tlx_comments">// Random input:
      // Note that we do not keep track of who is in the elevator, and elevator buttons
      // can be pressed at any time, whether there is a passenger or not.
      // All button presses are given 1/8 probability, here.
      </span><span class="tlx_untouched">{up_pressed, down_pressed, elevator_button_pressed} &lt;=
           9'b011110111 &amp;  </span><span class="tlx_comments">// Mask non-existant buttons.
           </span><span class="tlx_untouched">RW_rand_raw[26:18] &amp; RW_rand_raw[17:9] &amp; RW_rand_raw[8:0];  </span><span class="tlx_comments">// random w/ 1/8 probability.
      
      // State machine, to update:
      //   o floor
      //   o up/down_light
      //   o went_up/down
      
      // Stay, until we decide otherwise.
      //went_up &lt;= 1'b0;
      </span><span class="tlx_untouched">went_down &lt;= 1'b0;
      
      </span><span class="tlx_comments">// Update state for elevator button presses.
      </span><span class="tlx_untouched">for (int fl = 0; fl &lt; 3; fl++) begin
         if (elevator_button_pressed[fl]) elevator_light[fl] &lt;= '1;
            </span><span class="tlx_comments">// Note that if button is pressed for our new floor, the light is not lit.
      </span><span class="tlx_untouched">end
      </span><span class="tlx_comments">// Note that we cannot have been called to the floor we are on.
      </span><span class="tlx_untouched">if (reset) begin
         floor_mask &lt;= 3'b001;
         up_light &lt;= 2'b00;
         down_light &lt;= 2'b00;
         elevator_light &lt;= 3'b000;
      end else if (floor_mask[0]) begin
         </span><span class="tlx_comments">// From floor 0
         </span><span class="tlx_untouched">if (| {up_light[1:0], down_light[2:1], elevator_light[2:1]}) begin
            </span><span class="tlx_comments">// Go up.
            //went_up &lt;= '1;
            </span><span class="tlx_untouched">floor_mask &lt;= 3'b010;
            up_light[0] &lt;= '0;
            elevator_light[1] &lt;= '0;
         end else begin
            </span><span class="tlx_comments">// Stay.
            </span><span class="tlx_untouched">elevator_light[0] &lt;= '0;
         end
      end else if (floor_mask[2]) begin
         </span><span class="tlx_comments">// From floor 2
         </span><span class="tlx_untouched">if (| {down_light[2:1], up_light[1:0], elevator_light[1:0]}) begin
            </span><span class="tlx_comments">// Go down.
            </span><span class="tlx_untouched">went_down &lt;= '1;
            floor_mask &lt;= 3'b010;
            down_light[2] &lt;= '0;
            elevator_light[1] &lt;= '0;
         end else begin
            </span><span class="tlx_comments">// Stay.
            </span><span class="tlx_untouched">elevator_light[2] &lt;= '0;
         end
      end else begin
         </span><span class="tlx_comments">// From floor 1
         </span><span class="tlx_untouched">if (called_top &amp;&amp; (!went_down || !called_bottom)) begin
            </span><span class="tlx_comments">// Go up (gets priority over down when no momentum).
            //went_up &lt;= '1;
            </span><span class="tlx_untouched">floor_mask &lt;= 3'b100;
            up_light[1] &lt;= '0;
            elevator_light[2] &lt;= '0;
         end else if (called_bottom &amp;&amp; (went_down || !called_top)) begin
            </span><span class="tlx_comments">// Go down.
            </span><span class="tlx_untouched">went_down &lt;= '1;
            floor_mask &lt;= 3'b001;
            down_light[1] &lt;= '0;
            elevator_light[0] &lt;= '0;
         end else begin
            </span><span class="tlx_comments">// Stay.
            </span><span class="tlx_untouched">elevator_light[1] &lt;= '0;
         end
      end
         
      </span><span class="tlx_comments">// Update state for floor button presses.
      </span><span class="tlx_untouched">for (int fl = 0; fl &lt; 3; fl++) begin
         if (up_pressed[fl]) up_light[fl] &lt;= '1;
         if (down_pressed[fl]) down_light[fl] &lt;= '1;
      end
   end

</span><span class="tlx_structure">\TLV
   </span><span class="tlx_logic">$reset = *reset;
   
   </span><span class="tlx_comments">// -------------------------
   // Random stimulus.
   // Use values from Verilog model.
   </span><span class="tlx_structure">|ctrl
      </span><span class="tlx_staging">@0
         </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">2</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            </span><span class="tlx_comments">// Elevator up/down button input on each floor. 1 == pressed.
            </span><span class="tlx_logic">$up_pressed = *up_pressed[floor];   </span><span class="tlx_comments">// BUG: [#floor] doesn't work.
            </span><span class="tlx_logic">$down_pressed = *down_pressed[floor];
            </span><span class="tlx_comments">// The floor buttons/lights in the elevator. 1 == pressed.
            </span><span class="tlx_logic">$elevator_button_pressed = *elevator_button_pressed[floor];
   </span><span class="tlx_comments">// -------------------------
   
   // ==========
   // Version 2) Direct translation to TL-Verilog.
   // ==========
   
   </span><span class="tlx_structure">/version2
      |ctrl
         </span><span class="tlx_staging">@0
            </span><span class="tlx_comments">// Random input:
            // Note that we do not keep track of who is in the elevator, and elevator buttons
            // can be pressed at any time, whether there is a passenger or not.
            // All button presses are given 1/8 probability, here.
            </span><span class="tlx_logic">{$up_pressed[2:0], $down_pressed[2:0], $elevator_button_pressed[2:0]} =
                 {</span><span class="tlx_structure">/top|ctrl/floor[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$up_pressed, </span><span class="tlx_structure">/top|ctrl/floor[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$down_pressed, </span><span class="tlx_structure">/top|ctrl/floor[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$elevator_button_pressed};
            
            $reset = </span><span class="tlx_structure">/top|ctrl</span><span class="tlx_logic">$reset;
            
            </span><span class="tlx_comments">// For decisions from floor 1:
            </span><span class="tlx_logic">$called_top = $elevator_light[2] || $down_light[2] || $up_light[1];
            $called_bottom = $elevator_light[0] || $up_light[0] || $down_light[1];

            </span><span class="tlx_structure">\always_comb
               </span><span class="tlx_comments">// State machine, to update:
               //   o floor
               //   o up/down_light
               //   o went_up/down
               
               // Stay, until we decide otherwise.
               // 1 if the elevator will have just gone this direction to reach its current floor.
               //$$next_went_up = 1'b0;
               </span><span class="tlx_logic">$$next_went_down = 1'b0;
               
               </span><span class="tlx_comments">// Update state for elevator button presses.
               </span><span class="tlx_logic">for (int fl = 0; fl &lt; 3; fl++) begin
                  if ($elevator_button_pressed[fl]) $next_elevator_light[fl] = '1;
                     </span><span class="tlx_comments">// Note that if button is pressed for our new floor, the light is not lit.
               </span><span class="tlx_logic">end
               </span><span class="tlx_comments">// Note that we cannot have been called to the floor we are on.
               </span><span class="tlx_logic">if ($reset) begin
                  $$next_floor_mask[2:0] = 3'b001;     </span><span class="tlx_comments">// Next value of: The floor the elevator is on (1-hot decoded).
                  </span><span class="tlx_logic">$$next_up_light[1:0] = 2'b00;        </span><span class="tlx_comments">// Next value of: Elevator up/down button lights on each floor. 1 == lit. Cleared after departure.
                  </span><span class="tlx_logic">$$next_down_light[2:1] = 2'b00;      </span><span class="tlx_comments">// Next value of: The floor lights in the elevator. 1 == lit. Cleared on arrival.
                  </span><span class="tlx_logic">$$next_elevator_light[2:0] = 3'b000; </span><span class="tlx_comments">// Next value of: The floor lights in the elevator. 1 == lit. Cleared on arrival.
               </span><span class="tlx_logic">end else if ($floor_mask[0]) begin
                  </span><span class="tlx_comments">// From floor 0
                  </span><span class="tlx_logic">if (| {$up_light[1:0], $down_light[2:1], $elevator_light[2:1]}) begin
                     </span><span class="tlx_comments">// Go up.
                     //$next_went_up = '1;
                     </span><span class="tlx_logic">$next_floor_mask = 3'b010;
                     $next_up_light[0] = '0;
                     $next_elevator_light[1] = '0;
                  end else begin
                     </span><span class="tlx_comments">// Stay.
                     </span><span class="tlx_logic">$next_elevator_light[0] = '0;
                  end
               end else if ($floor_mask[2]) begin
                  </span><span class="tlx_comments">// From floor 2
                  </span><span class="tlx_logic">if (| {$down_light[2:1], $up_light[1:0], $elevator_light[1:0]}) begin
                     </span><span class="tlx_comments">// Go down.
                     </span><span class="tlx_logic">$next_went_down = '1;
                     $next_floor_mask = 3'b010;
                     $next_down_light[2] = '0;
                     $next_elevator_light[1] = '0;
                  end else begin
                     </span><span class="tlx_comments">// Stay.
                     </span><span class="tlx_logic">$next_elevator_light[2] = '0;
                  end
               end else begin
                  </span><span class="tlx_comments">// From floor 1
                  </span><span class="tlx_logic">if ($called_top &amp;&amp; (!$went_down || !$called_bottom)) begin
                     </span><span class="tlx_comments">// Go up (gets priority over down when no momentum).
                     //$next_went_up = '1;
                     </span><span class="tlx_logic">$next_floor_mask = 3'b100;
                     $next_up_light[1] = '0;
                     $next_elevator_light[2] = '0;
                  end else if ($called_bottom &amp;&amp; ($went_down || !$called_top)) begin
                     </span><span class="tlx_comments">// Go down.
                     </span><span class="tlx_logic">$next_went_down = '1;
                     $next_floor_mask = 3'b001;
                     $next_down_light[1] = '0;
                     $next_elevator_light[0] = '0;
                  end else begin
                     </span><span class="tlx_comments">// Stay.
                     </span><span class="tlx_logic">$next_elevator_light[1] = '0;
                  end 
               end
               
               </span><span class="tlx_comments">// Update state for floor button presses.
               </span><span class="tlx_logic">for (int fl = 0; fl &lt; 3; fl++) begin
                  if ($up_pressed[fl]) $next_up_light[fl] = '1;
                  if ($down_pressed[fl]) $next_down_light[fl] = '1;
               end
            
            </span><span class="tlx_comments">// Stage next state values from combinational state update logic.
            </span><span class="tlx_logic">$went_down = &gt;&gt;1$next_went_down;
            </span><span class="tlx_comments">//$went_up = &gt;&gt;1$next_went_up;
            </span><span class="tlx_logic">$floor_mask[2:0] = &gt;&gt;1$next_floor_mask;
            $up_light[1:0] = &gt;&gt;1$next_up_light;
            $down_light[2:1] = &gt;&gt;1$next_down_light;
            $elevator_light[2:0] = &gt;&gt;1$next_elevator_light;

   
   </span><span class="tlx_comments">// ==========
   // Version 3) Hand-coded TL-Verilog.
   // ==========
   
   // DUT
   // Macros to compute floor above/below with wrap (because some Verilog compilers complain about out-of-bounds accesses).
   // Note that for m4_above ($1 + 2) % 3 is ($1 - 1) % 3, but with positive modulo math.
   
   
   </span><span class="tlx_structure">|ctrl
      </span><span class="tlx_staging">@0
         </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/top</span><span class="tlx_logic">&lt;&gt;0$reset;
         $next_floor[1:0] = $reset   ? 2'b0 :
                            $go_up   ? $Floor + 2'b1 :
                            $go_down ? $Floor - 2'b1 :
                                       $RETAIN;
         $Floor[1:0] &lt;= $next_floor;  </span><span class="tlx_comments">// WORKAROUND: &lt;&lt;1$Floor can't be used, currently, so $next_floor created as temporary.
         </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
            </span><span class="tlx_comments">// Clear elevator light on arrival at next floor, or set it after pressed.
            </span><span class="tlx_logic">$ElevatorLight &lt;= </span><span class="tlx_structure">|ctrl</span><span class="tlx_logic">$reset ? 1'b0 :
                              </span><span class="tlx_structure">|ctrl</span><span class="tlx_logic">$next_floor == #floor ? 1'b0 :
                              $ElevatorLight || $elevator_button_pressed;
            </span><span class="tlx_comments">// Set up   light on this floor when pressed, and clear when leaving this floor upward.
            </span><span class="tlx_logic">$UpLight   &lt;= $up_pressed                                ? 1'b1 :
                          ((</span><span class="tlx_structure">|ctrl</span><span class="tlx_logic">$Floor == #floor) &amp;&amp; </span><span class="tlx_structure">|ctrl</span><span class="tlx_logic">$go_up)   ? 1'b0 :
                                                                       $RETAIN;
            </span><span class="tlx_comments">// Set down light on this floor when pressed, and clear when leaving this floor downward.
            </span><span class="tlx_logic">$DownLight &lt;= $down_pressed                              ? 1'b1 :
                          ((</span><span class="tlx_structure">|ctrl</span><span class="tlx_logic">$Floor == #floor) &amp;&amp; </span><span class="tlx_structure">|ctrl</span><span class="tlx_logic">$go_down) ? 1'b0 :
                                                                       $RETAIN;
            </span><span class="tlx_comments">// Call elevator to this floor when requested within elevator or at floor.
            </span><span class="tlx_logic">$called = $ElevatorLight || $DownLight || $UpLight;
            </span><span class="tlx_comments">// $called_above/below if $called above/below or up/down button is lit on this floor.
            </span><span class="tlx_logic">$called_above = $UpLight   || ((#floor == 2) ? 1'b0 : </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">((#floor + 1) % 3)</span><span class="tlx_structure">]</span><span class="tlx_logic">$called || </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">((#floor + 1) % 3)</span><span class="tlx_structure">]</span><span class="tlx_logic">$called_above);
            $called_below = $DownLight || ((#floor == 0) ? 1'b0 : </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">((#floor + 2) % 3)</span><span class="tlx_structure">]</span><span class="tlx_logic">$called || </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">((#floor + 2) % 3)</span><span class="tlx_structure">]</span><span class="tlx_logic">$called_below);
         </span><span class="tlx_comments">// Go up or down if called that way, breaking tie based on momentum and then prioritizing up.
         </span><span class="tlx_logic">$go_up   = ((! &gt;&gt;1$go_down || ! </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">$Floor</span><span class="tlx_structure">]</span><span class="tlx_logic">$called_below) &amp;&amp; </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">$Floor</span><span class="tlx_structure">]</span><span class="tlx_logic">$called_above);
         $go_down = ((  &gt;&gt;1$go_down || ! </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">$Floor</span><span class="tlx_structure">]</span><span class="tlx_logic">$called_above) &amp;&amp; </span><span class="tlx_structure">/floor[</span><span class="tlx_logic">$Floor</span><span class="tlx_structure">]</span><span class="tlx_logic">$called_below);

         
         </span><span class="tlx_comments">// Compare all three models.
         </span><span class="tlx_logic">$Error &lt;= $reset ? 1'b0 : !((*floor_mask == </span><span class="tlx_structure">/top/version2|ctrl</span><span class="tlx_logic">$floor_mask) &amp;&amp; ((3'b1 &lt;&lt; $Floor) == </span><span class="tlx_structure">/top/version2|ctrl</span><span class="tlx_logic">$floor_mask)) || $Error;
         *failed = (*cyc_cnt &gt; 400) &amp;&amp;   $Error;
         *passed = (*cyc_cnt &gt; 400) &amp;&amp; ! $Error;
</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
   // A state machine for a 3-floor elevator controller.
   // Elevator can travel one story each cycle, stopping at each floor (whether necessary or not).

   // This controller is written three ways:
   //   1) in SystemVerilog, in a big always_ff block
   //   2) directly translated to TL-Verilog
   //   3) cleanly rewritten in TL-Verilog with a single assignment for each signal
   //   4) (and the SandPiper(TM)-generated Verilog could be considered a fourth style)
   //
   //   Sequential style: 1) SV -&gt; 2) TLV
   //                        |         |
   //   Parallel style:   4) SV &lt;- 3) TLV

   // Observations:
   //  o Using a nested if-else structure (sequential style) is not better or worse than
   //    individual assignments (parallel style) in terms of code size. With sequential style,
   //    signals are repeated multiple times. With parallel style, cases are repeated
   //    multiple times.
   //  o TL-Verilog lends itself to parallel style. This:
   //     - allows signal declarations to be incorporated into assignments
   //     - provides individual atomic re-timable statements.
   //  o The logic representation chosen for TL-Verilog is less specific to 3 floors, with more
   //    logic replicated per floor, where Verilog logic is coded uniquely per-floor.
   //  o Coding time was roughly the same for Verilog and TL-Verilog (but, for what it's
   //    worth, I had two bugs of any significance in my Verilog and none in TL-Verilog).
   //  o Even though no simplicity benefit is claimed for TL-Verilog for state machines, the code
   //    is about half the size.

   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
   /* verilator lint_on WIDTH */

   // ==========
   // Version 1) SystemVerilog by hand.
   // ==========

   // Inputs:
   </span><span class="tlx_untouched">logic [2:0] up_pressed, down_pressed;  </span><span class="tlx_comments">// Elevator up/down button input on each floor. 1 == pressed.
   </span><span class="tlx_untouched">logic [2:0] elevator_button_pressed;   </span><span class="tlx_comments">// The floor buttons/lights in the elevator. 1 == pressed.

   </span><span class="tlx_untouched">logic [2:0] floor_mask;  </span><span class="tlx_comments">// Floor the elevator is on (1-hot decoded).
   </span><span class="tlx_untouched">logic [1:0] up_light; logic [2:1] down_light;   </span><span class="tlx_comments">// Elevator up/down button lights on each floor. 1 == lit. Cleared after departure.
   </span><span class="tlx_untouched">logic [2:0] elevator_light;  </span><span class="tlx_comments">// The floor lights in the elevator. 1 == lit. Cleared on arrival.
   </span><span class="tlx_untouched">logic went_up, went_down; </span><span class="tlx_comments">// 1 if the elevator just went this direction to reach its current floor.

   </span><span class="tlx_untouched">logic called_top, called_bottom;  </span><span class="tlx_comments">// 1 if there's a reason to go up/down.
   </span><span class="tlx_untouched">always_comb begin
      </span><span class="tlx_comments">// For decisions from floor 1:
      </span><span class="tlx_untouched">called_top = elevator_light[2] || down_light[2] || up_light[1];
      called_bottom = elevator_light[0] || up_light[0] || down_light[1];
   end
   always_ff @(posedge clk) begin
      </span><span class="tlx_comments">// Random input:
      // Note that we do not keep track of who is in the elevator, and elevator buttons
      // can be pressed at any time, whether there is a passenger or not.
      // All button presses are given 1/8 probability, here.
      </span><span class="tlx_untouched">{up_pressed, down_pressed, elevator_button_pressed} &lt;=
           9'b011110111 &amp;  </span><span class="tlx_comments">// Mask non-existant buttons.
           </span><span class="tlx_untouched">RW_rand_raw[26:18] &amp; RW_rand_raw[17:9] &amp; RW_rand_raw[8:0];  </span><span class="tlx_comments">// random w/ 1/8 probability.
      
      // State machine, to update:
      //   o floor
      //   o up/down_light
      //   o went_up/down
      
      // Stay, until we decide otherwise.
      //went_up &lt;= 1'b0;
      </span><span class="tlx_untouched">went_down &lt;= 1'b0;
      
      </span><span class="tlx_comments">// Update state for elevator button presses.
      </span><span class="tlx_untouched">for (int fl = 0; fl &lt; 3; fl++) begin
         if (elevator_button_pressed[fl]) elevator_light[fl] &lt;= '1;
            </span><span class="tlx_comments">// Note that if button is pressed for our new floor, the light is not lit.
      </span><span class="tlx_untouched">end
      </span><span class="tlx_comments">// Note that we cannot have been called to the floor we are on.
      </span><span class="tlx_untouched">if (reset) begin
         floor_mask &lt;= 3'b001;
         up_light &lt;= 2'b00;
         down_light &lt;= 2'b00;
         elevator_light &lt;= 3'b000;
      end else if (floor_mask[0]) begin
         </span><span class="tlx_comments">// From floor 0
         </span><span class="tlx_untouched">if (| {up_light[1:0], down_light[2:1], elevator_light[2:1]}) begin
            </span><span class="tlx_comments">// Go up.
            //went_up &lt;= '1;
            </span><span class="tlx_untouched">floor_mask &lt;= 3'b010;
            up_light[0] &lt;= '0;
            elevator_light[1] &lt;= '0;
         end else begin
            </span><span class="tlx_comments">// Stay.
            </span><span class="tlx_untouched">elevator_light[0] &lt;= '0;
         end
      end else if (floor_mask[2]) begin
         </span><span class="tlx_comments">// From floor 2
         </span><span class="tlx_untouched">if (| {down_light[2:1], up_light[1:0], elevator_light[1:0]}) begin
            </span><span class="tlx_comments">// Go down.
            </span><span class="tlx_untouched">went_down &lt;= '1;
            floor_mask &lt;= 3'b010;
            down_light[2] &lt;= '0;
            elevator_light[1] &lt;= '0;
         end else begin
            </span><span class="tlx_comments">// Stay.
            </span><span class="tlx_untouched">elevator_light[2] &lt;= '0;
         end
      end else begin
         </span><span class="tlx_comments">// From floor 1
         </span><span class="tlx_untouched">if (called_top &amp;&amp; (!went_down || !called_bottom)) begin
            </span><span class="tlx_comments">// Go up (gets priority over down when no momentum).
            //went_up &lt;= '1;
            </span><span class="tlx_untouched">floor_mask &lt;= 3'b100;
            up_light[1] &lt;= '0;
            elevator_light[2] &lt;= '0;
         end else if (called_bottom &amp;&amp; (went_down || !called_top)) begin
            </span><span class="tlx_comments">// Go down.
            </span><span class="tlx_untouched">went_down &lt;= '1;
            floor_mask &lt;= 3'b001;
            down_light[1] &lt;= '0;
            elevator_light[0] &lt;= '0;
         end else begin
            </span><span class="tlx_comments">// Stay.
            </span><span class="tlx_untouched">elevator_light[1] &lt;= '0;
         end
      end
         
      </span><span class="tlx_comments">// Update state for floor button presses.
      </span><span class="tlx_untouched">for (int fl = 0; fl &lt; 3; fl++) begin
         if (up_pressed[fl]) up_light[fl] &lt;= '1;
         if (down_pressed[fl]) down_light[fl] &lt;= '1;
      end
   end

</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   </span><span class="tlx_logic">assign L0_reset_a0 = reset;
   
   </span><span class="tlx_comments">// -------------------------
   // Random stimulus.
   // Use values from Verilog model.
   //_|ctrl
      //_@0
         </span><span class="tlx_structure">for (floor = 0; floor &lt;= 2; floor++) begin : L1_CTRL_Floor </span><span class="tlx_comments">//_/floor
            // Elevator up/down button input on each floor. 1 == pressed.
            </span><span class="tlx_logic">assign CTRL_Floor_up_pressed_a0[floor] = up_pressed[floor];   </span><span class="tlx_comments">// BUG: [#floor] doesn't work.
            </span><span class="tlx_logic">assign CTRL_Floor_down_pressed_a0[floor] = down_pressed[floor];
            </span><span class="tlx_comments">// The floor buttons/lights in the elevator. 1 == pressed.
            </span><span class="tlx_logic">assign CTRL_Floor_elevator_button_pressed_a0[floor] = elevator_button_pressed[floor]; </span><span class="tlx_structure">end
   </span><span class="tlx_comments">// -------------------------
   
   // ==========
   // Version 2) Direct translation to TL-Verilog.
   // ==========
   
   //_/version2
      //_|ctrl
         //_@0
            // Random input:
            // Note that we do not keep track of who is in the elevator, and elevator buttons
            // can be pressed at any time, whether there is a passenger or not.
            // All button presses are given 1/8 probability, here.
            </span><span class="tlx_logic">assign {Version2_CTRL_up_pressed_a0[2:0], Version2_CTRL_down_pressed_a0[2:0], Version2_CTRL_elevator_button_pressed_a0[2:0]} =
                 {CTRL_Floor_up_pressed_a0, CTRL_Floor_down_pressed_a0, CTRL_Floor_elevator_button_pressed_a0};
            
            assign Version2_CTRL_reset_a0 = CTRL_reset_a0;
            
            </span><span class="tlx_comments">// For decisions from floor 1:
            </span><span class="tlx_logic">assign Version2_CTRL_called_top_a0 = Version2_CTRL_elevator_light_a0[2] || Version2_CTRL_down_light_a0[2] || Version2_CTRL_up_light_a0[1];
            assign Version2_CTRL_called_bottom_a0 = Version2_CTRL_elevator_light_a0[0] || Version2_CTRL_up_light_a0[0] || Version2_CTRL_down_light_a0[1];

            always_comb begin
               </span><span class="tlx_comments">// State machine, to update:
               //   o floor
               //   o up/down_light
               //   o went_up/down
               
               // Stay, until we decide otherwise.
               // 1 if the elevator will have just gone this direction to reach its current floor.
               //$$next_went_up = 1'b0;
               </span><span class="tlx_logic">Version2_CTRL_next_went_down_a0 = 1'b0;
               
               </span><span class="tlx_comments">// Update state for elevator button presses.
               </span><span class="tlx_logic">for (int fl = 0; fl &lt; 3; fl++) begin
                  if (Version2_CTRL_elevator_button_pressed_a0[fl]) Version2_CTRL_next_elevator_light_a0[fl] = '1;
                     </span><span class="tlx_comments">// Note that if button is pressed for our new floor, the light is not lit.
               </span><span class="tlx_logic">end
               </span><span class="tlx_comments">// Note that we cannot have been called to the floor we are on.
               </span><span class="tlx_logic">if (Version2_CTRL_reset_a0) begin
                  Version2_CTRL_next_floor_mask_a0[2:0] = 3'b001;     </span><span class="tlx_comments">// Next value of: The floor the elevator is on (1-hot decoded).
                  </span><span class="tlx_logic">Version2_CTRL_next_up_light_a0[1:0] = 2'b00;        </span><span class="tlx_comments">// Next value of: Elevator up/down button lights on each floor. 1 == lit. Cleared after departure.
                  </span><span class="tlx_logic">Version2_CTRL_next_down_light_a0[2:1] = 2'b00;      </span><span class="tlx_comments">// Next value of: The floor lights in the elevator. 1 == lit. Cleared on arrival.
                  </span><span class="tlx_logic">Version2_CTRL_next_elevator_light_a0[2:0] = 3'b000; </span><span class="tlx_comments">// Next value of: The floor lights in the elevator. 1 == lit. Cleared on arrival.
               </span><span class="tlx_logic">end else if (Version2_CTRL_floor_mask_a0[0]) begin
                  </span><span class="tlx_comments">// From floor 0
                  </span><span class="tlx_logic">if (| {Version2_CTRL_up_light_a0[1:0], Version2_CTRL_down_light_a0[2:1], Version2_CTRL_elevator_light_a0[2:1]}) begin
                     </span><span class="tlx_comments">// Go up.
                     //$next_went_up = '1;
                     </span><span class="tlx_logic">Version2_CTRL_next_floor_mask_a0 = 3'b010;
                     Version2_CTRL_next_up_light_a0[0] = '0;
                     Version2_CTRL_next_elevator_light_a0[1] = '0;
                  end else begin
                     </span><span class="tlx_comments">// Stay.
                     </span><span class="tlx_logic">Version2_CTRL_next_elevator_light_a0[0] = '0;
                  end
               end else if (Version2_CTRL_floor_mask_a0[2]) begin
                  </span><span class="tlx_comments">// From floor 2
                  </span><span class="tlx_logic">if (| {Version2_CTRL_down_light_a0[2:1], Version2_CTRL_up_light_a0[1:0], Version2_CTRL_elevator_light_a0[1:0]}) begin
                     </span><span class="tlx_comments">// Go down.
                     </span><span class="tlx_logic">Version2_CTRL_next_went_down_a0 = '1;
                     Version2_CTRL_next_floor_mask_a0 = 3'b010;
                     Version2_CTRL_next_down_light_a0[2] = '0;
                     Version2_CTRL_next_elevator_light_a0[1] = '0;
                  end else begin
                     </span><span class="tlx_comments">// Stay.
                     </span><span class="tlx_logic">Version2_CTRL_next_elevator_light_a0[2] = '0;
                  end
               end else begin
                  </span><span class="tlx_comments">// From floor 1
                  </span><span class="tlx_logic">if (Version2_CTRL_called_top_a0 &amp;&amp; (!Version2_CTRL_went_down_a0 || !Version2_CTRL_called_bottom_a0)) begin
                     </span><span class="tlx_comments">// Go up (gets priority over down when no momentum).
                     //$next_went_up = '1;
                     </span><span class="tlx_logic">Version2_CTRL_next_floor_mask_a0 = 3'b100;
                     Version2_CTRL_next_up_light_a0[1] = '0;
                     Version2_CTRL_next_elevator_light_a0[2] = '0;
                  end else if (Version2_CTRL_called_bottom_a0 &amp;&amp; (Version2_CTRL_went_down_a0 || !Version2_CTRL_called_top_a0)) begin
                     </span><span class="tlx_comments">// Go down.
                     </span><span class="tlx_logic">Version2_CTRL_next_went_down_a0 = '1;
                     Version2_CTRL_next_floor_mask_a0 = 3'b001;
                     Version2_CTRL_next_down_light_a0[1] = '0;
                     Version2_CTRL_next_elevator_light_a0[0] = '0;
                  end else begin
                     </span><span class="tlx_comments">// Stay.
                     </span><span class="tlx_logic">Version2_CTRL_next_elevator_light_a0[1] = '0;
                  end 
               end
               
               </span><span class="tlx_comments">// Update state for floor button presses.
               </span><span class="tlx_logic">for (int fl = 0; fl &lt; 3; fl++) begin
                  if (Version2_CTRL_up_pressed_a0[fl]) Version2_CTRL_next_up_light_a0[fl] = '1;
                  if (Version2_CTRL_down_pressed_a0[fl]) Version2_CTRL_next_down_light_a0[fl] = '1;
               end </span><span class="tlx_structure">end
            
            </span><span class="tlx_comments">// Stage next state values from combinational state update logic.
            </span><span class="tlx_logic">assign Version2_CTRL_went_down_a0 = Version2_CTRL_next_went_down_a1;
            </span><span class="tlx_comments">//$went_up = &gt;&gt;1$next_went_up;
            </span><span class="tlx_logic">assign Version2_CTRL_floor_mask_a0[2:0] = Version2_CTRL_next_floor_mask_a1;
            assign Version2_CTRL_up_light_a0[1:0] = Version2_CTRL_next_up_light_a1;
            assign Version2_CTRL_down_light_a0[2:1] = Version2_CTRL_next_down_light_a1;
            assign Version2_CTRL_elevator_light_a0[2:0] = Version2_CTRL_next_elevator_light_a1;

   
   </span><span class="tlx_comments">// ==========
   // Version 3) Hand-coded TL-Verilog.
   // ==========
   
   // DUT
   // Macros to compute floor above/below with wrap (because some Verilog compilers complain about out-of-bounds accesses).
   // Note that for m4_above ($1 + 2) % 3 is ($1 - 1) % 3, but with positive modulo math.
   
   
   //_|ctrl
      //_@0
         </span><span class="tlx_logic">assign CTRL_reset_a0 = L0_reset_a0;
         assign CTRL_next_floor_a0[1:0] = CTRL_reset_a0   ? 2'b0 :
                            CTRL_go_up_a0   ? CTRL_Floor_a0 + 2'b1 :
                            CTRL_go_down_a0 ? CTRL_Floor_a0 - 2'b1 :
                                       CTRL_next_floor_a1[1:0];
         assign CTRL_Floor_n1[1:0] = CTRL_next_floor_a0;  </span><span class="tlx_comments">// WORKAROUND: &lt;&lt;1$Floor can't be used, currently, so $next_floor created as temporary.
         </span><span class="tlx_structure">for (floor = 0; floor &lt;= 2; floor++) begin : L1b_CTRL_Floor </span><span class="tlx_declarations">logic L1_DownLight_n1, L1_DownLight_a0; logic L1_ElevatorLight_n1, L1_ElevatorLight_a0; logic L1_UpLight_n1, L1_UpLight_a0; </span><span class="tlx_comments">//_/floor
            // Clear elevator light on arrival at next floor, or set it after pressed.
            </span><span class="tlx_logic">assign L1_ElevatorLight_n1 = CTRL_reset_a0 ? 1'b0 :
                              CTRL_next_floor_a0 == floor ? 1'b0 :
                              L1_ElevatorLight_a0 || CTRL_Floor_elevator_button_pressed_a0[floor];
            </span><span class="tlx_comments">// Set up   light on this floor when pressed, and clear when leaving this floor upward.
            </span><span class="tlx_logic">assign L1_UpLight_n1   = CTRL_Floor_up_pressed_a0[floor]                                ? 1'b1 :
                          ((CTRL_Floor_a0 == floor) &amp;&amp; CTRL_go_up_a0)   ? 1'b0 :
                                                                       L1_UpLight_a0;
            </span><span class="tlx_comments">// Set down light on this floor when pressed, and clear when leaving this floor downward.
            </span><span class="tlx_logic">assign L1_DownLight_n1 = CTRL_Floor_down_pressed_a0[floor]                              ? 1'b1 :
                          ((CTRL_Floor_a0 == floor) &amp;&amp; CTRL_go_down_a0) ? 1'b0 :
                                                                       L1_DownLight_a0;
            </span><span class="tlx_comments">// Call elevator to this floor when requested within elevator or at floor.
            </span><span class="tlx_logic">assign CTRL_Floor_called_a0[floor] = L1_ElevatorLight_a0 || L1_DownLight_a0 || L1_UpLight_a0;
            </span><span class="tlx_comments">// $called_above/below if $called above/below or up/down button is lit on this floor.
            </span><span class="tlx_logic">assign CTRL_Floor_called_above_a0[floor] = L1_UpLight_a0   || ((floor == 2) ? 1'b0 : CTRL_Floor_called_a0[((floor + 1) % 3)] || CTRL_Floor_called_above_a0[((floor + 1) % 3)]);
            assign CTRL_Floor_called_below_a0[floor] = L1_DownLight_a0 || ((floor == 0) ? 1'b0 : CTRL_Floor_called_a0[((floor + 2) % 3)] || CTRL_Floor_called_below_a0[((floor + 2) % 3)]); </span><span class="tlx_structure">end
         </span><span class="tlx_comments">// Go up or down if called that way, breaking tie based on momentum and then prioritizing up.
         </span><span class="tlx_logic">assign CTRL_go_up_a0   = ((! CTRL_go_down_a1 || ! CTRL_Floor_called_below_a0[CTRL_Floor_a0]) &amp;&amp; CTRL_Floor_called_above_a0[CTRL_Floor_a0]);
         assign CTRL_go_down_a0 = ((  CTRL_go_down_a1 || ! CTRL_Floor_called_above_a0[CTRL_Floor_a0]) &amp;&amp; CTRL_Floor_called_below_a0[CTRL_Floor_a0]);

         
         </span><span class="tlx_comments">// Compare all three models.
         </span><span class="tlx_logic">assign CTRL_Error_n1 = CTRL_reset_a0 ? 1'b0 : !((floor_mask == Version2_CTRL_floor_mask_a0) &amp;&amp; ((3'b1 &lt;&lt; CTRL_Floor_a0) == Version2_CTRL_floor_mask_a0)) || CTRL_Error_a0;
         assign failed = (cyc_cnt &gt; 400) &amp;&amp;   CTRL_Error_a0;
         assign passed = (cyc_cnt &gt; 400) &amp;&amp; ! CTRL_Error_a0; </span><span class="tlx_structure">endgenerate
</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 326, 1239, 0, 8, 216, 0, 0, 0, 'opacity: 0.1', 1685, 'opacity: 0.1', 1500, 'opacity: 0.1'],
      ['top.sv', 0, 326, 1878, 167, 0, 253, 0, 0, 0, 'opacity: 0.1', 1894, 'opacity: 0.1', 1584, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 453, 290, 161, 0, 0, 1373, 'opacity: 0.1', 1023, 'opacity: 0.1', 1309, 'opacity: 0.1'],
      ['SV Total', 0, 326, 1878, 620, 290, 414, 0, 0, 1373, 'opacity: 0.1', 2917, 'opacity: 0.1', 2893, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar xx, yy;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For |default$reset.
</span><span class="tlx_declarations">logic DEFAULT_reset_a1,
      DEFAULT_reset_a2;

</span><span class="tlx_comments">// For |default/tb$above_min_start.
</span><span class="tlx_declarations">logic DEFAULT_Tb_above_min_start_a2;

</span><span class="tlx_comments">// For |default/tb$alive_cnt.
</span><span class="tlx_declarations">logic [21:0] DEFAULT_Tb_alive_cnt_a2;

</span><span class="tlx_comments">// For |default/tb$below_max_stop.
</span><span class="tlx_declarations">logic DEFAULT_Tb_below_max_stop_a2;

</span><span class="tlx_comments">// For |default/tb$start_ok.
</span><span class="tlx_declarations">logic DEFAULT_Tb_start_ok_a2,
      DEFAULT_Tb_start_ok_a3;

</span><span class="tlx_comments">// For |default/tb$stop_cnt.
</span><span class="tlx_declarations">logic [7:0] DEFAULT_Tb_stop_cnt_a2,
            DEFAULT_Tb_stop_cnt_a3;

</span><span class="tlx_comments">// For |default/tb/yy$vert_alive_accum.
</span><span class="tlx_declarations">logic [21:0] DEFAULT_Tb_Yy_vert_alive_accum_a2 [Y_SIZE-1:0];

</span><span class="tlx_comments">// For |default/yy/xx$alive.
</span><span class="tlx_declarations">logic [X_SIZE-1:0] DEFAULT_Yy_Xx_alive_a1 [Y_SIZE-1:0],
                   DEFAULT_Yy_Xx_alive_a2 [Y_SIZE-1:0];

</span><span class="tlx_comments">// For |default/yy/xx$row_cnt.
</span><span class="tlx_declarations">logic [1:0] DEFAULT_Yy_Xx_row_cnt_a1 [Y_SIZE-1:0][X_SIZE-1:0];


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">

   //
   // Scope: |default
   //

      // For $reset.
      </span><span class="tlx_staging">always_ff @(posedge clk) DEFAULT_reset_a2 &lt;= DEFAULT_reset_a1;


      </span><span class="tlx_comments">//
      // Scope: /tb
      //

         // For $start_ok.
         </span><span class="tlx_staging">always_ff @(posedge clk) DEFAULT_Tb_start_ok_a3 &lt;= DEFAULT_Tb_start_ok_a2;

         </span><span class="tlx_comments">// For $stop_cnt.
         </span><span class="tlx_staging">always_ff @(posedge clk) DEFAULT_Tb_stop_cnt_a3[7:0] &lt;= DEFAULT_Tb_stop_cnt_a2[7:0];



      </span><span class="tlx_comments">//
      // Scope: /yy[Y_SIZE-1:0]
      //
      </span><span class="tlx_structure">for (yy = 0; yy &lt;= Y_SIZE-1; yy++) begin : L1gen_DEFAULT_Yy
</span><span class="tlx_comments">
         //
         // Scope: /xx[X_SIZE-1:0]
         //
         </span><span class="tlx_structure">for (xx = 0; xx &lt;= X_SIZE-1; xx++) begin : L2gen_Xx
</span><span class="tlx_comments">            // For $alive.
            </span><span class="tlx_staging">always_ff @(posedge clk) DEFAULT_Yy_Xx_alive_a2[yy][xx] &lt;= DEFAULT_Yy_Xx_alive_a1[yy][xx];

         </span><span class="tlx_structure">end
      end



endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS
</span><span class="tlx_comments">

      //
      // Scope: |default
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|default 
         logic  \@1$reset ;
         assign \@1$reset = DEFAULT_reset_a1;

         </span><span class="tlx_comments">//
         // Scope: /tb
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/tb 
            logic  \@2$above_min_start ;
            assign \@2$above_min_start = DEFAULT_Tb_above_min_start_a2;
            logic [21:0] \@2$alive_cnt ;
            assign \@2$alive_cnt = DEFAULT_Tb_alive_cnt_a2;
            logic  \@2$below_max_stop ;
            assign \@2$below_max_stop = DEFAULT_Tb_below_max_stop_a2;
            logic  \@2$start_ok ;
            assign \@2$start_ok = DEFAULT_Tb_start_ok_a2;
            logic [7:0] \@2$stop_cnt ;
            assign \@2$stop_cnt = DEFAULT_Tb_stop_cnt_a2;

            </span><span class="tlx_comments">//
            // Scope: /yy[Y_SIZE-1:0]
            //
            </span><span class="tlx_instrumentation">for (yy = 0; yy &lt;= Y_SIZE-1; yy++) begin : \/yy 
               logic [21:0] \@2$below_alive_accum ;
               assign \@2$below_alive_accum = L1_DEFAULT_Tb_Yy[yy].L1_below_alive_accum_a2;
               logic [21:0] \@2$vert_alive_accum ;
               assign \@2$vert_alive_accum = DEFAULT_Tb_Yy_vert_alive_accum_a2[yy];

               </span><span class="tlx_comments">//
               // Scope: /xx[X_SIZE-1:0]
               //
               </span><span class="tlx_instrumentation">for (xx = 0; xx &lt;= X_SIZE-1; xx++) begin : \/xx 
                  logic [10:0] \@2$horiz_alive_accum ;
                  assign \@2$horiz_alive_accum = L1_DEFAULT_Tb_Yy[yy].L1_Xx_horiz_alive_accum_a2[xx];
                  logic [10:0] \@2$right_alive_accum ;
                  assign \@2$right_alive_accum = L1_DEFAULT_Tb_Yy[yy].L2_Xx[xx].L2_right_alive_accum_a2;
               end
            end
         end

         </span><span class="tlx_comments">//
         // Scope: /yy[Y_SIZE-1:0]
         //
         </span><span class="tlx_instrumentation">for (yy = 0; yy &lt;= Y_SIZE-1; yy++) begin : \/yy 
</span><span class="tlx_comments">
            //
            // Scope: /xx[X_SIZE-1:0]
            //
            </span><span class="tlx_instrumentation">for (xx = 0; xx &lt;= X_SIZE-1; xx++) begin : \/xx 
               logic  \@1$alive ;
               assign \@1$alive = DEFAULT_Yy_Xx_alive_a1[yy][xx];
               logic [3:0] \@1$cnt ;
               assign \@1$cnt = L1_DEFAULT_Yy[yy].L2_Xx[xx].L2_cnt_a1;
               logic [0:0] \@1$init_alive ;
               assign \@1$init_alive = L1_DEFAULT_Yy[yy].L2_Xx[xx].L2_init_alive_a1;
               logic [1:0] \@1$row_cnt ;
               assign \@1$row_cnt = DEFAULT_Yy_Xx_row_cnt_a1[yy][xx];
            end
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV

</span><span class="tlx_comments">// --------------------------------------------------------------------
//
// This example implements Conway's Game of Life.
// In this &quot;game&quot;, a grid of cells (10x10) are born and die based on the
// number of live neighbors they have in each step (clock cycle).
// A cell's neighbors are the surrounding 8 cells, which includes the
// diagonals.
//   - A cell is born if exactly 3 neighbors are alive.
//   - A cell dies from overcrowding or starvation if it have &gt;3 or &lt;2
//     neighbors.
//
// Output shows the grid in each step of simulation.
//
// This example shows:
//   - Use of SystemVerilog constants.
//   - Use of TL-Verilog &quot;behavioral hierarchy&quot;.  (Eg, &gt;xx[X_SIZE-1:0])
//   - That TL-Verilog is not just for pipelines!
//
// --------------------------------------------------------------------


</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */

// -------------------------
// Parameters

// Board size
</span><span class="tlx_untouched">localparam X_SIZE = 10;  </span><span class="tlx_comments">// Note: There's a hardcoded X_SIZE in $display statement.
</span><span class="tlx_untouched">localparam Y_SIZE = 10;

</span><span class="tlx_comments">/* verilator lint_off UNOPTFLAT */  // To silence Verilator warnings.

</span><span class="tlx_structure">\TLV



   </span><span class="tlx_comments">// -------------------------
   // Design

   </span><span class="tlx_structure">|default
      </span><span class="tlx_staging">@1
         </span><span class="tlx_logic">$reset = *reset;
      </span><span class="tlx_structure">/yy[</span><span class="tlx_logic">Y_SIZE-1</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         /xx[</span><span class="tlx_logic">X_SIZE-1</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            </span><span class="tlx_staging">@1
               </span><span class="tlx_comments">// Cell logic

               // ===========
               // Population count ($cnt) of 3x3 square (with edge logic).
               
               // Sum left + me + right.
               </span><span class="tlx_logic">$row_cnt[1:0] = {1'b0, (</span><span class="tlx_structure">/xx[</span><span class="tlx_logic">(xx + X_SIZE-1) % X_SIZE</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$alive &amp; (xx &gt; 0))} +
                               {1'b0, &gt;&gt;1$alive} +
                               {1'b0, (</span><span class="tlx_structure">/xx[</span><span class="tlx_logic">(xx + 1) % X_SIZE</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$alive &amp; (xx &lt; X_SIZE-1))};
               </span><span class="tlx_comments">// Sum three $row_cnt's: above + mine + below.
               </span><span class="tlx_logic">$cnt[3:0] = {2'b00, (</span><span class="tlx_structure">/yy[</span><span class="tlx_logic">(yy + Y_SIZE-1) % Y_SIZE</span><span class="tlx_structure">]/xx</span><span class="tlx_logic">$row_cnt &amp; {2{(yy &gt; 0)}})} +
                           {2'b00, $row_cnt[1:0]} +
                           {2'b00, (</span><span class="tlx_structure">/yy[</span><span class="tlx_logic">(yy + 1) % Y_SIZE</span><span class="tlx_structure">]/xx</span><span class="tlx_logic">$row_cnt &amp; {2{(yy &lt; Y_SIZE-1)}})};


               </span><span class="tlx_comments">// ===========
               // Init state.
               
               </span><span class="tlx_logic">$init_alive[0:0] = *RW_rand_vect[(0 + ((yy * xx) ^ ((3 * xx) + yy))) % 257 +: 1];


               </span><span class="tlx_comments">// ===========
               // Am I alive?
               
               </span><span class="tlx_logic">$alive = </span><span class="tlx_structure">|default</span><span class="tlx_logic">$reset ? $init_alive :           </span><span class="tlx_comments">// init
                        </span><span class="tlx_logic">&gt;&gt;1$alive ? ($cnt &gt;= 3 &amp;&amp; $cnt &lt;= 4) :   </span><span class="tlx_comments">// stay alive
                                    </span><span class="tlx_logic">($cnt == 3);                 </span><span class="tlx_comments">// born






   // -------------------------
   // Embedded testbench
   //
   // Declare success when total live cells was above 25% and remains below 6.25% for 20 cycles.

   // Count live cells through accumulation, into $alive_cnt.
   // Accumulate right-to-left, then bottom-to-top through &gt;yy[0].
   </span><span class="tlx_structure">|default
      /tb
         </span><span class="tlx_staging">@2
            </span><span class="tlx_structure">/yy[</span><span class="tlx_logic">Y_SIZE-1</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
               /xx[</span><span class="tlx_logic">X_SIZE-1</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
                  \SV_plus
                     </span><span class="tlx_logic">if (xx &lt; X_SIZE - 1)
                        assign $$right_alive_accum[10:0] = </span><span class="tlx_structure">/xx[</span><span class="tlx_logic">xx + 1</span><span class="tlx_structure">]</span><span class="tlx_logic">$horiz_alive_accum;
                     else
                        assign $right_alive_accum[10:0] = 11'b0;
                  $horiz_alive_accum[10:0] = $right_alive_accum + {10'b0, </span><span class="tlx_structure">|default/yy/xx</span><span class="tlx_logic">$alive};
               </span><span class="tlx_structure">\SV_plus
                  </span><span class="tlx_logic">if (yy &lt; Y_SIZE -1)
                     assign $$below_alive_accum[21:0] = </span><span class="tlx_structure">/yy[</span><span class="tlx_logic">yy + 1</span><span class="tlx_structure">]</span><span class="tlx_logic">$vert_alive_accum;
                  else
                     assign $below_alive_accum[21:0] = 22'b0;
               $vert_alive_accum[21:0] = $below_alive_accum + {11'b0, </span><span class="tlx_structure">/xx[</span><span class="tlx_logic">0</span><span class="tlx_structure">]</span><span class="tlx_logic">$horiz_alive_accum};
            $alive_cnt[21:0] = </span><span class="tlx_structure">/yy[</span><span class="tlx_logic">0</span><span class="tlx_structure">]</span><span class="tlx_logic">$vert_alive_accum;
            $above_min_start = $alive_cnt &gt; (X_SIZE * Y_SIZE) &gt;&gt; 2;  </span><span class="tlx_comments">// 1/4
            </span><span class="tlx_logic">$below_max_stop  = $alive_cnt &lt; (X_SIZE * Y_SIZE) &gt;&gt; 4;  </span><span class="tlx_comments">// 1/16
            </span><span class="tlx_logic">$start_ok = </span><span class="tlx_structure">|default</span><span class="tlx_logic">$reset ? 1'b0 : (&gt;&gt;1$start_ok || $above_min_start);
            $stop_cnt[7:0] = </span><span class="tlx_structure">|default</span><span class="tlx_logic">$reset  ? 8'b0 :
                             $below_max_stop ? &gt;&gt;1$stop_cnt + 8'b1 :
                                               8'b0;
            *passed = &gt;&gt;1$start_ok &amp;&amp; (($alive_cnt == '0) || (&gt;&gt;1$stop_cnt &gt; 8'd20));

      </span><span class="tlx_structure">/print
         </span><span class="tlx_comments">// Print
         </span><span class="tlx_staging">@2
            </span><span class="tlx_structure">\SV_plus
               </span><span class="tlx_logic">always_ff @(posedge clk) begin
                  \$display(&quot;---------------&quot;);
                  for (int y = 0; y &lt; Y_SIZE; y++) begin
                     if (! </span><span class="tlx_structure">|default</span><span class="tlx_logic">$reset) begin
                        \$display(&quot;    \%10b&quot;, </span><span class="tlx_structure">|default/yy[</span><span class="tlx_logic">y</span><span class="tlx_structure">]/xx[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$alive);
                     end
                  end
               end
</span><span class="tlx_structure">\SV
</span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV

// --------------------------------------------------------------------
//
// This example implements Conway's Game of Life.
// In this &quot;game&quot;, a grid of cells (10x10) are born and die based on the
// number of live neighbors they have in each step (clock cycle).
// A cell's neighbors are the surrounding 8 cells, which includes the
// diagonals.
//   - A cell is born if exactly 3 neighbors are alive.
//   - A cell dies from overcrowding or starvation if it have &gt;3 or &lt;2
//     neighbors.
//
// Output shows the grid in each step of simulation.
//
// This example shows:
//   - Use of SystemVerilog constants.
//   - Use of TL-Verilog &quot;behavioral hierarchy&quot;.  (Eg, &gt;xx[X_SIZE-1:0])
//   - That TL-Verilog is not just for pipelines!
//
// --------------------------------------------------------------------


</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */

// -------------------------
// Parameters

// Board size
</span><span class="tlx_untouched">localparam X_SIZE = 10;  </span><span class="tlx_comments">// Note: There's a hardcoded X_SIZE in $display statement.
</span><span class="tlx_untouched">localparam Y_SIZE = 10;

</span><span class="tlx_comments">/* verilator lint_off UNOPTFLAT */  // To silence Verilator warnings.

</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV



   // -------------------------
   // Design

   //_|default
      //_@1
         </span><span class="tlx_logic">assign DEFAULT_reset_a1 = reset;
      </span><span class="tlx_structure">for (yy = 0; yy &lt;= Y_SIZE-1; yy++) begin : L1_DEFAULT_Yy </span><span class="tlx_comments">//_/yy
         </span><span class="tlx_structure">for (xx = 0; xx &lt;= X_SIZE-1; xx++) begin : L2_Xx </span><span class="tlx_declarations">logic [3:0] L2_cnt_a1; logic [0:0] L2_init_alive_a1; </span><span class="tlx_comments">//_/xx
            //_@1
               // Cell logic

               // ===========
               // Population count ($cnt) of 3x3 square (with edge logic).
               
               // Sum left + me + right.
               </span><span class="tlx_logic">assign DEFAULT_Yy_Xx_row_cnt_a1[yy][xx][1:0] = {1'b0, (DEFAULT_Yy_Xx_alive_a2[yy][(xx + X_SIZE-1) % X_SIZE] &amp; (xx &gt; 0))} +
                               {1'b0, DEFAULT_Yy_Xx_alive_a2[yy][xx]} +
                               {1'b0, (DEFAULT_Yy_Xx_alive_a2[yy][(xx + 1) % X_SIZE] &amp; (xx &lt; X_SIZE-1))};
               </span><span class="tlx_comments">// Sum three $row_cnt's: above + mine + below.
               </span><span class="tlx_logic">assign L2_cnt_a1[3:0] = {2'b00, (DEFAULT_Yy_Xx_row_cnt_a1[(yy + Y_SIZE-1) % Y_SIZE][xx] &amp; {2{(yy &gt; 0)}})} +
                           {2'b00, DEFAULT_Yy_Xx_row_cnt_a1[yy][xx][1:0]} +
                           {2'b00, (DEFAULT_Yy_Xx_row_cnt_a1[(yy + 1) % Y_SIZE][xx] &amp; {2{(yy &lt; Y_SIZE-1)}})};


               </span><span class="tlx_comments">// ===========
               // Init state.
               
               </span><span class="tlx_logic">assign L2_init_alive_a1[0:0] = RW_rand_vect[(0 + ((yy * xx) ^ ((3 * xx) + yy))) % 257 +: 1];


               </span><span class="tlx_comments">// ===========
               // Am I alive?
               
               </span><span class="tlx_logic">assign DEFAULT_Yy_Xx_alive_a1[yy][xx] = DEFAULT_reset_a1 ? L2_init_alive_a1 :           </span><span class="tlx_comments">// init
                        </span><span class="tlx_logic">DEFAULT_Yy_Xx_alive_a2[yy][xx] ? (L2_cnt_a1 &gt;= 3 &amp;&amp; L2_cnt_a1 &lt;= 4) :   </span><span class="tlx_comments">// stay alive
                                    </span><span class="tlx_logic">(L2_cnt_a1 == 3); </span><span class="tlx_structure">end end                 </span><span class="tlx_comments">// born






   // -------------------------
   // Embedded testbench
   //
   // Declare success when total live cells was above 25% and remains below 6.25% for 20 cycles.

   // Count live cells through accumulation, into $alive_cnt.
   // Accumulate right-to-left, then bottom-to-top through &gt;yy[0].
   //_|default
      //_/tb
         //_@2
            </span><span class="tlx_structure">for (yy = 0; yy &lt;= Y_SIZE-1; yy++) begin : L1_DEFAULT_Tb_Yy </span><span class="tlx_declarations">logic [21:0] L1_below_alive_accum_a2; logic [10:0] L1_Xx_horiz_alive_accum_a2 [X_SIZE-1:0]; </span><span class="tlx_comments">//_/yy
               </span><span class="tlx_structure">for (xx = 0; xx &lt;= X_SIZE-1; xx++) begin : L2_Xx </span><span class="tlx_declarations">logic [10:0] L2_right_alive_accum_a2; </span><span class="tlx_comments">//_/xx
                  /*SV_plus*/
                     </span><span class="tlx_logic">if (xx &lt; X_SIZE - 1)
                        assign L2_right_alive_accum_a2[10:0] = L1_Xx_horiz_alive_accum_a2[xx + 1];
                     else
                        assign L2_right_alive_accum_a2[10:0] = 11'b0;
                  assign L1_Xx_horiz_alive_accum_a2[xx][10:0] = L2_right_alive_accum_a2 + {10'b0, DEFAULT_Yy_Xx_alive_a2[yy][xx]}; </span><span class="tlx_structure">end
               </span><span class="tlx_comments">/*SV_plus*/
                  </span><span class="tlx_logic">if (yy &lt; Y_SIZE -1)
                     assign L1_below_alive_accum_a2[21:0] = DEFAULT_Tb_Yy_vert_alive_accum_a2[yy + 1];
                  else
                     assign L1_below_alive_accum_a2[21:0] = 22'b0;
               assign DEFAULT_Tb_Yy_vert_alive_accum_a2[yy][21:0] = L1_below_alive_accum_a2 + {11'b0, L1_Xx_horiz_alive_accum_a2[0]}; </span><span class="tlx_structure">end
            </span><span class="tlx_logic">assign DEFAULT_Tb_alive_cnt_a2[21:0] = DEFAULT_Tb_Yy_vert_alive_accum_a2[0];
            assign DEFAULT_Tb_above_min_start_a2 = DEFAULT_Tb_alive_cnt_a2 &gt; (X_SIZE * Y_SIZE) &gt;&gt; 2;  </span><span class="tlx_comments">// 1/4
            </span><span class="tlx_logic">assign DEFAULT_Tb_below_max_stop_a2  = DEFAULT_Tb_alive_cnt_a2 &lt; (X_SIZE * Y_SIZE) &gt;&gt; 4;  </span><span class="tlx_comments">// 1/16
            </span><span class="tlx_logic">assign DEFAULT_Tb_start_ok_a2 = DEFAULT_reset_a2 ? 1'b0 : (DEFAULT_Tb_start_ok_a3 || DEFAULT_Tb_above_min_start_a2);
            assign DEFAULT_Tb_stop_cnt_a2[7:0] = DEFAULT_reset_a2  ? 8'b0 :
                             DEFAULT_Tb_below_max_stop_a2 ? DEFAULT_Tb_stop_cnt_a3 + 8'b1 :
                                               8'b0;
            assign passed = DEFAULT_Tb_start_ok_a3 &amp;&amp; ((DEFAULT_Tb_alive_cnt_a2 == '0) || (DEFAULT_Tb_stop_cnt_a3 &gt; 8'd20));

      </span><span class="tlx_comments">//_/print
         // Print
         //_@2
            /*SV_plus*/
               </span><span class="tlx_logic">always_ff @(posedge clk) begin
                  $display(&quot;---------------&quot;);
                  for (int y = 0; y &lt; Y_SIZE; y++) begin
                     if (! DEFAULT_reset_a2) begin
                        $display(&quot;    %10b&quot;, DEFAULT_Yy_Xx_alive_a2[y]);
                     end
                  end
               end </span><span class="tlx_structure">endgenerate
</span><span class="tlx_comments">//_\SV
</span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"





//
// Signals declared top-level.
//

// For $Cnt.
logic [15:0] L0_Cnt_n1,
             L0_Cnt_a0;

// For $reset.
logic L0_reset_a0;

// For |exe$adj_offset6.
logic [15:0] EXE_adj_offset6_a5;

// For |exe$aluop.
logic [3:0] EXE_aluop_a4,
            EXE_aluop_a5;

// For |exe$br.
logic EXE_br_a4,
      EXE_br_a5,
      EXE_br_a6;

// For |exe$cc.
logic [2:0] EXE_cc_a5,
            EXE_cc_a6;

// For |exe$dest.
logic [2:0] EXE_dest_a4,
            EXE_dest_a5,
            EXE_dest_a6;

// For |exe$fetch.
logic EXE_fetch_a6;

// For |exe$instr_valid.
logic EXE_instr_valid_a3,
      EXE_instr_valid_a4,
      EXE_instr_valid_a5,
      EXE_instr_valid_a6;

// For |exe$ir.
logic [15:0] EXE_ir_a3,
             EXE_ir_a4;

// For |exe$mar.
logic [15:0] EXE_mar_a5,
             EXE_mar_a6;

// For |exe$mdr.
logic [15:0] EXE_mdr_a5,
             EXE_mdr_a6;

// For |exe$mem_op.
logic EXE_mem_op_a6,
      EXE_mem_op_a7,
      EXE_mem_op_a8;

// For |exe$mem_rdata.
logic [15:0] EXE_mem_rdata_a6;

// For |exe$mem_resp.
logic EXE_mem_resp_a6;

// For |exe$offset6.
logic [5:0] EXE_offset6_a4,
            EXE_offset6_a5;

// For |exe$offset9.
logic [8:0] EXE_offset9_a4,
            EXE_offset9_a5,
            EXE_offset9_a6;

// For |exe$opcode.
logic [3:0] EXE_opcode_a4;

// For |exe$reg_a.
logic [15:0] EXE_reg_a_a4,
             EXE_reg_a_a5;

// For |exe$reg_b.
logic [15:0] EXE_reg_b_a4,
             EXE_reg_b_a5;

// For |exe$rslt.
logic [15:0] EXE_rslt_a5;

// For |exe$src1.
logic [2:0] EXE_src1_a4;

// For |exe$src2.
logic [2:0] EXE_src2_a4;

// For |exe$valid_br_taken.
logic EXE_valid_br_taken_a6;

// For |exe$valid_exe_inst.
logic EXE_valid_exe_inst_a6;

// For |exe$valid_ld.
logic EXE_valid_ld_a4,
      EXE_valid_ld_a5,
      EXE_valid_ld_a6;

// For |exe$valid_mem_instr.
logic EXE_valid_mem_instr_a4,
      EXE_valid_mem_instr_a5,
      EXE_valid_mem_instr_a6;

// For |exe$valid_st.
logic EXE_valid_st_a4,
      EXE_valid_st_a5,
      EXE_valid_st_a6,
      EXE_valid_st_a7;

// For |fetch$instr_valid.
logic FETCH_instr_valid_a1,
      FETCH_instr_valid_a2;

// For |fetch$pc.
logic [15:0] FETCH_pc_a0,
             FETCH_pc_a1;

// For |fetch$reset.
logic FETCH_reset_a0,
      FETCH_reset_a1,
      FETCH_reset_a2;

// For |fetch$valid_br_taken.
logic FETCH_valid_br_taken_a0;

// For |resp$FetchPending.
logic RESP_FetchPending_a1,
      RESP_FetchPending_a2,
      RESP_FetchPending_a3;

// For |resp$LoadPending.
logic RESP_LoadPending_a1,
      RESP_LoadPending_a2,
      RESP_LoadPending_a3;

// For |resp$StorePending.
logic RESP_StorePending_a1,
      RESP_StorePending_a2,
      RESP_StorePending_a3;

// For |resp$fetch_resp_valid.
logic RESP_fetch_resp_valid_a3;

// For |resp$ld_resp_valid.
logic RESP_ld_resp_valid_a3,
      RESP_ld_resp_valid_a4;

// For |resp$mem_rdata.
logic [15:0] RESP_mem_rdata_a2,
             RESP_mem_rdata_a3;

// For |resp$mem_resp.
logic RESP_mem_resp_a2,
      RESP_mem_resp_a3;

// For |resp$next_store_pending.
logic RESP_next_store_pending_a2;

// For |resp$reset.
logic RESP_reset_a1,
      RESP_reset_a2;


//
// Scope: |exe
//

// Clock signals.
logic clkP_EXE_instr_valid_a5 ;
logic clkP_EXE_instr_valid_a6 ;


generate

   // For $Cnt.
   always_ff @(posedge clk) L0_Cnt_a0[15:0] <= L0_Cnt_n1[15:0];


   //
   // Scope: |exe
   //

      // For $aluop.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_aluop_a5[3:0] <= EXE_aluop_a4[3:0];

      // For $br.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_br_a5 <= EXE_br_a4;
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_br_a6 <= EXE_br_a5;

      // For $cc.
      always_ff @(posedge clk) EXE_cc_a6[2:0] <= EXE_cc_a5[2:0];

      // For $dest.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_dest_a5[2:0] <= EXE_dest_a4[2:0];
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_dest_a6[2:0] <= EXE_dest_a5[2:0];

      // For $instr_valid.
      always_ff @(posedge clk) EXE_instr_valid_a4 <= EXE_instr_valid_a3;
      always_ff @(posedge clk) EXE_instr_valid_a5 <= EXE_instr_valid_a4;
      always_ff @(posedge clk) EXE_instr_valid_a6 <= EXE_instr_valid_a5;

      // For $ir.
      always_ff @(posedge clk) EXE_ir_a4[15:0] <= EXE_ir_a3[15:0];

      // For $mar.
      always_ff @(posedge clk) EXE_mar_a6[15:0] <= EXE_mar_a5[15:0];

      // For $mdr.
      always_ff @(posedge clk) EXE_mdr_a6[15:0] <= EXE_mdr_a5[15:0];

      // For $mem_op.
      always_ff @(posedge clk) EXE_mem_op_a7 <= EXE_mem_op_a6;
      always_ff @(posedge clk) EXE_mem_op_a8 <= EXE_mem_op_a7;

      // For $offset6.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_offset6_a5[5:0] <= EXE_offset6_a4[5:0];

      // For $offset9.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_offset9_a5[8:0] <= EXE_offset9_a4[8:0];
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_offset9_a6[8:0] <= EXE_offset9_a5[8:0];

      // For $reg_a.
      always_ff @(posedge clk) EXE_reg_a_a5[15:0] <= EXE_reg_a_a4[15:0];

      // For $reg_b.
      always_ff @(posedge clk) EXE_reg_b_a5[15:0] <= EXE_reg_b_a4[15:0];

      // For $valid_ld.
      always_ff @(posedge clk) EXE_valid_ld_a5 <= EXE_valid_ld_a4;
      always_ff @(posedge clk) EXE_valid_ld_a6 <= EXE_valid_ld_a5;

      // For $valid_mem_instr.
      always_ff @(posedge clk) EXE_valid_mem_instr_a5 <= EXE_valid_mem_instr_a4;
      always_ff @(posedge clk) EXE_valid_mem_instr_a6 <= EXE_valid_mem_instr_a5;

      // For $valid_st.
      always_ff @(posedge clk) EXE_valid_st_a5 <= EXE_valid_st_a4;
      always_ff @(posedge clk) EXE_valid_st_a6 <= EXE_valid_st_a5;
      always_ff @(posedge clk) EXE_valid_st_a7 <= EXE_valid_st_a6;



   //
   // Scope: |fetch
   //

      // For $instr_valid.
      always_ff @(posedge clk) FETCH_instr_valid_a2 <= FETCH_instr_valid_a1;

      // For $pc.
      always_ff @(posedge clk) FETCH_pc_a1[15:0] <= FETCH_pc_a0[15:0];

      // For $reset.
      always_ff @(posedge clk) FETCH_reset_a1 <= FETCH_reset_a0;
      always_ff @(posedge clk) FETCH_reset_a2 <= FETCH_reset_a1;



   //
   // Scope: |resp
   //

      // For $FetchPending.
      always_ff @(posedge clk) RESP_FetchPending_a2 <= RESP_FetchPending_a1;
      always_ff @(posedge clk) RESP_FetchPending_a3 <= RESP_FetchPending_a2;

      // For $LoadPending.
      always_ff @(posedge clk) RESP_LoadPending_a2 <= RESP_LoadPending_a1;
      always_ff @(posedge clk) RESP_LoadPending_a3 <= RESP_LoadPending_a2;

      // For $StorePending.
      always_ff @(posedge clk) RESP_StorePending_a2 <= RESP_StorePending_a1;
      always_ff @(posedge clk) RESP_StorePending_a3 <= RESP_StorePending_a2;

      // For $ld_resp_valid.
      always_ff @(posedge clk) RESP_ld_resp_valid_a4 <= RESP_ld_resp_valid_a3;

      // For $mem_rdata.
      always_ff @(posedge clk) RESP_mem_rdata_a3[15:0] <= RESP_mem_rdata_a2[15:0];

      // For $mem_resp.
      always_ff @(posedge clk) RESP_mem_resp_a3 <= RESP_mem_resp_a2;

      // For $reset.
      always_ff @(posedge clk) RESP_reset_a2 <= RESP_reset_a1;




endgenerate



//
// Gated clocks.
//

generate



   //
   // Scope: |exe
   //

      clk_gate gen_clkP_EXE_instr_valid_a5(clkP_EXE_instr_valid_a5, clk, 1'b1, EXE_instr_valid_a4, 1'b0);
      clk_gate gen_clkP_EXE_instr_valid_a6(clkP_EXE_instr_valid_a6, clk, 1'b1, EXE_instr_valid_a5, 1'b0);



endgenerate



generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.

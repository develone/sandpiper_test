<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 1192, 1908, 0, 28, 227, 13, 0, 0, 'opacity: 0.1', 2054, 'opacity: 0.1', 2648, 'opacity: 0.1'],
      ['top.sv', 0, 1192, 2900, 0, 0, 73, 0, 0, 0, 'opacity: 0.1', 2259, 'opacity: 0.1', 2693, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 1619, 2567, 72, 0, 246, 0, 'opacity: 0.1', 1831, 'opacity: 0.1', 1409, 'opacity: 0.1'],
      ['SV Total', 0, 1192, 2900, 1619, 2567, 145, 0, 246, 0, 'opacity: 0.1', 4090, 'opacity: 0.1', 4102, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;





</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $Cnt.
</span><span class="tlx_declarations">logic [15:0] L0_Cnt_n1,
             L0_Cnt_a0;

</span><span class="tlx_comments">// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0;

</span><span class="tlx_comments">// For |exe$adj_offset6.
</span><span class="tlx_declarations">logic [15:0] EXE_adj_offset6_a5;

</span><span class="tlx_comments">// For |exe$aluop.
</span><span class="tlx_declarations">logic [3:0] EXE_aluop_a4,
            EXE_aluop_a5;

</span><span class="tlx_comments">// For |exe$br.
</span><span class="tlx_declarations">logic EXE_br_a4,
      EXE_br_a5,
      EXE_br_a6;

</span><span class="tlx_comments">// For |exe$cc.
</span><span class="tlx_declarations">logic [2:0] EXE_cc_a5,
            EXE_cc_a6;

</span><span class="tlx_comments">// For |exe$dest.
</span><span class="tlx_declarations">logic [2:0] EXE_dest_a4,
            EXE_dest_a5,
            EXE_dest_a6;

</span><span class="tlx_comments">// For |exe$fetch.
</span><span class="tlx_declarations">logic EXE_fetch_a6;

</span><span class="tlx_comments">// For |exe$instr_valid.
</span><span class="tlx_declarations">logic EXE_instr_valid_a3,
      EXE_instr_valid_a4,
      EXE_instr_valid_a5,
      EXE_instr_valid_a6;

</span><span class="tlx_comments">// For |exe$ir.
</span><span class="tlx_declarations">logic [15:0] EXE_ir_a3,
             EXE_ir_a4;

</span><span class="tlx_comments">// For |exe$mar.
</span><span class="tlx_declarations">logic [15:0] EXE_mar_a5,
             EXE_mar_a6;

</span><span class="tlx_comments">// For |exe$mdr.
</span><span class="tlx_declarations">logic [15:0] EXE_mdr_a5,
             EXE_mdr_a6;

</span><span class="tlx_comments">// For |exe$mem_op.
</span><span class="tlx_declarations">logic EXE_mem_op_a6,
      EXE_mem_op_a7,
      EXE_mem_op_a8;

</span><span class="tlx_comments">// For |exe$mem_rdata.
</span><span class="tlx_declarations">logic [15:0] EXE_mem_rdata_a6;

</span><span class="tlx_comments">// For |exe$mem_resp.
</span><span class="tlx_declarations">logic EXE_mem_resp_a6;

</span><span class="tlx_comments">// For |exe$offset6.
</span><span class="tlx_declarations">logic [5:0] EXE_offset6_a4,
            EXE_offset6_a5;

</span><span class="tlx_comments">// For |exe$offset9.
</span><span class="tlx_declarations">logic [8:0] EXE_offset9_a4,
            EXE_offset9_a5,
            EXE_offset9_a6;

</span><span class="tlx_comments">// For |exe$opcode.
</span><span class="tlx_declarations">logic [3:0] EXE_opcode_a4;

</span><span class="tlx_comments">// For |exe$reg_a.
</span><span class="tlx_declarations">logic [15:0] EXE_reg_a_a4,
             EXE_reg_a_a5;

</span><span class="tlx_comments">// For |exe$reg_b.
</span><span class="tlx_declarations">logic [15:0] EXE_reg_b_a4,
             EXE_reg_b_a5;

</span><span class="tlx_comments">// For |exe$rslt.
</span><span class="tlx_declarations">logic [15:0] EXE_rslt_a5;

</span><span class="tlx_comments">// For |exe$src1.
</span><span class="tlx_declarations">logic [2:0] EXE_src1_a4;

</span><span class="tlx_comments">// For |exe$src2.
</span><span class="tlx_declarations">logic [2:0] EXE_src2_a4;

</span><span class="tlx_comments">// For |exe$valid_br_taken.
</span><span class="tlx_declarations">logic EXE_valid_br_taken_a6;

</span><span class="tlx_comments">// For |exe$valid_exe_inst.
</span><span class="tlx_declarations">logic EXE_valid_exe_inst_a6;

</span><span class="tlx_comments">// For |exe$valid_ld.
</span><span class="tlx_declarations">logic EXE_valid_ld_a4,
      EXE_valid_ld_a5,
      EXE_valid_ld_a6;

</span><span class="tlx_comments">// For |exe$valid_mem_instr.
</span><span class="tlx_declarations">logic EXE_valid_mem_instr_a4,
      EXE_valid_mem_instr_a5,
      EXE_valid_mem_instr_a6;

</span><span class="tlx_comments">// For |exe$valid_st.
</span><span class="tlx_declarations">logic EXE_valid_st_a4,
      EXE_valid_st_a5,
      EXE_valid_st_a6,
      EXE_valid_st_a7;

</span><span class="tlx_comments">// For |fetch$instr_valid.
</span><span class="tlx_declarations">logic FETCH_instr_valid_a1,
      FETCH_instr_valid_a2;

</span><span class="tlx_comments">// For |fetch$pc.
</span><span class="tlx_declarations">logic [15:0] FETCH_pc_a0,
             FETCH_pc_a1;

</span><span class="tlx_comments">// For |fetch$reset.
</span><span class="tlx_declarations">logic FETCH_reset_a0,
      FETCH_reset_a1,
      FETCH_reset_a2;

</span><span class="tlx_comments">// For |fetch$valid_br_taken.
</span><span class="tlx_declarations">logic FETCH_valid_br_taken_a0;

</span><span class="tlx_comments">// For |resp$FetchPending.
</span><span class="tlx_declarations">logic RESP_FetchPending_a1,
      RESP_FetchPending_a2,
      RESP_FetchPending_a3;

</span><span class="tlx_comments">// For |resp$LoadPending.
</span><span class="tlx_declarations">logic RESP_LoadPending_a1,
      RESP_LoadPending_a2,
      RESP_LoadPending_a3;

</span><span class="tlx_comments">// For |resp$StorePending.
</span><span class="tlx_declarations">logic RESP_StorePending_a1,
      RESP_StorePending_a2,
      RESP_StorePending_a3;

</span><span class="tlx_comments">// For |resp$fetch_resp_valid.
</span><span class="tlx_declarations">logic RESP_fetch_resp_valid_a3;

</span><span class="tlx_comments">// For |resp$ld_resp_valid.
</span><span class="tlx_declarations">logic RESP_ld_resp_valid_a3,
      RESP_ld_resp_valid_a4;

</span><span class="tlx_comments">// For |resp$mem_rdata.
</span><span class="tlx_declarations">logic [15:0] RESP_mem_rdata_a2,
             RESP_mem_rdata_a3;

</span><span class="tlx_comments">// For |resp$mem_resp.
</span><span class="tlx_declarations">logic RESP_mem_resp_a2,
      RESP_mem_resp_a3;

</span><span class="tlx_comments">// For |resp$next_store_pending.
</span><span class="tlx_declarations">logic RESP_next_store_pending_a2;

</span><span class="tlx_comments">// For |resp$reset.
</span><span class="tlx_declarations">logic RESP_reset_a1,
      RESP_reset_a2;

</span><span class="tlx_comments">
//
// Scope: |exe
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_EXE_instr_valid_a5 ;
logic clkP_EXE_instr_valid_a6 ;

</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">
   // For $Cnt.
   </span><span class="tlx_staging">always_ff @(posedge clk) L0_Cnt_a0[15:0] &lt;= L0_Cnt_n1[15:0];


   </span><span class="tlx_comments">//
   // Scope: |exe
   //

      // For $aluop.
      </span><span class="tlx_staging">always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_aluop_a5[3:0] &lt;= EXE_aluop_a4[3:0];

      </span><span class="tlx_comments">// For $br.
      </span><span class="tlx_staging">always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_br_a5 &lt;= EXE_br_a4;
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_br_a6 &lt;= EXE_br_a5;

      </span><span class="tlx_comments">// For $cc.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_cc_a6[2:0] &lt;= EXE_cc_a5[2:0];

      </span><span class="tlx_comments">// For $dest.
      </span><span class="tlx_staging">always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_dest_a5[2:0] &lt;= EXE_dest_a4[2:0];
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_dest_a6[2:0] &lt;= EXE_dest_a5[2:0];

      </span><span class="tlx_comments">// For $instr_valid.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_instr_valid_a4 &lt;= EXE_instr_valid_a3;
      always_ff @(posedge clk) EXE_instr_valid_a5 &lt;= EXE_instr_valid_a4;
      always_ff @(posedge clk) EXE_instr_valid_a6 &lt;= EXE_instr_valid_a5;

      </span><span class="tlx_comments">// For $ir.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_ir_a4[15:0] &lt;= EXE_ir_a3[15:0];

      </span><span class="tlx_comments">// For $mar.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_mar_a6[15:0] &lt;= EXE_mar_a5[15:0];

      </span><span class="tlx_comments">// For $mdr.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_mdr_a6[15:0] &lt;= EXE_mdr_a5[15:0];

      </span><span class="tlx_comments">// For $mem_op.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_mem_op_a7 &lt;= EXE_mem_op_a6;
      always_ff @(posedge clk) EXE_mem_op_a8 &lt;= EXE_mem_op_a7;

      </span><span class="tlx_comments">// For $offset6.
      </span><span class="tlx_staging">always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_offset6_a5[5:0] &lt;= EXE_offset6_a4[5:0];

      </span><span class="tlx_comments">// For $offset9.
      </span><span class="tlx_staging">always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_offset9_a5[8:0] &lt;= EXE_offset9_a4[8:0];
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_offset9_a6[8:0] &lt;= EXE_offset9_a5[8:0];

      </span><span class="tlx_comments">// For $reg_a.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_reg_a_a5[15:0] &lt;= EXE_reg_a_a4[15:0];

      </span><span class="tlx_comments">// For $reg_b.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_reg_b_a5[15:0] &lt;= EXE_reg_b_a4[15:0];

      </span><span class="tlx_comments">// For $valid_ld.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_valid_ld_a5 &lt;= EXE_valid_ld_a4;
      always_ff @(posedge clk) EXE_valid_ld_a6 &lt;= EXE_valid_ld_a5;

      </span><span class="tlx_comments">// For $valid_mem_instr.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_valid_mem_instr_a5 &lt;= EXE_valid_mem_instr_a4;
      always_ff @(posedge clk) EXE_valid_mem_instr_a6 &lt;= EXE_valid_mem_instr_a5;

      </span><span class="tlx_comments">// For $valid_st.
      </span><span class="tlx_staging">always_ff @(posedge clk) EXE_valid_st_a5 &lt;= EXE_valid_st_a4;
      always_ff @(posedge clk) EXE_valid_st_a6 &lt;= EXE_valid_st_a5;
      always_ff @(posedge clk) EXE_valid_st_a7 &lt;= EXE_valid_st_a6;



   </span><span class="tlx_comments">//
   // Scope: |fetch
   //

      // For $instr_valid.
      </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_instr_valid_a2 &lt;= FETCH_instr_valid_a1;

      </span><span class="tlx_comments">// For $pc.
      </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_pc_a1[15:0] &lt;= FETCH_pc_a0[15:0];

      </span><span class="tlx_comments">// For $reset.
      </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_reset_a1 &lt;= FETCH_reset_a0;
      always_ff @(posedge clk) FETCH_reset_a2 &lt;= FETCH_reset_a1;



   </span><span class="tlx_comments">//
   // Scope: |resp
   //

      // For $FetchPending.
      </span><span class="tlx_staging">always_ff @(posedge clk) RESP_FetchPending_a2 &lt;= RESP_FetchPending_a1;
      always_ff @(posedge clk) RESP_FetchPending_a3 &lt;= RESP_FetchPending_a2;

      </span><span class="tlx_comments">// For $LoadPending.
      </span><span class="tlx_staging">always_ff @(posedge clk) RESP_LoadPending_a2 &lt;= RESP_LoadPending_a1;
      always_ff @(posedge clk) RESP_LoadPending_a3 &lt;= RESP_LoadPending_a2;

      </span><span class="tlx_comments">// For $StorePending.
      </span><span class="tlx_staging">always_ff @(posedge clk) RESP_StorePending_a2 &lt;= RESP_StorePending_a1;
      always_ff @(posedge clk) RESP_StorePending_a3 &lt;= RESP_StorePending_a2;

      </span><span class="tlx_comments">// For $ld_resp_valid.
      </span><span class="tlx_staging">always_ff @(posedge clk) RESP_ld_resp_valid_a4 &lt;= RESP_ld_resp_valid_a3;

      </span><span class="tlx_comments">// For $mem_rdata.
      </span><span class="tlx_staging">always_ff @(posedge clk) RESP_mem_rdata_a3[15:0] &lt;= RESP_mem_rdata_a2[15:0];

      </span><span class="tlx_comments">// For $mem_resp.
      </span><span class="tlx_staging">always_ff @(posedge clk) RESP_mem_resp_a3 &lt;= RESP_mem_resp_a2;

      </span><span class="tlx_comments">// For $reset.
      </span><span class="tlx_staging">always_ff @(posedge clk) RESP_reset_a2 &lt;= RESP_reset_a1;




</span><span class="tlx_structure">endgenerate



</span><span class="tlx_comments">//
// Gated clocks.
//

</span><span class="tlx_structure">generate

</span><span class="tlx_comments">

   //
   // Scope: |exe
   //

</span><span class="tlx_gating">      clk_gate gen_clkP_EXE_instr_valid_a5(clkP_EXE_instr_valid_a5, clk, 1'b1, EXE_instr_valid_a4, 1'b0);
      clk_gate gen_clkP_EXE_instr_valid_a6(clkP_EXE_instr_valid_a6, clk, 1'b1, EXE_instr_valid_a5, 1'b0);



</span><span class="tlx_structure">endgenerate



generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV

</span><span class="tlx_comments">// ------------------------
// SystemVerilog data types

</span><span class="tlx_untouched">typedef logic [15:0] mips_word;
typedef logic  [7:0] mips_byte;
typedef logic  [2:0] mips_reg;


typedef enum bit [3:0] {
    op_add  = 4'b0001,
    op_and  = 4'b0101,
    op_br   = 4'b0000,
    op_jmp  = 4'b1100,   </span><span class="tlx_comments">/* also RET */
    </span><span class="tlx_untouched">op_jsr  = 4'b0100,   </span><span class="tlx_comments">/* also JSRR */
    </span><span class="tlx_untouched">op_ldb  = 4'b0010,
    op_ldi  = 4'b1010,
    op_lea  = 4'b1110,
    op_not  = 4'b1001,
    op_ldr  = 4'b0110,
    op_rti  = 4'b1000,
    op_shf  = 4'b1101,
    op_stb  = 4'b0011,
    op_sti  = 4'b1011,
    op_str  = 4'b0111,
    op_trap = 4'b1111
} mips_opcode;

typedef enum bit [3:0] {
    alu_add,
    alu_and,
    alu_not
} mips_aluop;






module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
</span><span class="tlx_structure">\TLV
   </span><span class="tlx_comments">/*
   
   // Fetch pipe fetches an insruction.
   |fetch
      @1   // &quot;fetch1&quot;
      @2   // &quot;fetch2&quot;
   // A pipeline for execution, beginning from fetch response from memory.
   |exe
      @2   // &quot;fetch2&quot;
      @3   // &quot;fetch3&quot;
      @4   // &quot;decode&quot;
      @5   // exe (&quot;add&quot;, &quot;and&quot;, &quot;not&quot;, &quot;calc_addr&quot;, &quot;br&quot;)
      @6   // &quot;ld1/st1&quot;, &quot;br_taken&quot;, or next &quot;fetch 1&quot;
      @7   // &quot;st2&quot;, next &quot;fetch 1&quot; after &quot;br_taken&quot;
   // Pipeline for memory response for fetch/load/store.
   // Stages align with those of the instruction fetch response.
   |resp
      @2   // &quot;ld1/st2&quot;
      @3   // &quot;ld2&quot;, IR, next &quot;fetch1&quot; for store
      @4   // next &quot;fetch1&quot; for load
   */
   
   // Fetch next instruction
   </span><span class="tlx_structure">|fetch
      </span><span class="tlx_comments">// Next PC
      </span><span class="tlx_staging">@0
         </span><span class="tlx_logic">$reset = *reset;
         
         $valid_br_taken = </span><span class="tlx_structure">/top|exe</span><span class="tlx_logic">&gt;&gt;6$valid_br_taken;
         $pc[15:0] =
            $reset ? 16'b0 :
            ($valid_br_taken &amp;&amp; &gt;&gt;1$instr_valid)
               ? </span><span class="tlx_comments">// Add to PC (increment or branch).
                 </span><span class="tlx_logic">&gt;&gt;1$pc +
                    (&gt;&gt;1$instr_valid
                       ? </span><span class="tlx_comments">// increment
                         </span><span class="tlx_logic">16'd2
                       : </span><span class="tlx_comments">// branch
                         </span><span class="tlx_logic">{{7{</span><span class="tlx_structure">/top|exe</span><span class="tlx_logic">&gt;&gt;6$offset9[8]}},  </span><span class="tlx_comments">// sign ext
                          </span><span class="tlx_structure">/top|exe</span><span class="tlx_logic">&gt;&gt;6$offset9})         </span><span class="tlx_comments">// branch target
               </span><span class="tlx_logic">: $RETAIN;
               
      </span><span class="tlx_comments">// Next instruction
      </span><span class="tlx_staging">@1
         </span><span class="tlx_logic">$instr_valid =
            </span><span class="tlx_comments">// first instruction
            </span><span class="tlx_logic">(&gt;&gt;1$reset &amp;&amp; ! $reset) ||
            </span><span class="tlx_comments">// store
            </span><span class="tlx_logic">(</span><span class="tlx_structure">/top|resp</span><span class="tlx_logic">&gt;&gt;2$mem_resp &amp;&amp; </span><span class="tlx_structure">/top|resp</span><span class="tlx_logic">&gt;&gt;2$StorePending) ||  </span><span class="tlx_comments">// /top|resp&gt;&gt;2$st_resp_valid, but better timing.
            // load
            </span><span class="tlx_structure">/top|resp</span><span class="tlx_logic">&gt;&gt;3$ld_resp_valid ||
            </span><span class="tlx_comments">// else (alu, branch not-taken)
            </span><span class="tlx_structure">/top|exe</span><span class="tlx_logic">&gt;&gt;5$valid_exe_inst;
   
   </span><span class="tlx_comments">// Execute the instruction that was fetched.
   </span><span class="tlx_structure">|exe
      </span><span class="tlx_comments">//@2
      //   $reset = *reset;
         
      </span><span class="tlx_staging">@3
         </span><span class="tlx_logic">$instr_valid      = </span><span class="tlx_structure">/top|resp</span><span class="tlx_logic">&lt;&gt;0$fetch_resp_valid;    
         $ir[15:0] = $instr_valid ? </span><span class="tlx_structure">/top|resp</span><span class="tlx_logic">&lt;&gt;0$mem_rdata :
                                    $RETAIN;
      
      </span><span class="tlx_comments">// Decode
      </span><span class="tlx_staging">@4
         </span><span class="tlx_comments">// Condition on valid instruction if pipelined implementation.
         </span><span class="tlx_validity">?$instr_valid
            </span><span class="tlx_comments">// Instruction fields:
            </span><span class="tlx_logic">$opcode[3:0]  = $ir[15:12];
            $dest[2:0]    = $ir[11:9];
            $src1[2:0]    = $ir[8:6];
            $src2[2:0]    = $ir[2:0];
            $offset6[5:0] = $ir[5:0];
            $offset9[8:0] = $ir[8:0];
         
            </span><span class="tlx_comments">// Opcode Decode:
            </span><span class="tlx_structure">\always_comb
               </span><span class="tlx_logic">casez($opcode)
                  op_add:  $$aluop[3:0] = alu_add;
                  op_and:  $aluop = alu_and;
                  op_not:  $aluop = alu_not;
                  default: $aluop = 'x;
               endcase
            $br = $opcode == op_br;
         $valid_ld = $instr_valid &amp;&amp; $opcode == op_ldr;
         $valid_st = $instr_valid &amp;&amp; $opcode == op_str;
         $valid_mem_instr = $valid_ld || $valid_st;
            
      </span><span class="tlx_comments">// Regfile
      </span><span class="tlx_staging">@4
         </span><span class="tlx_logic">regfile rf(.clk(*clk),
                    .load(</span><span class="tlx_structure">/top|resp</span><span class="tlx_logic">&lt;&lt;1$ld_resp_valid),
                    .in(($instr_valid &amp;&amp; ! $valid_mem_instr)
                              ? &gt;&gt;1$rslt :
                                </span><span class="tlx_structure">/top|resp</span><span class="tlx_logic">&lt;&lt;1$mem_rdata),
                    .src_a($src1),
                    .src_b($src2),
                    .dest($dest),
                    .reg_a($$reg_a[15:0]),
                    .reg_b($$reg_b[15:0]));

      </span><span class="tlx_comments">// ALU
      </span><span class="tlx_staging">@5
         </span><span class="tlx_logic">$adj_offset6[15:0] = {{10{$offset6[5]}}, $offset6};
         alu alu(.aluop($aluop),
                 .a($reg_a),
                 .b($valid_mem_instr ? $adj_offset6 : $reg_b),
                 .f($$rslt[15:0]));

      </span><span class="tlx_comments">// Branch target
      </span><span class="tlx_staging">@5
         </span><span class="tlx_logic">$cc[2:0] = {$rslt[15], $rslt == 16'b0, | $rslt[14:0]};
      </span><span class="tlx_staging">@6
         </span><span class="tlx_logic">$valid_br_taken = $instr_valid &amp;&amp; $br &amp;&amp;
                           $cc == $dest;  </span><span class="tlx_comments">// CCCOMP
         // Cases that go to &quot;fetch 1&quot; after &quot;exe&quot;.
         </span><span class="tlx_logic">$valid_exe_inst = $instr_valid &amp;&amp; !($valid_mem_instr || $valid_br_taken);
         
      </span><span class="tlx_comments">// MAR/MDR
      </span><span class="tlx_staging">@5
         </span><span class="tlx_logic">$mar[15:0] =
            $valid_mem_instr          ? $rslt :             </span><span class="tlx_comments">// ld/st
            </span><span class="tlx_structure">/top|fetch</span><span class="tlx_logic">&lt;&lt;4$instr_valid ? </span><span class="tlx_structure">/top|fetch</span><span class="tlx_logic">&lt;&lt;4$pc :  </span><span class="tlx_comments">// instruction load
                                        </span><span class="tlx_logic">$RETAIN;
         </span><span class="tlx_comments">// Note: MDR as spec'ed holds both ld and store data, which gets in the way for
         //       a pipelined design, so I just let load data stage separately.
         </span><span class="tlx_logic">$mdr[15:0] =
            $valid_st     ? $rslt :     </span><span class="tlx_comments">// st
                            </span><span class="tlx_logic">$RETAIN;
      </span><span class="tlx_comments">// Memory
      </span><span class="tlx_staging">@6
         </span><span class="tlx_logic">$fetch = </span><span class="tlx_structure">/top|fetch</span><span class="tlx_logic">&lt;&lt;4$instr_valid;
         </span><span class="tlx_comments">// Just return random data for now, 2 cycles later.
         </span><span class="tlx_logic">$mem_rdata[15:0] = *RW_rand_vect[(0 + (0)) % 257 +: 16];
         $mem_op = $valid_mem_instr || $fetch;
         $mem_resp = &gt;&gt;2$mem_op;
   
   </span><span class="tlx_comments">// Handle response from memory, whether fetch, ld, or st.
   </span><span class="tlx_structure">|resp
      </span><span class="tlx_staging">@1
         </span><span class="tlx_logic">$reset = *reset;
      </span><span class="tlx_staging">@2
         </span><span class="tlx_comments">// Remember the purpose of the memory operation: fetch, load, or store.
         </span><span class="tlx_logic">{&lt;&lt;1$FetchPending,
          &lt;&lt;1$LoadPending,
          $next_store_pending} =
            $reset || $mem_resp        ? 3'b000 :
            </span><span class="tlx_structure">/top|fetch</span><span class="tlx_logic">&lt;&gt;0$instr_valid  ? 3'b100 :
            </span><span class="tlx_structure">/top|exe</span><span class="tlx_logic">&gt;&gt;4$valid_ld       ? 3'b010 :
            </span><span class="tlx_structure">/top|exe</span><span class="tlx_logic">&gt;&gt;5$valid_st       ? 3'b001 :
                                         {$FetchPending, $LoadPending, $StorePending};  </span><span class="tlx_comments">// $RETAIN
         </span><span class="tlx_logic">&lt;&lt;1$StorePending = $next_store_pending;
         
      </span><span class="tlx_comments">// This pipeline is fed from memory response.
      </span><span class="tlx_staging">@2
         </span><span class="tlx_logic">$mem_resp = </span><span class="tlx_structure">/top|exe</span><span class="tlx_logic">&gt;&gt;4$mem_resp;
         $mem_rdata[15:0] = </span><span class="tlx_structure">/top|exe</span><span class="tlx_logic">&gt;&gt;4$mem_rdata;
         
      </span><span class="tlx_comments">// Characterize response.
      </span><span class="tlx_staging">@3
         </span><span class="tlx_logic">$ld_resp_valid    = $mem_resp &amp;&amp; $LoadPending;
         </span><span class="tlx_comments">//$st_resp_valid    = $mem_resp &amp;&amp; $StorePending;
         </span><span class="tlx_logic">$fetch_resp_valid = $mem_resp &amp;&amp; $FetchPending;
         
   
   </span><span class="tlx_comments">// ---------
   // Testbench
   // ---------
   
   // Just run for fixed number of cycles
   </span><span class="tlx_logic">$reset = *reset;
   $Cnt[15:0] &lt;= $reset ? 16'b0 :
                               $Cnt + 16'b1;
   *passed = $Cnt &gt; 16'd100;

</span><span class="tlx_structure">\SV
</span><span class="tlx_untouched">endmodule




</span><span class="tlx_comments">// -------------
// ALU

</span><span class="tlx_untouched">module alu
(
    input mips_aluop aluop,
    input mips_word a, b,
    output mips_word f
);

always_comb
begin
    case (aluop)
        alu_add: f = a + b;
        alu_and: f = a &amp; b;
        alu_not: f = ~a;
        default: f = f;
    endcase
end

endmodule : alu



</span><span class="tlx_comments">// ---------------
// Register File

</span><span class="tlx_untouched">module regfile
(
    input clk,
    input load,
    input mips_word in,
    input mips_reg src_a, src_b, dest,
    output mips_word reg_a, reg_b
);

mips_word data [7:0];

initial
begin
    for (int i = 0; i &lt; $size(data); i++)
    begin
        data[i] = 16'b0;
    end
end

always_ff @(posedge clk)
begin
    if (load == 1)
    begin
        data[dest] = in;
    end
end

always_comb
begin
    reg_a = data[src_a];
    reg_b = data[src_b];
end

endmodule : regfile
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV

// ------------------------
// SystemVerilog data types

</span><span class="tlx_untouched">typedef logic [15:0] mips_word;
typedef logic  [7:0] mips_byte;
typedef logic  [2:0] mips_reg;


typedef enum bit [3:0] {
    op_add  = 4'b0001,
    op_and  = 4'b0101,
    op_br   = 4'b0000,
    op_jmp  = 4'b1100,   </span><span class="tlx_comments">/* also RET */
    </span><span class="tlx_untouched">op_jsr  = 4'b0100,   </span><span class="tlx_comments">/* also JSRR */
    </span><span class="tlx_untouched">op_ldb  = 4'b0010,
    op_ldi  = 4'b1010,
    op_lea  = 4'b1110,
    op_not  = 4'b1001,
    op_ldr  = 4'b0110,
    op_rti  = 4'b1000,
    op_shf  = 4'b1101,
    op_stb  = 4'b0011,
    op_sti  = 4'b1011,
    op_str  = 4'b0111,
    op_trap = 4'b1111
} mips_opcode;

typedef enum bit [3:0] {
    alu_add,
    alu_and,
    alu_not
} mips_aluop;






module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   /*
   
   // Fetch pipe fetches an insruction.
   |fetch
      @1   // &quot;fetch1&quot;
      @2   // &quot;fetch2&quot;
   // A pipeline for execution, beginning from fetch response from memory.
   |exe
      @2   // &quot;fetch2&quot;
      @3   // &quot;fetch3&quot;
      @4   // &quot;decode&quot;
      @5   // exe (&quot;add&quot;, &quot;and&quot;, &quot;not&quot;, &quot;calc_addr&quot;, &quot;br&quot;)
      @6   // &quot;ld1/st1&quot;, &quot;br_taken&quot;, or next &quot;fetch 1&quot;
      @7   // &quot;st2&quot;, next &quot;fetch 1&quot; after &quot;br_taken&quot;
   // Pipeline for memory response for fetch/load/store.
   // Stages align with those of the instruction fetch response.
   |resp
      @2   // &quot;ld1/st2&quot;
      @3   // &quot;ld2&quot;, IR, next &quot;fetch1&quot; for store
      @4   // next &quot;fetch1&quot; for load
   */
   
   // Fetch next instruction
   //_|fetch
      // Next PC
      //_@0
         </span><span class="tlx_logic">assign FETCH_reset_a0 = reset;
         
         assign FETCH_valid_br_taken_a0 = EXE_valid_br_taken_a6;
         assign FETCH_pc_a0[15:0] =
            FETCH_reset_a0 ? 16'b0 :
            (FETCH_valid_br_taken_a0 &amp;&amp; FETCH_instr_valid_a1)
               ? </span><span class="tlx_comments">// Add to PC (increment or branch).
                 </span><span class="tlx_logic">FETCH_pc_a1 +
                    (FETCH_instr_valid_a1
                       ? </span><span class="tlx_comments">// increment
                         </span><span class="tlx_logic">16'd2
                       : </span><span class="tlx_comments">// branch
                         </span><span class="tlx_logic">{{7{EXE_offset9_a6[8]}},  </span><span class="tlx_comments">// sign ext
                          </span><span class="tlx_logic">EXE_offset9_a6})         </span><span class="tlx_comments">// branch target
               </span><span class="tlx_logic">: FETCH_pc_a1[15:0];
               
      </span><span class="tlx_comments">// Next instruction
      //_@1
         </span><span class="tlx_logic">assign FETCH_instr_valid_a1 =
            </span><span class="tlx_comments">// first instruction
            </span><span class="tlx_logic">(FETCH_reset_a2 &amp;&amp; ! FETCH_reset_a1) ||
            </span><span class="tlx_comments">// store
            </span><span class="tlx_logic">(RESP_mem_resp_a3 &amp;&amp; RESP_StorePending_a3) ||  </span><span class="tlx_comments">// /top|resp&gt;&gt;2$st_resp_valid, but better timing.
            // load
            </span><span class="tlx_logic">RESP_ld_resp_valid_a4 ||
            </span><span class="tlx_comments">// else (alu, branch not-taken)
            </span><span class="tlx_logic">EXE_valid_exe_inst_a6;
   
   </span><span class="tlx_comments">// Execute the instruction that was fetched.
   //_|exe
      //@2
      //   $reset = *reset;
         
      //_@3
         </span><span class="tlx_logic">assign EXE_instr_valid_a3      = RESP_fetch_resp_valid_a3;    
         assign EXE_ir_a3[15:0] = EXE_instr_valid_a3 ? RESP_mem_rdata_a3 :
                                    EXE_ir_a4[15:0];
      
      </span><span class="tlx_comments">// Decode
      //_@4
         // Condition on valid instruction if pipelined implementation.
         //_?$instr_valid
            // Instruction fields:
            </span><span class="tlx_logic">assign EXE_opcode_a4[3:0]  = EXE_ir_a4[15:12];
            assign EXE_dest_a4[2:0]    = EXE_ir_a4[11:9];
            assign EXE_src1_a4[2:0]    = EXE_ir_a4[8:6];
            assign EXE_src2_a4[2:0]    = EXE_ir_a4[2:0];
            assign EXE_offset6_a4[5:0] = EXE_ir_a4[5:0];
            assign EXE_offset9_a4[8:0] = EXE_ir_a4[8:0];
         
            </span><span class="tlx_comments">// Opcode Decode:
            </span><span class="tlx_logic">always_comb begin
               casez(EXE_opcode_a4)
                  op_add:  EXE_aluop_a4[3:0] = alu_add;
                  op_and:  EXE_aluop_a4 = alu_and;
                  op_not:  EXE_aluop_a4 = alu_not;
                  default: EXE_aluop_a4 = 'x;
               endcase </span><span class="tlx_structure">end
            </span><span class="tlx_logic">assign EXE_br_a4 = EXE_opcode_a4 == op_br;
         assign EXE_valid_ld_a4 = EXE_instr_valid_a4 &amp;&amp; EXE_opcode_a4 == op_ldr;
         assign EXE_valid_st_a4 = EXE_instr_valid_a4 &amp;&amp; EXE_opcode_a4 == op_str;
         assign EXE_valid_mem_instr_a4 = EXE_valid_ld_a4 || EXE_valid_st_a4;
            
      </span><span class="tlx_comments">// Regfile
      //_@4
         </span><span class="tlx_logic">regfile rf(.clk(clk),
                    .load(RESP_ld_resp_valid_a3),
                    .in((EXE_instr_valid_a4 &amp;&amp; ! EXE_valid_mem_instr_a4)
                              ? EXE_rslt_a5 :
                                RESP_mem_rdata_a3),
                    .src_a(EXE_src1_a4),
                    .src_b(EXE_src2_a4),
                    .dest(EXE_dest_a4),
                    .reg_a(EXE_reg_a_a4[15:0]),
                    .reg_b(EXE_reg_b_a4[15:0]));

      </span><span class="tlx_comments">// ALU
      //_@5
         </span><span class="tlx_logic">assign EXE_adj_offset6_a5[15:0] = {{10{EXE_offset6_a5[5]}}, EXE_offset6_a5};
         alu alu(.aluop(EXE_aluop_a5),
                 .a(EXE_reg_a_a5),
                 .b(EXE_valid_mem_instr_a5 ? EXE_adj_offset6_a5 : EXE_reg_b_a5),
                 .f(EXE_rslt_a5[15:0]));

      </span><span class="tlx_comments">// Branch target
      //_@5
         </span><span class="tlx_logic">assign EXE_cc_a5[2:0] = {EXE_rslt_a5[15], EXE_rslt_a5 == 16'b0, | EXE_rslt_a5[14:0]};
      </span><span class="tlx_comments">//_@6
         </span><span class="tlx_logic">assign EXE_valid_br_taken_a6 = EXE_instr_valid_a6 &amp;&amp; EXE_br_a6 &amp;&amp;
                           EXE_cc_a6 == EXE_dest_a6;  </span><span class="tlx_comments">// CCCOMP
         // Cases that go to &quot;fetch 1&quot; after &quot;exe&quot;.
         </span><span class="tlx_logic">assign EXE_valid_exe_inst_a6 = EXE_instr_valid_a6 &amp;&amp; !(EXE_valid_mem_instr_a6 || EXE_valid_br_taken_a6);
         
      </span><span class="tlx_comments">// MAR/MDR
      //_@5
         </span><span class="tlx_logic">assign EXE_mar_a5[15:0] =
            EXE_valid_mem_instr_a5          ? EXE_rslt_a5 :             </span><span class="tlx_comments">// ld/st
            </span><span class="tlx_logic">FETCH_instr_valid_a1 ? FETCH_pc_a1 :  </span><span class="tlx_comments">// instruction load
                                        </span><span class="tlx_logic">EXE_mar_a6[15:0];
         </span><span class="tlx_comments">// Note: MDR as spec'ed holds both ld and store data, which gets in the way for
         //       a pipelined design, so I just let load data stage separately.
         </span><span class="tlx_logic">assign EXE_mdr_a5[15:0] =
            EXE_valid_st_a5     ? EXE_rslt_a5 :     </span><span class="tlx_comments">// st
                            </span><span class="tlx_logic">EXE_mdr_a6[15:0];
      </span><span class="tlx_comments">// Memory
      //_@6
         </span><span class="tlx_logic">assign EXE_fetch_a6 = FETCH_instr_valid_a2;
         </span><span class="tlx_comments">// Just return random data for now, 2 cycles later.
         </span><span class="tlx_logic">assign EXE_mem_rdata_a6[15:0] = RW_rand_vect[(0 + (0)) % 257 +: 16];
         assign EXE_mem_op_a6 = EXE_valid_mem_instr_a6 || EXE_fetch_a6;
         assign EXE_mem_resp_a6 = EXE_mem_op_a8;
   
   </span><span class="tlx_comments">// Handle response from memory, whether fetch, ld, or st.
   //_|resp
      //_@1
         </span><span class="tlx_logic">assign RESP_reset_a1 = reset;
      </span><span class="tlx_comments">//_@2
         // Remember the purpose of the memory operation: fetch, load, or store.
         </span><span class="tlx_logic">assign {RESP_FetchPending_a1,
          RESP_LoadPending_a1,
          RESP_next_store_pending_a2} =
            RESP_reset_a2 || RESP_mem_resp_a2        ? 3'b000 :
            FETCH_instr_valid_a2  ? 3'b100 :
            EXE_valid_ld_a6       ? 3'b010 :
            EXE_valid_st_a7       ? 3'b001 :
                                         {RESP_FetchPending_a2, RESP_LoadPending_a2, RESP_StorePending_a2};  </span><span class="tlx_comments">// $RETAIN
         </span><span class="tlx_logic">assign RESP_StorePending_a1 = RESP_next_store_pending_a2;
         
      </span><span class="tlx_comments">// This pipeline is fed from memory response.
      //_@2
         </span><span class="tlx_logic">assign RESP_mem_resp_a2 = EXE_mem_resp_a6;
         assign RESP_mem_rdata_a2[15:0] = EXE_mem_rdata_a6;
         
      </span><span class="tlx_comments">// Characterize response.
      //_@3
         </span><span class="tlx_logic">assign RESP_ld_resp_valid_a3    = RESP_mem_resp_a3 &amp;&amp; RESP_LoadPending_a3;
         </span><span class="tlx_comments">//$st_resp_valid    = $mem_resp &amp;&amp; $StorePending;
         </span><span class="tlx_logic">assign RESP_fetch_resp_valid_a3 = RESP_mem_resp_a3 &amp;&amp; RESP_FetchPending_a3;
         
   
   </span><span class="tlx_comments">// ---------
   // Testbench
   // ---------
   
   // Just run for fixed number of cycles
   </span><span class="tlx_logic">assign L0_reset_a0 = reset;
   assign L0_Cnt_n1[15:0] = L0_reset_a0 ? 16'b0 :
                               L0_Cnt_a0 + 16'b1;
   assign passed = L0_Cnt_a0 &gt; 16'd100; </span><span class="tlx_structure">endgenerate

</span><span class="tlx_comments">//_\SV
</span><span class="tlx_untouched">endmodule




</span><span class="tlx_comments">// -------------
// ALU

</span><span class="tlx_untouched">module alu
(
    input mips_aluop aluop,
    input mips_word a, b,
    output mips_word f
);

always_comb
begin
    case (aluop)
        alu_add: f = a + b;
        alu_and: f = a &amp; b;
        alu_not: f = ~a;
        default: f = f;
    endcase
end

endmodule : alu



</span><span class="tlx_comments">// ---------------
// Register File

</span><span class="tlx_untouched">module regfile
(
    input clk,
    input load,
    input mips_word in,
    input mips_reg src_a, src_b, dest,
    output mips_word reg_a, reg_b
);

mips_word data [7:0];

initial
begin
    for (int i = 0; i &lt; $size(data); i++)
    begin
        data[i] = 16'b0;
    end
end

always_ff @(posedge clk)
begin
    if (load == 1)
    begin
        data[dest] = in;
    end
end

always_comb
begin
    reg_a = data[src_a];
    reg_b = data[src_b];
end

endmodule : regfile
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

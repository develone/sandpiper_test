<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 432, 3283, 0, 30, 574, 76, 0, 0, 'opacity: 0.1', 9015, 'opacity: 0.1', 4529, 'opacity: 0.1'],
      ['top.sv', 0, 432, 8770, 303, 0, 283, 0, 0, 0, 'opacity: 0.1', 9353, 'opacity: 0.1', 4703, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 3691, 5393, 308, 0, 965, 5338, 'opacity: 0.1', 3611, 'opacity: 0.1', 6350, 'opacity: 0.1'],
      ['SV Total', 0, 432, 8770, 3994, 5393, 591, 0, 965, 5338, 'opacity: 0.1', 12964, 'opacity: 0.1', 11053, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar mem, regs, src;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0;

</span><span class="tlx_comments">// For |fetch/instr$Pc.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_Pc_n1,
             FETCH_Instr_Pc_a0,
             FETCH_Instr_Pc_a1,
             FETCH_Instr_Pc_a2,
             FETCH_Instr_Pc_a3,
             FETCH_Instr_Pc_a4,
             FETCH_Instr_Pc_a5;

</span><span class="tlx_comments">// For |fetch/instr$SquashCnt.
</span><span class="tlx_declarations">logic [2:0] FETCH_Instr_SquashCnt_a1,
            FETCH_Instr_SquashCnt_a2;

</span><span class="tlx_comments">// For |fetch/instr$addr.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_addr_a2;
logic [4:0] FETCH_Instr_addr_a3;

</span><span class="tlx_comments">// For |fetch/instr$branch.
</span><span class="tlx_declarations">logic FETCH_Instr_branch_a1,
      FETCH_Instr_branch_a2,
      FETCH_Instr_branch_a3;

</span><span class="tlx_comments">// For |fetch/instr$branch_target.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_branch_target_a3;

</span><span class="tlx_comments">// For |fetch/instr$compare_rslt.
</span><span class="tlx_declarations">logic FETCH_Instr_compare_rslt_a2;

</span><span class="tlx_comments">// For |fetch/instr$conditional_branch.
</span><span class="tlx_declarations">logic FETCH_Instr_conditional_branch_a1,
      FETCH_Instr_conditional_branch_a2;

</span><span class="tlx_comments">// For |fetch/instr$dest_char.
</span><span class="tlx_declarations">logic [7:0] FETCH_Instr_dest_char_a1;

</span><span class="tlx_comments">// For |fetch/instr$dest_is_reg.
</span><span class="tlx_declarations">logic FETCH_Instr_dest_is_reg_a1,
      FETCH_Instr_dest_is_reg_a2,
      FETCH_Instr_dest_is_reg_a3;

</span><span class="tlx_comments">// For |fetch/instr$dest_reg.
</span><span class="tlx_declarations">logic [2:0] FETCH_Instr_dest_reg_a1,
            FETCH_Instr_dest_reg_a2,
            FETCH_Instr_dest_reg_a3,
            FETCH_Instr_dest_reg_a4,
            FETCH_Instr_dest_reg_a5;

</span><span class="tlx_comments">// For |fetch/instr$dest_tmp.
</span><span class="tlx_declarations">logic [7:0] FETCH_Instr_dest_tmp_a1;

</span><span class="tlx_comments">// For |fetch/instr$dest_valid.
</span><span class="tlx_declarations">logic FETCH_Instr_dest_valid_a1,
      FETCH_Instr_dest_valid_a2;

</span><span class="tlx_comments">// For |fetch/instr$illegal.
</span><span class="tlx_declarations">logic FETCH_Instr_illegal_a1,
      FETCH_Instr_illegal_a2;

</span><span class="tlx_comments">// For |fetch/instr$illegal_dest.
</span><span class="tlx_declarations">logic FETCH_Instr_illegal_dest_a1;

</span><span class="tlx_comments">// For |fetch/instr$jump.
</span><span class="tlx_declarations">logic FETCH_Instr_jump_a1,
      FETCH_Instr_jump_a2;

</span><span class="tlx_comments">// For |fetch/instr$jump_target.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_jump_target_a2;

</span><span class="tlx_comments">// For |fetch/instr$ld.
</span><span class="tlx_declarations">logic FETCH_Instr_ld_a1,
      FETCH_Instr_ld_a2,
      FETCH_Instr_ld_a3,
      FETCH_Instr_ld_a4,
      FETCH_Instr_ld_a5;

</span><span class="tlx_comments">// For |fetch/instr$ld_rslt.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_ld_rslt_a3,
             FETCH_Instr_ld_rslt_a4,
             FETCH_Instr_ld_rslt_a5,
             FETCH_Instr_ld_rslt_a6;

</span><span class="tlx_comments">// For |fetch/instr$mispred_branch.
</span><span class="tlx_declarations">logic FETCH_Instr_mispred_branch_a2;

</span><span class="tlx_comments">// For |fetch/instr$no_dest.
</span><span class="tlx_declarations">logic FETCH_Instr_no_dest_a1;

</span><span class="tlx_comments">// For |fetch/instr$op_char.
</span><span class="tlx_declarations">logic [7:0] FETCH_Instr_op_char_a1;

</span><span class="tlx_comments">// For |fetch/instr$op_compare.
</span><span class="tlx_declarations">logic FETCH_Instr_op_compare_a1,
      FETCH_Instr_op_compare_a2;

</span><span class="tlx_comments">// For |fetch/instr$op_full.
</span><span class="tlx_declarations">logic FETCH_Instr_op_full_a1,
      FETCH_Instr_op_full_a2;

</span><span class="tlx_comments">// For |fetch/instr$op_full_rslt.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_op_full_rslt_a2;

</span><span class="tlx_comments">// For |fetch/instr$raw.
</span><span class="tlx_declarations">logic [39:0] FETCH_Instr_raw_a0,
             FETCH_Instr_raw_a1 </span><span class="tlx_comments">/* covering: [23:0] &amp; [39:32] */</span><span class="tlx_declarations">;

</span><span class="tlx_comments">// For |fetch/instr$reg_write.
</span><span class="tlx_declarations">logic FETCH_Instr_reg_write_a3;

</span><span class="tlx_comments">// For |fetch/instr$replay.
</span><span class="tlx_declarations">logic FETCH_Instr_replay_a1,
      FETCH_Instr_replay_a2;

</span><span class="tlx_comments">// For |fetch/instr$reset.
</span><span class="tlx_declarations">logic FETCH_Instr_reset_a0,
      FETCH_Instr_reset_a1,
      FETCH_Instr_reset_a2,
      FETCH_Instr_reset_a3;

</span><span class="tlx_comments">// For |fetch/instr$returning_ld.
</span><span class="tlx_declarations">logic FETCH_Instr_returning_ld_a0,
      FETCH_Instr_returning_ld_a1,
      FETCH_Instr_returning_ld_a2,
      FETCH_Instr_returning_ld_a3;

</span><span class="tlx_comments">// For |fetch/instr$returning_ld_reg.
</span><span class="tlx_declarations">logic [2:0] FETCH_Instr_returning_ld_reg_a1;

</span><span class="tlx_comments">// For |fetch/instr$rslt.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_rslt_a2,
             FETCH_Instr_rslt_a3;

</span><span class="tlx_comments">// For |fetch/instr$squash.
</span><span class="tlx_declarations">logic FETCH_Instr_squash_a2,
      FETCH_Instr_squash_a3;

</span><span class="tlx_comments">// For |fetch/instr$st.
</span><span class="tlx_declarations">logic FETCH_Instr_st_a1,
      FETCH_Instr_st_a2;

</span><span class="tlx_comments">// For |fetch/instr$valid_illegal.
</span><span class="tlx_declarations">logic FETCH_Instr_valid_illegal_a2,
      FETCH_Instr_valid_illegal_a3,
      FETCH_Instr_valid_illegal_a4,
      FETCH_Instr_valid_illegal_a5,
      FETCH_Instr_valid_illegal_a6;

</span><span class="tlx_comments">// For |fetch/instr$valid_jump.
</span><span class="tlx_declarations">logic FETCH_Instr_valid_jump_a2;

</span><span class="tlx_comments">// For |fetch/instr$valid_ld.
</span><span class="tlx_declarations">logic FETCH_Instr_valid_ld_a2,
      FETCH_Instr_valid_ld_a3,
      FETCH_Instr_valid_ld_a4;

</span><span class="tlx_comments">// For |fetch/instr$valid_mispred_branch.
</span><span class="tlx_declarations">logic FETCH_Instr_valid_mispred_branch_a2,
      FETCH_Instr_valid_mispred_branch_a3;

</span><span class="tlx_comments">// For |fetch/instr$valid_st.
</span><span class="tlx_declarations">logic FETCH_Instr_valid_st_a2,
      FETCH_Instr_valid_st_a3;

</span><span class="tlx_comments">// For |fetch/instr$write_pc.
</span><span class="tlx_declarations">logic FETCH_Instr_write_pc_a1;

</span><span class="tlx_comments">// For |fetch/instr/mem$Word.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_Mem_Word_a2 [31:0],
             FETCH_Instr_Mem_Word_a3 [31:0];

</span><span class="tlx_comments">// For |fetch/instr/op$add.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_add_a1,
      FETCH_Instr_Op_add_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$and.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_and_a1,
      FETCH_Instr_Op_and_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$arith.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_arith_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$bitwise.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_bitwise_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$char.
</span><span class="tlx_declarations">logic [7:0] FETCH_Instr_Op_char_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$combine.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_combine_a1,
      FETCH_Instr_Op_combine_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$compare.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_compare_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$conditional.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_conditional_a1,
      FETCH_Instr_Op_conditional_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$div.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_div_a1,
      FETCH_Instr_Op_div_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$eq.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_eq_a1,
      FETCH_Instr_Op_eq_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$full.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_full_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$ge.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_ge_a1,
      FETCH_Instr_Op_ge_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$gt.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_gt_a1,
      FETCH_Instr_Op_gt_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$illegal.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_illegal_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$ld.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_ld_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$le.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_le_a1,
      FETCH_Instr_Op_le_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$lt.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_lt_a1,
      FETCH_Instr_Op_lt_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$mem.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_mem_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$mul.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_mul_a1,
      FETCH_Instr_Op_mul_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$ne.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_ne_a1,
      FETCH_Instr_Op_ne_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$or.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_or_a1,
      FETCH_Instr_Op_or_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$st.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_st_a1;

</span><span class="tlx_comments">// For |fetch/instr/op$sub.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_sub_a1,
      FETCH_Instr_Op_sub_a2;

</span><span class="tlx_comments">// For |fetch/instr/op$wide_imm.
</span><span class="tlx_declarations">logic FETCH_Instr_Op_wide_imm_a1,
      FETCH_Instr_Op_wide_imm_a2;

</span><span class="tlx_comments">// For |fetch/instr/regs$Value.
</span><span class="tlx_declarations">logic [11:0] FETCH_Instr_Regs_Value_a2 [7:0],
             FETCH_Instr_Regs_Value_a3 [7:0];

</span><span class="tlx_comments">// For |fetch/instr/regs$next_pending.
</span><span class="tlx_declarations">logic FETCH_Instr_Regs_next_pending_a2 [7:0],
      FETCH_Instr_Regs_next_pending_a3 [7:0];

</span><span class="tlx_comments">// For |fetch/instr/src$illegal.
</span><span class="tlx_declarations">logic [2:1] FETCH_Instr_Src_illegal_a1;

</span><span class="tlx_comments">// For |fetch/instr/src$replay.
</span><span class="tlx_declarations">logic [2:1] FETCH_Instr_Src_replay_a1;

</span><span class="tlx_comments">
//
// Scope: |fetch
//

//
// Scope: |fetch/instr
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_FETCH_Instr_dest_valid_a3 ;
logic clkP_FETCH_Instr_ld_a3 ;
logic clkP_FETCH_Instr_ld_a4 ;
logic clkP_FETCH_Instr_ld_a5 ;
logic clkP_FETCH_Instr_ld_a6 ;

</span><span class="tlx_comments">//
// Scope: |fetch/instr/src[2:1]
//

// Clock signals.
</span><span class="tlx_gating">logic clkP_FETCH_Instr_Src_valid_a2 [2:1];
logic clkP_FETCH_Instr_Src_valid_a3 [2:1];

</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">

   //
   // Scope: |fetch
   //


      //
      // Scope: /instr
      //

         // For $Pc.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Pc_a0[11:0] &lt;= FETCH_Instr_Pc_n1[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a1[11:0] &lt;= FETCH_Instr_Pc_a0[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a2[11:0] &lt;= FETCH_Instr_Pc_a1[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a3[11:0] &lt;= FETCH_Instr_Pc_a2[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a4[11:0] &lt;= FETCH_Instr_Pc_a3[11:0];
         always_ff @(posedge clk) FETCH_Instr_Pc_a5[11:0] &lt;= FETCH_Instr_Pc_a4[11:0];

         </span><span class="tlx_comments">// For $SquashCnt.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_SquashCnt_a2[2:0] &lt;= FETCH_Instr_SquashCnt_a1[2:0];

         </span><span class="tlx_comments">// For $addr.
         </span><span class="tlx_staging">always_ff @(posedge clkP_FETCH_Instr_ld_a3) FETCH_Instr_addr_a3[4:0] &lt;= FETCH_Instr_addr_a2[4:0];

         </span><span class="tlx_comments">// For $branch.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_branch_a2 &lt;= FETCH_Instr_branch_a1;
         always_ff @(posedge clk) FETCH_Instr_branch_a3 &lt;= FETCH_Instr_branch_a2;

         </span><span class="tlx_comments">// For $conditional_branch.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_conditional_branch_a2 &lt;= FETCH_Instr_conditional_branch_a1;

         </span><span class="tlx_comments">// For $dest_is_reg.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_dest_is_reg_a2 &lt;= FETCH_Instr_dest_is_reg_a1;
         always_ff @(posedge clk) FETCH_Instr_dest_is_reg_a3 &lt;= FETCH_Instr_dest_is_reg_a2;

         </span><span class="tlx_comments">// For $dest_reg.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_dest_reg_a2[2:0] &lt;= FETCH_Instr_dest_reg_a1[2:0];
         always_ff @(posedge clk) FETCH_Instr_dest_reg_a3[2:0] &lt;= FETCH_Instr_dest_reg_a2[2:0];
         always_ff @(posedge clk) FETCH_Instr_dest_reg_a4[2:0] &lt;= FETCH_Instr_dest_reg_a3[2:0];
         always_ff @(posedge clk) FETCH_Instr_dest_reg_a5[2:0] &lt;= FETCH_Instr_dest_reg_a4[2:0];

         </span><span class="tlx_comments">// For $dest_valid.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_dest_valid_a2 &lt;= FETCH_Instr_dest_valid_a1;

         </span><span class="tlx_comments">// For $illegal.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_illegal_a2 &lt;= FETCH_Instr_illegal_a1;

         </span><span class="tlx_comments">// For $jump.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_jump_a2 &lt;= FETCH_Instr_jump_a1;

         </span><span class="tlx_comments">// For $ld.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_ld_a2 &lt;= FETCH_Instr_ld_a1;
         always_ff @(posedge clk) FETCH_Instr_ld_a3 &lt;= FETCH_Instr_ld_a2;
         always_ff @(posedge clk) FETCH_Instr_ld_a4 &lt;= FETCH_Instr_ld_a3;
         always_ff @(posedge clk) FETCH_Instr_ld_a5 &lt;= FETCH_Instr_ld_a4;

         </span><span class="tlx_comments">// For $ld_rslt.
         </span><span class="tlx_staging">always_ff @(posedge clkP_FETCH_Instr_ld_a4) FETCH_Instr_ld_rslt_a4[11:0] &lt;= FETCH_Instr_ld_rslt_a3[11:0];
         always_ff @(posedge clkP_FETCH_Instr_ld_a5) FETCH_Instr_ld_rslt_a5[11:0] &lt;= FETCH_Instr_ld_rslt_a4[11:0];
         always_ff @(posedge clkP_FETCH_Instr_ld_a6) FETCH_Instr_ld_rslt_a6[11:0] &lt;= FETCH_Instr_ld_rslt_a5[11:0];

         </span><span class="tlx_comments">// For $op_compare.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_op_compare_a2 &lt;= FETCH_Instr_op_compare_a1;

         </span><span class="tlx_comments">// For $op_full.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_op_full_a2 &lt;= FETCH_Instr_op_full_a1;

         </span><span class="tlx_comments">// For $raw.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_raw_a1[23:0] &lt;= FETCH_Instr_raw_a0[23:0];
         always_ff @(posedge clk) FETCH_Instr_raw_a1[39:32] &lt;= FETCH_Instr_raw_a0[39:32];

         </span><span class="tlx_comments">// For $replay.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_replay_a2 &lt;= FETCH_Instr_replay_a1;

         </span><span class="tlx_comments">// For $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_reset_a1 &lt;= FETCH_Instr_reset_a0;
         always_ff @(posedge clk) FETCH_Instr_reset_a2 &lt;= FETCH_Instr_reset_a1;
         always_ff @(posedge clk) FETCH_Instr_reset_a3 &lt;= FETCH_Instr_reset_a2;

         </span><span class="tlx_comments">// For $returning_ld.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_returning_ld_a1 &lt;= FETCH_Instr_returning_ld_a0;
         always_ff @(posedge clk) FETCH_Instr_returning_ld_a2 &lt;= FETCH_Instr_returning_ld_a1;
         always_ff @(posedge clk) FETCH_Instr_returning_ld_a3 &lt;= FETCH_Instr_returning_ld_a2;

         </span><span class="tlx_comments">// For $rslt.
         </span><span class="tlx_staging">always_ff @(posedge clkP_FETCH_Instr_dest_valid_a3) FETCH_Instr_rslt_a3[11:0] &lt;= FETCH_Instr_rslt_a2[11:0];

         </span><span class="tlx_comments">// For $squash.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_squash_a3 &lt;= FETCH_Instr_squash_a2;

         </span><span class="tlx_comments">// For $st.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_st_a2 &lt;= FETCH_Instr_st_a1;

         </span><span class="tlx_comments">// For $valid_illegal.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_valid_illegal_a3 &lt;= FETCH_Instr_valid_illegal_a2;
         always_ff @(posedge clk) FETCH_Instr_valid_illegal_a4 &lt;= FETCH_Instr_valid_illegal_a3;
         always_ff @(posedge clk) FETCH_Instr_valid_illegal_a5 &lt;= FETCH_Instr_valid_illegal_a4;
         always_ff @(posedge clk) FETCH_Instr_valid_illegal_a6 &lt;= FETCH_Instr_valid_illegal_a5;

         </span><span class="tlx_comments">// For $valid_ld.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_valid_ld_a3 &lt;= FETCH_Instr_valid_ld_a2;
         always_ff @(posedge clk) FETCH_Instr_valid_ld_a4 &lt;= FETCH_Instr_valid_ld_a3;

         </span><span class="tlx_comments">// For $valid_mispred_branch.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_valid_mispred_branch_a3 &lt;= FETCH_Instr_valid_mispred_branch_a2;

         </span><span class="tlx_comments">// For $valid_st.
         </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_valid_st_a3 &lt;= FETCH_Instr_valid_st_a2;


         </span><span class="tlx_comments">//
         // Scope: /mem[31:0]
         //
         </span><span class="tlx_structure">for (mem = 0; mem &lt;= 31; mem++) begin : L1gen_FETCH_Instr_Mem
</span><span class="tlx_comments">            // For $Word.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Mem_Word_a3[mem][11:0] &lt;= FETCH_Instr_Mem_Word_a2[mem][11:0];

         </span><span class="tlx_structure">end

         </span><span class="tlx_comments">//
         // Scope: /op
         //

            // For $add.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_add_a2 &lt;= FETCH_Instr_Op_add_a1;

            </span><span class="tlx_comments">// For $and.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_and_a2 &lt;= FETCH_Instr_Op_and_a1;

            </span><span class="tlx_comments">// For $combine.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_combine_a2 &lt;= FETCH_Instr_Op_combine_a1;

            </span><span class="tlx_comments">// For $conditional.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_conditional_a2 &lt;= FETCH_Instr_Op_conditional_a1;

            </span><span class="tlx_comments">// For $div.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_div_a2 &lt;= FETCH_Instr_Op_div_a1;

            </span><span class="tlx_comments">// For $eq.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_eq_a2 &lt;= FETCH_Instr_Op_eq_a1;

            </span><span class="tlx_comments">// For $ge.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_ge_a2 &lt;= FETCH_Instr_Op_ge_a1;

            </span><span class="tlx_comments">// For $gt.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_gt_a2 &lt;= FETCH_Instr_Op_gt_a1;

            </span><span class="tlx_comments">// For $le.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_le_a2 &lt;= FETCH_Instr_Op_le_a1;

            </span><span class="tlx_comments">// For $lt.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_lt_a2 &lt;= FETCH_Instr_Op_lt_a1;

            </span><span class="tlx_comments">// For $mul.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_mul_a2 &lt;= FETCH_Instr_Op_mul_a1;

            </span><span class="tlx_comments">// For $ne.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_ne_a2 &lt;= FETCH_Instr_Op_ne_a1;

            </span><span class="tlx_comments">// For $or.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_or_a2 &lt;= FETCH_Instr_Op_or_a1;

            </span><span class="tlx_comments">// For $sub.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_sub_a2 &lt;= FETCH_Instr_Op_sub_a1;

            </span><span class="tlx_comments">// For $wide_imm.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Op_wide_imm_a2 &lt;= FETCH_Instr_Op_wide_imm_a1;



         </span><span class="tlx_comments">//
         // Scope: /regs[7:0]
         //
         </span><span class="tlx_structure">for (regs = 0; regs &lt;= 7; regs++) begin : L1gen_FETCH_Instr_Regs
</span><span class="tlx_comments">            // For $Value.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Regs_Value_a3[regs][11:0] &lt;= FETCH_Instr_Regs_Value_a2[regs][11:0];

            </span><span class="tlx_comments">// For $next_pending.
            </span><span class="tlx_staging">always_ff @(posedge clk) FETCH_Instr_Regs_next_pending_a3[regs] &lt;= FETCH_Instr_Regs_next_pending_a2[regs];

         </span><span class="tlx_structure">end

         </span><span class="tlx_comments">//
         // Scope: /src[2:1]
         //
         </span><span class="tlx_structure">for (src = 1; src &lt;= 2; src++) begin : L1gen_FETCH_Instr_Src
</span><span class="tlx_comments">            // For $valid.
            </span><span class="tlx_staging">always_ff @(posedge clk) L1c_FETCH_Instr_Src[src].L1_valid_a2 &lt;= L1c_FETCH_Instr_Src[src].L1_valid_a1;

            </span><span class="tlx_comments">// For $value.
            </span><span class="tlx_staging">always_ff @(posedge clkP_FETCH_Instr_Src_valid_a2[src]) L1c_FETCH_Instr_Src[src].L1_value_a2[11:0] &lt;= L1c_FETCH_Instr_Src[src].L1_value_a1[11:0];
            always_ff @(posedge clkP_FETCH_Instr_Src_valid_a3[src]) L1c_FETCH_Instr_Src[src].L1_value_a3[11:0] &lt;= L1c_FETCH_Instr_Src[src].L1_value_a2[11:0];

         </span><span class="tlx_structure">end




endgenerate



</span><span class="tlx_comments">//
// Gated clocks.
//

</span><span class="tlx_structure">generate

</span><span class="tlx_comments">

   //
   // Scope: |fetch
   //


      //
      // Scope: /instr
      //

</span><span class="tlx_gating">         clk_gate gen_clkP_FETCH_Instr_dest_valid_a3(clkP_FETCH_Instr_dest_valid_a3, clk, 1'b1, FETCH_Instr_dest_valid_a2, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_ld_a3(clkP_FETCH_Instr_ld_a3, clk, 1'b1, FETCH_Instr_ld_a2, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_ld_a4(clkP_FETCH_Instr_ld_a4, clk, 1'b1, FETCH_Instr_ld_a3, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_ld_a5(clkP_FETCH_Instr_ld_a5, clk, 1'b1, FETCH_Instr_ld_a4, 1'b0);
         clk_gate gen_clkP_FETCH_Instr_ld_a6(clkP_FETCH_Instr_ld_a6, clk, 1'b1, FETCH_Instr_ld_a5, 1'b0);

         </span><span class="tlx_comments">//
         // Scope: /src[2:1]
         //
         </span><span class="tlx_structure">for (src = 1; src &lt;= 2; src++) begin : L1clk_FETCH_Instr_Src
</span><span class="tlx_gating">            clk_gate gen_clkP_FETCH_Instr_Src_valid_a2(clkP_FETCH_Instr_Src_valid_a2[src], clk, 1'b1, L1c_FETCH_Instr_Src[src].L1_valid_a1, 1'b0);
            clk_gate gen_clkP_FETCH_Instr_Src_valid_a3(clkP_FETCH_Instr_Src_valid_a3[src], clk, 1'b1, L1c_FETCH_Instr_Src[src].L1_valid_a2, 1'b0);
         </span><span class="tlx_structure">end




endgenerate



</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      </span><span class="tlx_comments">//
      // Scope: |fetch
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|fetch 
</span><span class="tlx_comments">
         //
         // Scope: /instr
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/instr 
            logic [11:0] \@-1$Pc ;
            assign \@-1$Pc = FETCH_Instr_Pc_n1;
            logic [2:0] \@1$SquashCnt ;
            assign \@1$SquashCnt = FETCH_Instr_SquashCnt_a1;
            logic [11:0] \@2$addr ;
            assign \@2$addr = FETCH_Instr_addr_a2;
            logic  \@1$branch ;
            assign \@1$branch = FETCH_Instr_branch_a1;
            logic [11:0] \@3$branch_target ;
            assign \@3$branch_target = FETCH_Instr_branch_target_a3;
            logic  \@2$compare_rslt ;
            assign \@2$compare_rslt = FETCH_Instr_compare_rslt_a2;
            logic  \@1$conditional_branch ;
            assign \@1$conditional_branch = FETCH_Instr_conditional_branch_a1;
            logic [7:0] \@1$dest_char ;
            assign \@1$dest_char = FETCH_Instr_dest_char_a1;
            logic  \@1$dest_is_reg ;
            assign \@1$dest_is_reg = FETCH_Instr_dest_is_reg_a1;
            logic [2:0] \@1$dest_reg ;
            assign \@1$dest_reg = FETCH_Instr_dest_reg_a1;
            logic [7:0] \@1$dest_tmp ;
            assign \@1$dest_tmp = FETCH_Instr_dest_tmp_a1;
            logic  \@1$dest_valid ;
            assign \@1$dest_valid = FETCH_Instr_dest_valid_a1;
            logic  \@1$illegal ;
            assign \@1$illegal = FETCH_Instr_illegal_a1;
            logic  \@1$illegal_dest ;
            assign \@1$illegal_dest = FETCH_Instr_illegal_dest_a1;
            logic  \@1$jump ;
            assign \@1$jump = FETCH_Instr_jump_a1;
            logic [11:0] \@2$jump_target ;
            assign \@2$jump_target = FETCH_Instr_jump_target_a2;
            logic  \@1$ld ;
            assign \@1$ld = FETCH_Instr_ld_a1;
            logic [11:0] \@3$ld_rslt ;
            assign \@3$ld_rslt = FETCH_Instr_ld_rslt_a3;
            logic  \@2$mispred_branch ;
            assign \@2$mispred_branch = FETCH_Instr_mispred_branch_a2;
            logic  \@1$no_dest ;
            assign \@1$no_dest = FETCH_Instr_no_dest_a1;
            logic [7:0] \@1$op_char ;
            assign \@1$op_char = FETCH_Instr_op_char_a1;
            logic  \@1$op_compare ;
            assign \@1$op_compare = FETCH_Instr_op_compare_a1;
            logic  \@1$op_full ;
            assign \@1$op_full = FETCH_Instr_op_full_a1;
            logic [11:0] \@2$op_full_rslt ;
            assign \@2$op_full_rslt = FETCH_Instr_op_full_rslt_a2;
            logic [39:0] \@0$raw ;
            assign \@0$raw = FETCH_Instr_raw_a0;
            logic  \@3$reg_write ;
            assign \@3$reg_write = FETCH_Instr_reg_write_a3;
            logic  \@1$replay ;
            assign \@1$replay = FETCH_Instr_replay_a1;
            logic  \@0$reset ;
            assign \@0$reset = FETCH_Instr_reset_a0;
            logic  \@0$returning_ld ;
            assign \@0$returning_ld = FETCH_Instr_returning_ld_a0;
            logic [2:0] \@1$returning_ld_reg ;
            assign \@1$returning_ld_reg = FETCH_Instr_returning_ld_reg_a1;
            logic [11:0] \@2$rslt ;
            assign \@2$rslt = FETCH_Instr_rslt_a2;
            logic  \@2$squash ;
            assign \@2$squash = FETCH_Instr_squash_a2;
            logic  \@1$st ;
            assign \@1$st = FETCH_Instr_st_a1;
            logic  \@2$valid_illegal ;
            assign \@2$valid_illegal = FETCH_Instr_valid_illegal_a2;
            logic  \@2$valid_jump ;
            assign \@2$valid_jump = FETCH_Instr_valid_jump_a2;
            logic  \@2$valid_ld ;
            assign \@2$valid_ld = FETCH_Instr_valid_ld_a2;
            logic  \@2$valid_mispred_branch ;
            assign \@2$valid_mispred_branch = FETCH_Instr_valid_mispred_branch_a2;
            logic  \@2$valid_st ;
            assign \@2$valid_st = FETCH_Instr_valid_st_a2;
            logic  \@1$write_pc ;
            assign \@1$write_pc = FETCH_Instr_write_pc_a1;

            </span><span class="tlx_comments">//
            // Scope: /mem[31:0]
            //
            </span><span class="tlx_instrumentation">for (mem = 0; mem &lt;= 31; mem++) begin : \/mem 
               logic [11:0] \@2$Word ;
               assign \@2$Word = FETCH_Instr_Mem_Word_a2[mem];
            end

            </span><span class="tlx_comments">//
            // Scope: /op
            //
            </span><span class="tlx_instrumentation">if (1) begin : \/op 
               logic  \@1$add ;
               assign \@1$add = FETCH_Instr_Op_add_a1;
               logic  \@1$and ;
               assign \@1$and = FETCH_Instr_Op_and_a1;
               logic  \@1$arith ;
               assign \@1$arith = FETCH_Instr_Op_arith_a1;
               logic  \@1$bitwise ;
               assign \@1$bitwise = FETCH_Instr_Op_bitwise_a1;
               logic [7:0] \@1$char ;
               assign \@1$char = FETCH_Instr_Op_char_a1;
               logic  \@1$combine ;
               assign \@1$combine = FETCH_Instr_Op_combine_a1;
               logic  \@1$compare ;
               assign \@1$compare = FETCH_Instr_Op_compare_a1;
               logic  \@1$conditional ;
               assign \@1$conditional = FETCH_Instr_Op_conditional_a1;
               logic  \@1$div ;
               assign \@1$div = FETCH_Instr_Op_div_a1;
               logic  \@1$eq ;
               assign \@1$eq = FETCH_Instr_Op_eq_a1;
               logic  \@1$full ;
               assign \@1$full = FETCH_Instr_Op_full_a1;
               logic  \@1$ge ;
               assign \@1$ge = FETCH_Instr_Op_ge_a1;
               logic  \@1$gt ;
               assign \@1$gt = FETCH_Instr_Op_gt_a1;
               logic  \@1$illegal ;
               assign \@1$illegal = FETCH_Instr_Op_illegal_a1;
               logic  \@1$ld ;
               assign \@1$ld = FETCH_Instr_Op_ld_a1;
               logic  \@1$le ;
               assign \@1$le = FETCH_Instr_Op_le_a1;
               logic  \@1$lt ;
               assign \@1$lt = FETCH_Instr_Op_lt_a1;
               logic  \@1$mem ;
               assign \@1$mem = FETCH_Instr_Op_mem_a1;
               logic  \@1$mul ;
               assign \@1$mul = FETCH_Instr_Op_mul_a1;
               logic  \@1$ne ;
               assign \@1$ne = FETCH_Instr_Op_ne_a1;
               logic  \@1$or ;
               assign \@1$or = FETCH_Instr_Op_or_a1;
               logic  \@1$st ;
               assign \@1$st = FETCH_Instr_Op_st_a1;
               logic  \@1$sub ;
               assign \@1$sub = FETCH_Instr_Op_sub_a1;
               logic  \@1$wide_imm ;
               assign \@1$wide_imm = FETCH_Instr_Op_wide_imm_a1;
            end

            </span><span class="tlx_comments">//
            // Scope: /regs[7:0]
            //
            </span><span class="tlx_instrumentation">for (regs = 0; regs &lt;= 7; regs++) begin : \/regs 
               logic [11:0] \@2$Value ;
               assign \@2$Value = FETCH_Instr_Regs_Value_a2[regs];
               logic  \@2$next_pending ;
               assign \@2$next_pending = FETCH_Instr_Regs_next_pending_a2[regs];
               logic  \@2$reg_match ;
               assign \@2$reg_match = L1b_FETCH_Instr_Regs[regs].L1_reg_match_a2;
            end

            </span><span class="tlx_comments">//
            // Scope: /src[2:1]
            //
            </span><span class="tlx_instrumentation">for (src = 1; src &lt;= 2; src++) begin : \/src 
               logic [7:0] \@1$char ;
               assign \@1$char = L1_FETCH_Instr_Src[src].L1_char_a1;
               logic  \@1$illegal ;
               assign \@1$illegal = FETCH_Instr_Src_illegal_a1[src];
               logic [7:0] \@1$imm_tmp ;
               assign \@1$imm_tmp = L1b_FETCH_Instr_Src[src].L1_imm_tmp_a1;
               logic [2:0] \@1$imm_value ;
               assign \@1$imm_value = L1b_FETCH_Instr_Src[src].L1_imm_value_a1;
               logic  \@1$is_imm ;
               assign \@1$is_imm = L1b_FETCH_Instr_Src[src].L1_is_imm_a1;
               logic  \@1$is_reg ;
               assign \@1$is_reg = L1b_FETCH_Instr_Src[src].L1_is_reg_a1;
               logic  \@1$is_reg_condition ;
               assign \@1$is_reg_condition = L1c_FETCH_Instr_Src[src].L1_is_reg_condition_a1;
               logic [2:0] \@1$reg ;
               assign \@1$reg = L1b_FETCH_Instr_Src[src].L1_reg_a1;
               logic [7:0] \@1$reg_tmp ;
               assign \@1$reg_tmp = L1b_FETCH_Instr_Src[src].L1_reg_tmp_a1;
               logic [11:0] \@1$reg_value ;
               assign \@1$reg_value = L1c_FETCH_Instr_Src[src].L1_reg_value_a1;
               logic  \@1$replay ;
               assign \@1$replay = FETCH_Instr_Src_replay_a1[src];
               logic  \@1$valid ;
               assign \@1$valid = L1c_FETCH_Instr_Src[src].L1_valid_a1;
               logic [11:0] \@1$value ;
               assign \@1$value = L1c_FETCH_Instr_Src[src].L1_value_a1;
            end
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
</span><span class="tlx_comments">// -----------------------------------------------------------------------------
// Copyright (c) 2017, Redwood EDA
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Redwood EDA nor the names of its contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------


// A dirt-simple CPU for educational purposes.



// The ISA:

// What's interesting about this ISA?
//   o It's super small.
//   o It's easy to play with and learn from.
//   o Instructions are short, kind-of-readable strings, so no assembler is needed.
//     They would map directly to a denser (~17-bit) encoding if desired.
//   o The only instruction formats are op, load, and store.
//   o Branch/Jump: There is no special format for control-flow instructions. Any
//     instruction can write the PC (relative or absolute). A conditional branch
//     will typically utilize a condition operation that provides a (relative) branch
//     target or zero.
//
// Branch prediction ISA considerations:
//   Typical branch predication techniques can be utilized for conditional branches
//   with an immediate offset (eg p=4?c), though the immediate is VERY limited
//   (small, positive). The immediate could also be used to predicate off subsequent
//   instructions. By convention, b is a branch target register, so it is
//   reasonable to predict the target of &quot;p=b?c&quot;, using a stale side copy of b.
//
// ISA Machine Arch:
//   o Single stage &quot;pipeline&quot;.
//   o 8 registers.
//   o A word is 12 bits wide.
//   o Operators operate on and produce words as signed or unsigned values and
//     booleans (all-zero/one)
//
//
// Instruction Set:
//
// Instructions are 5-character strings: &quot;D=1o2&quot;
//
// =: Appears in every instruction (just for readability).
// D, 2, 1: &quot;a&quot; - &quot;h&quot; for registers;
//          &quot;0&quot; - &quot;7&quot; for immediate constants (sources, or &quot;0&quot; for unused dest);
//          &quot;P&quot; for absolute dest PC (jump);
//          &quot;p&quot; for relative dest PC (branch), PC = PC + 1 + result(signed).
//
// o: operator
//   Op: (D = 1 o 2) (Eg: &quot;c=a+b&quot;):
//     Arithmetic:
//       +, -, *, /: *, / are unsigned.
//     Compare: (D = (1 o 2) ? all-1s : 0)
//       =, !, &lt;, &gt;, [, ]: ] is &gt;=, [ is &lt;=
//          (On booleans these are XNOR, XOR, !1&amp;2, 1&amp;!2, !1|2, 1|!2)
//     Bitwise:
//       &amp;, |: (Can be used on booleans as well as vectors.)
//     (There are no operators for NAND and NOR and unary !.)
//     Concatination:
//       ~: Extended constant (D = {1[2:0], 2[2:0]})
//       ,: Combine (D = {1[5:0], 2[5:0]})
//     Conditional:
//       ?: (D = 2 ? `0 : 1)
//   Load (Eg: &quot;c=a{b&quot;):
//     {: Load (D = [1 + 2] (typically 1 would be an immediate offset)
//   Store (Eg: &quot;0=a}b&quot;):
//     }: Store ([2] = D = 1) (typically D would be &quot;0&quot; (no dest))
//
// A full-width immediate load sequence, to load octal 2017 is:
//   a=2~0
//   b=1~7
//   a=a,b

// A typical local conditional branch sequence is:
//   a=0-6  // offset
//   c=c-1  // decrementing loop counter
//   p=a?c  // branch by a (to PC+1-6) if c is non-negative (MSB==0)



// The CPU

// The code is parameterized, using the M4 macro preprocessor, for adjustable pipeline
// depth.
//
// Overview:
//   o One instruction traverses the single free-flowing CPU pipeline per cycle.
//   o There is no branch or condition or target prediction.
//   o Instructions are in-order, but the uarch supports loads that return their
//     data out of order (though, they don't).
//
// Replays:
//
// The PC is redirected, and inflight instructions are squashed (their results are
// not committed) for:
//   o jumps (go to jump target)
//   o unconditioned and non-negative-conditioned branches (go to branch target)
//   o instructions that consume a pending register (replay instruction immediately)
//     (See &quot;Loads&quot;, below.)
//   o loads that write to a pending register (replay instruction immediately)
//     (See &quot;Loads&quot;, below.)
//
// Loads:
//
// Load destination registers are marked &quot;pending&quot;, and reads of pending
// registers are replayed. (This could again result in a read of the same
// pending register, to repeat until the load returns.) Writes to pending registers
// are also replayed, so there can be at most one oustanding load to any given
// register. This way, out-of-order loads are supported (though loads are implemented
// to have a fixed latency). A returning load reserves a slot at the beginning
// of the pipeline to reserve a register write port. The returning load writes its
// result and clears the destination register's pending flag.
//
// To support L1 and L2 caches, it would be reasonable to delay register write (if
// necessary) to wait for L1 hits (extending the bypass window), and mark &quot;pending&quot;
// for L1 misses.
//
// Bypass:
//
// Register bypass is provided if one instruction's result is not written to the
// register file in time for the next instruction's read. An additional bypass is
// provided for each additional cycle between read and write.



// /============\
// | Parameters |
// \============/

// Adjust the parameters below to define the pipeline depth and staging.

// Pipeline stages for each piece of logic:









// Feedback latencies:

  // +1 or +0. +0 aligns PC_MUX with EXECUTE
  // +0 aligns PC_MUX with BRANCH_TARGET_CALC. Must be either equal to or one greater than JUMP_LATENCY.
   // From load to returning load


// Machine parameters:
  // (Must match program exactly.)



</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
/* verilator lint_on WIDTH */  // Let's be strict about bit widths.
   </span><span class="tlx_untouched">logic [39:0] instrs [0:13-1];


   </span><span class="tlx_comments">// /=============\
   // | The Program |
   // \=============/

   // Add 1,2,3,...,10 (in that order).
   // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
   //
   // Regs:
   // b: cnt
   // c: ten
   // d: out
   // e: tmp
   // f: offset
   // g: store addr

   </span><span class="tlx_untouched">assign instrs = '{
      &quot;g=0~0&quot;, </span><span class="tlx_comments">//     store_addr = 0
      </span><span class="tlx_untouched">&quot;b=0~1&quot;, </span><span class="tlx_comments">//     cnt = 1
      </span><span class="tlx_untouched">&quot;c=1~2&quot;, </span><span class="tlx_comments">//     ten = 10
      </span><span class="tlx_untouched">&quot;d=0~0&quot;, </span><span class="tlx_comments">//     out = 0
      </span><span class="tlx_untouched">&quot;f=0-6&quot;, </span><span class="tlx_comments">//     offset = -6
      </span><span class="tlx_untouched">&quot;d=d+b&quot;, </span><span class="tlx_comments">//  -&gt; out += cnt
      </span><span class="tlx_untouched">&quot;0=d}g&quot;, </span><span class="tlx_comments">//     store out at store_addr
      </span><span class="tlx_untouched">&quot;b=b+1&quot;, </span><span class="tlx_comments">//     cnt ++
      </span><span class="tlx_untouched">&quot;g=g+1&quot;, </span><span class="tlx_comments">//     store_addr++
      </span><span class="tlx_untouched">&quot;e=c-b&quot;, </span><span class="tlx_comments">//     tmp = 10 - cnt
      </span><span class="tlx_untouched">&quot;p=f?e&quot;, </span><span class="tlx_comments">//  ^- branch back if tmp &gt;= 0
      </span><span class="tlx_untouched">&quot;h=0{c&quot;, </span><span class="tlx_comments">//     load the final value
      </span><span class="tlx_untouched">&quot;P=0-1&quot;  </span><span class="tlx_comments">//     TERMINATE by jumping to -1
   </span><span class="tlx_untouched">};


</span><span class="tlx_structure">\TLV
   
   </span><span class="tlx_comments">// /=========\
   // | The CPU |
   // \=========/
   
   </span><span class="tlx_logic">$reset = *reset;

   </span><span class="tlx_structure">|fetch
      /instr
         </span><span class="tlx_staging">@0
            </span><span class="tlx_logic">$reset = </span><span class="tlx_structure">/top</span><span class="tlx_logic">&lt;&gt;0$reset;

         </span><span class="tlx_staging">@0
            </span><span class="tlx_comments">//?$fetch  // We'll need this once there are invalid cycles.

            // =====
            // Fetch
            // =====

            </span><span class="tlx_logic">$raw[39:0] = *instrs\[$Pc[3:0]\];
            
         </span><span class="tlx_comments">// A returning load clobbers the instruction.
         </span><span class="tlx_staging">@0
            </span><span class="tlx_logic">$returning_ld = &gt;&gt;4$valid_ld;
         </span><span class="tlx_staging">@1
            </span><span class="tlx_logic">$returning_ld_reg[2:0] = &gt;&gt;4$dest_reg;
         
         </span><span class="tlx_staging">@0
            </span><span class="tlx_comments">// =======
            // Next PC
            // =======
            
            //?$fetch_or_reset
            </span><span class="tlx_logic">$Pc[11:0] &lt;=
               $reset ? 0 :
               &gt;&gt;3$valid_mispred_branch ? &gt;&gt;3$branch_target :
               &gt;&gt;2$valid_jump ? &gt;&gt;2$jump_target :
               &gt;&gt;2$replay ? &gt;&gt;2$Pc :
               $returning_ld ? $RETAIN :  </span><span class="tlx_comments">// Returning load, so next PC is the previous next PC (unless there was a branch that wasn't visible yet)
                        </span><span class="tlx_logic">$Pc + 12'b1;

         </span><span class="tlx_staging">@1

            </span><span class="tlx_comments">// ======
            // DECODE
            // ======

            // Characters
            </span><span class="tlx_logic">$dest_char[7:0] = $raw[39:32];
            </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">:</span><span class="tlx_logic">1</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$char[7:0] = (#src == 1) ? </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$raw[23:16] : </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$raw[7:0];
            $op_char[7:0] = $raw[15:8];

            </span><span class="tlx_comments">// Dest
            </span><span class="tlx_logic">$dest_is_reg = ($dest_char &gt;= &quot;a&quot; &amp;&amp; $dest_char &lt;= &quot;h&quot;) || $returning_ld;
            $dest_tmp[7:0] = $dest_char - &quot;a&quot;;
            $dest_reg[2:0] = $returning_ld ? $returning_ld_reg : $dest_tmp[2:0];
            $jump = $dest_char == &quot;P&quot;;
            $branch = $dest_char == &quot;p&quot;;
            $no_dest = $dest_char == &quot;0&quot;;
            $write_pc = $jump || $branch;
            $dest_valid = $write_pc || $dest_is_reg;
            $illegal_dest = !($dest_is_reg || 
                              (($branch || $jump || $no_dest) &amp;&amp; ! $ld));  </span><span class="tlx_comments">// Load must have reg dest.

            </span><span class="tlx_structure">/src[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
               </span><span class="tlx_comments">// Src1
               </span><span class="tlx_logic">$is_reg = $char &gt;= &quot;a&quot; &amp;&amp; $char &lt;= &quot;h&quot;;
               $reg_tmp[7:0] = $char - &quot;a&quot;;
               $reg[2:0] = $reg_tmp[2:0];
               $is_imm = $char &gt;= &quot;0&quot; &amp;&amp; $char &lt; &quot;8&quot;;
               $imm_tmp[7:0] = $char - &quot;0&quot;;
               $imm_value[2:0] = $imm_tmp[2:0];
               $illegal = !($is_reg || $is_imm);

            </span><span class="tlx_comments">// Opcode:
            </span><span class="tlx_structure">/op
               </span><span class="tlx_logic">$char[7:0] = </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$op_char;
               </span><span class="tlx_comments">// Arithmetic
               </span><span class="tlx_logic">$add = $char == &quot;+&quot;;
               $sub = $char == &quot;-&quot;;
               $mul = $char == &quot;*&quot;;
               $div = $char == &quot;/&quot;;
               </span><span class="tlx_comments">// Compare and bool (w/ 1 bit rslt)
               </span><span class="tlx_logic">$eq = $char == &quot;=&quot;;
               $ne = $char == &quot;!&quot;;
               $lt = $char == &quot;&lt;&quot;;
               $gt = $char == &quot;&gt;&quot;;
               $le = $char == &quot;[&quot;;
               $ge = $char == &quot;]&quot;;
               $and = $char == &quot;&amp;&quot;;
               $or = $char == &quot;|&quot;;
               </span><span class="tlx_comments">// Wide Immediate
               </span><span class="tlx_logic">$wide_imm = $char == &quot;~&quot;;
               $combine = $char == &quot;,&quot;;
               </span><span class="tlx_comments">// Conditional
               </span><span class="tlx_logic">$conditional = $char == &quot;?&quot;;
               </span><span class="tlx_comments">// Memory
               </span><span class="tlx_logic">$ld = $char == &quot;{&quot;;
               $st = $char == &quot;}&quot;;
               </span><span class="tlx_comments">// Opcode classes:
               </span><span class="tlx_logic">$arith = $add || $sub || $mul || $div;
               $compare = $eq || $ne || $lt || $gt || $le || $ge;
               $bitwise = $and || $or;
               $full = $arith || $bitwise || $wide_imm || $combine || $conditional;
               </span><span class="tlx_comments">//$op3 = $compare || $full;
               </span><span class="tlx_logic">$mem = $ld || $st;
               $illegal = !($compare || $full || $mem);
            $op_compare = </span><span class="tlx_structure">/op</span><span class="tlx_logic">$compare;
            $op_full = </span><span class="tlx_structure">/op</span><span class="tlx_logic">$full;
            $ld = </span><span class="tlx_structure">/op</span><span class="tlx_logic">$ld;
            $st = </span><span class="tlx_structure">/op</span><span class="tlx_logic">$st;
            $illegal = $illegal_dest || (| </span><span class="tlx_structure">/src[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$illegal) || </span><span class="tlx_structure">/op</span><span class="tlx_logic">$illegal;
            
            </span><span class="tlx_comments">// Branch instructions with a condition (that might be worth predicting).
            </span><span class="tlx_logic">$conditional_branch = $branch &amp;&amp; </span><span class="tlx_structure">/op</span><span class="tlx_logic">$conditional;
            
         </span><span class="tlx_staging">@1
            </span><span class="tlx_comments">// ======
            // Reg Rd
            // ======
            
            </span><span class="tlx_structure">/regs[</span><span class="tlx_logic">7</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            /src[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$is_reg_condition = $is_reg;
               </span><span class="tlx_validity">?$is_reg_condition
                  </span><span class="tlx_logic">$reg_value[11:0] =
                     </span><span class="tlx_comments">// Bypass stages:
                     </span><span class="tlx_logic">(</span><span class="tlx_structure">/instr</span><span class="tlx_logic">&gt;&gt;1$dest_is_reg &amp;&amp; (</span><span class="tlx_structure">/instr</span><span class="tlx_logic">&gt;&gt;1$dest_reg == $reg)) ? </span><span class="tlx_structure">/instr</span><span class="tlx_logic">&gt;&gt;1$rslt :
                     (</span><span class="tlx_structure">/instr</span><span class="tlx_logic">&gt;&gt;2$dest_is_reg &amp;&amp; (</span><span class="tlx_structure">/instr</span><span class="tlx_logic">&gt;&gt;2$dest_reg == $reg)) ? </span><span class="tlx_structure">/instr</span><span class="tlx_logic">&gt;&gt;2$rslt :
                     
                     </span><span class="tlx_structure">/instr/regs[</span><span class="tlx_logic">$reg</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;2$Value;
               $valid = !$illegal;
               </span><span class="tlx_validity">?$valid
                  </span><span class="tlx_logic">$value[11:0] = $is_reg ? $reg_value :
                                           {9'b0, $imm_value}; </span><span class="tlx_comments">// $is_imm
               </span><span class="tlx_logic">$replay = $is_reg &amp;&amp; </span><span class="tlx_structure">/instr/regs[</span><span class="tlx_logic">$reg</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$next_pending;
            $replay = | </span><span class="tlx_structure">/src[</span><span class="tlx_logic">*</span><span class="tlx_structure">]</span><span class="tlx_logic">$replay || ($dest_is_reg &amp;&amp; </span><span class="tlx_structure">/regs[</span><span class="tlx_logic">$dest_reg</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$next_pending);
            
         </span><span class="tlx_staging">@2
            </span><span class="tlx_comments">// =======
            // Execute
            // =======
            
            </span><span class="tlx_validity">?$op_compare
               </span><span class="tlx_logic">$compare_rslt =
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$eq ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value == </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$ne ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value != </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$lt ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &lt; </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$gt ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &gt; </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$le ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &lt;= </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$ge ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &gt;= </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                           1'b0;
            </span><span class="tlx_validity">?$op_full
               </span><span class="tlx_logic">$op_full_rslt[11:0] =
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$add ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value + </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$sub ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value - </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$mul ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value * </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$div ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value * </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$and ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value &amp; </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$or ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value | </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$wide_imm ? {6'b0, </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[2:0], </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[2:0]} :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$combine ? {</span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[5:0], </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[5:0]} :
                  </span><span class="tlx_structure">/op</span><span class="tlx_logic">$conditional ? (</span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[11] ? 12'b0 : </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value) :
                                    12'b0;
            </span><span class="tlx_validity">?$dest_valid
               </span><span class="tlx_logic">$rslt[11:0] =
                  $returning_ld ? &gt;&gt;4$ld_rslt :
                  $st ? </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value :
                  $op_full ? $op_full_rslt :
                  $op_compare ? {12{$compare_rslt}} :
                  </span><span class="tlx_comments">//$ld ? $ld_rslt :
                        </span><span class="tlx_logic">12'b0;
               
         </span><span class="tlx_staging">@2
            </span><span class="tlx_comments">// =========
            // Target PC
            // =========
            
            // Jump (Dest = &quot;P&quot;) and Branch (Dest = &quot;p&quot;) Targets.
            </span><span class="tlx_validity">?$jump
               </span><span class="tlx_logic">$jump_target[11:0] = $rslt;
            </span><span class="tlx_comments">// Always predict taken; mispredict if jump or unconditioned branch or
            //   conditioned branch with positive condition.
            </span><span class="tlx_logic">$mispred_branch = $branch &amp;&amp; ! ($conditional_branch &amp;&amp; </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[11]);
            $valid_jump = $jump &amp;&amp; ! $squash;
            $valid_mispred_branch = $mispred_branch &amp;&amp; ~$squash;
            $valid_ld = $ld &amp;&amp; ! $squash;
            $valid_st = $st &amp;&amp; ! $squash;
            $valid_illegal = $illegal &amp;&amp; ! $squash;
            </span><span class="tlx_comments">// Squash. Keep a count of the number of cycles remaining in the shadow of a mispredict.
            </span><span class="tlx_logic">$squash = | $SquashCnt || $returning_ld || $replay;
            $SquashCnt[2:0] &lt;=
               $reset                ? 3'b0 :
               $valid_mispred_branch ? 3 :
               $valid_jump           ? 2 :
               $replay               ? 3 - 3'b1:
               $SquashCnt == 3'b0    ? 3'b0 :
                                       $SquashCnt - 3'b1;
         </span><span class="tlx_staging">@3
            </span><span class="tlx_validity">?$branch
               </span><span class="tlx_logic">$branch_target[11:0] = $Pc + 12'b1 + $rslt;
            
            
            </span><span class="tlx_comments">// ====
            // Load
            // ====
            
            </span><span class="tlx_structure">/mem[</span><span class="tlx_logic">31</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         </span><span class="tlx_validity">?$ld
            </span><span class="tlx_staging">@2
               </span><span class="tlx_logic">$addr[11:0] = </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value + </span><span class="tlx_structure">/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value;
            </span><span class="tlx_staging">@3
               </span><span class="tlx_logic">$ld_rslt[11:0] = </span><span class="tlx_structure">/mem[</span><span class="tlx_logic">$addr[4:0]</span><span class="tlx_structure">]</span><span class="tlx_logic">$Word;
         
         </span><span class="tlx_comments">// Array writes are not currently permitted to use assignment
         // syntax, so \always_comb is used, and this must be outside of
         // when conditions, so we need to use if. &lt;&lt;1 because no &lt;= support
         // in this context. (This limitation will be lifted.)

         </span><span class="tlx_staging">@3
            </span><span class="tlx_comments">// =====
            // Store
            // =====

            </span><span class="tlx_structure">\always_comb
               </span><span class="tlx_logic">if ($valid_st)
                  </span><span class="tlx_structure">/mem[/src[</span><span class="tlx_logic">2</span><span class="tlx_structure">]</span><span class="tlx_logic">$value[4:0]</span><span class="tlx_structure">]</span><span class="tlx_logic">&lt;&lt;1$$Word[11:0] = </span><span class="tlx_structure">/src[</span><span class="tlx_logic">1</span><span class="tlx_structure">]</span><span class="tlx_logic">$value;

         </span><span class="tlx_staging">@3
            </span><span class="tlx_comments">// =========
            // Reg Write
            // =========

            </span><span class="tlx_logic">$reg_write = ($dest_is_reg &amp;&amp; ! $squash) || $returning_ld;
            </span><span class="tlx_structure">\always_comb
               </span><span class="tlx_logic">if ($reg_write)
                  </span><span class="tlx_structure">/regs[</span><span class="tlx_logic">$dest_reg</span><span class="tlx_structure">]</span><span class="tlx_logic">&lt;&lt;1$$Value[11:0] = $reset ? 12'h0 : $rslt;
         
         </span><span class="tlx_comments">// There's no bypass on pending, so we must write the same cycle we read.
         </span><span class="tlx_staging">@2
            </span><span class="tlx_structure">/regs[</span><span class="tlx_logic">*</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$reg_match = </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$dest_reg == #regs;
               $next_pending =  </span><span class="tlx_comments">// Should be state, but need to consume prior to flop, which SandPiper doesn't support, yet.
                  </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$reset ? 1'b0 :
                  </span><span class="tlx_comments">// set for loads
                  </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$valid_ld &amp;&amp; $reg_match   ? 1'b1 :
                  </span><span class="tlx_comments">// clear when load returns
                  </span><span class="tlx_structure">/instr</span><span class="tlx_logic">$returning_ld &amp;&amp; $reg_match ? 1'b0 :
                               $RETAIN;

         
   </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">*passed = ! *reset &amp;&amp; </span><span class="tlx_structure">|fetch/instr</span><span class="tlx_logic">&gt;&gt;5$Pc == 12'hfff;
   *failed = ! *reset &amp;&amp; (*cyc_cnt &gt; 1000 || (! </span><span class="tlx_structure">|fetch/instr</span><span class="tlx_logic">&gt;&gt;3$reset &amp;&amp; </span><span class="tlx_structure">|fetch/instr</span><span class="tlx_logic">&gt;&gt;6$valid_illegal));
</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
// -----------------------------------------------------------------------------
// Copyright (c) 2017, Redwood EDA
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Redwood EDA nor the names of its contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------


// A dirt-simple CPU for educational purposes.



// The ISA:

// What's interesting about this ISA?
//   o It's super small.
//   o It's easy to play with and learn from.
//   o Instructions are short, kind-of-readable strings, so no assembler is needed.
//     They would map directly to a denser (~17-bit) encoding if desired.
//   o The only instruction formats are op, load, and store.
//   o Branch/Jump: There is no special format for control-flow instructions. Any
//     instruction can write the PC (relative or absolute). A conditional branch
//     will typically utilize a condition operation that provides a (relative) branch
//     target or zero.
//
// Branch prediction ISA considerations:
//   Typical branch predication techniques can be utilized for conditional branches
//   with an immediate offset (eg p=4?c), though the immediate is VERY limited
//   (small, positive). The immediate could also be used to predicate off subsequent
//   instructions. By convention, b is a branch target register, so it is
//   reasonable to predict the target of &quot;p=b?c&quot;, using a stale side copy of b.
//
// ISA Machine Arch:
//   o Single stage &quot;pipeline&quot;.
//   o 8 registers.
//   o A word is 12 bits wide.
//   o Operators operate on and produce words as signed or unsigned values and
//     booleans (all-zero/one)
//
//
// Instruction Set:
//
// Instructions are 5-character strings: &quot;D=1o2&quot;
//
// =: Appears in every instruction (just for readability).
// D, 2, 1: &quot;a&quot; - &quot;h&quot; for registers;
//          &quot;0&quot; - &quot;7&quot; for immediate constants (sources, or &quot;0&quot; for unused dest);
//          &quot;P&quot; for absolute dest PC (jump);
//          &quot;p&quot; for relative dest PC (branch), PC = PC + 1 + result(signed).
//
// o: operator
//   Op: (D = 1 o 2) (Eg: &quot;c=a+b&quot;):
//     Arithmetic:
//       +, -, *, /: *, / are unsigned.
//     Compare: (D = (1 o 2) ? all-1s : 0)
//       =, !, &lt;, &gt;, [, ]: ] is &gt;=, [ is &lt;=
//          (On booleans these are XNOR, XOR, !1&amp;2, 1&amp;!2, !1|2, 1|!2)
//     Bitwise:
//       &amp;, |: (Can be used on booleans as well as vectors.)
//     (There are no operators for NAND and NOR and unary !.)
//     Concatination:
//       ~: Extended constant (D = {1[2:0], 2[2:0]})
//       ,: Combine (D = {1[5:0], 2[5:0]})
//     Conditional:
//       ?: (D = 2 ? `0 : 1)
//   Load (Eg: &quot;c=a{b&quot;):
//     {: Load (D = [1 + 2] (typically 1 would be an immediate offset)
//   Store (Eg: &quot;0=a}b&quot;):
//     }: Store ([2] = D = 1) (typically D would be &quot;0&quot; (no dest))
//
// A full-width immediate load sequence, to load octal 2017 is:
//   a=2~0
//   b=1~7
//   a=a,b

// A typical local conditional branch sequence is:
//   a=0-6  // offset
//   c=c-1  // decrementing loop counter
//   p=a?c  // branch by a (to PC+1-6) if c is non-negative (MSB==0)



// The CPU

// The code is parameterized, using the M4 macro preprocessor, for adjustable pipeline
// depth.
//
// Overview:
//   o One instruction traverses the single free-flowing CPU pipeline per cycle.
//   o There is no branch or condition or target prediction.
//   o Instructions are in-order, but the uarch supports loads that return their
//     data out of order (though, they don't).
//
// Replays:
//
// The PC is redirected, and inflight instructions are squashed (their results are
// not committed) for:
//   o jumps (go to jump target)
//   o unconditioned and non-negative-conditioned branches (go to branch target)
//   o instructions that consume a pending register (replay instruction immediately)
//     (See &quot;Loads&quot;, below.)
//   o loads that write to a pending register (replay instruction immediately)
//     (See &quot;Loads&quot;, below.)
//
// Loads:
//
// Load destination registers are marked &quot;pending&quot;, and reads of pending
// registers are replayed. (This could again result in a read of the same
// pending register, to repeat until the load returns.) Writes to pending registers
// are also replayed, so there can be at most one oustanding load to any given
// register. This way, out-of-order loads are supported (though loads are implemented
// to have a fixed latency). A returning load reserves a slot at the beginning
// of the pipeline to reserve a register write port. The returning load writes its
// result and clears the destination register's pending flag.
//
// To support L1 and L2 caches, it would be reasonable to delay register write (if
// necessary) to wait for L1 hits (extending the bypass window), and mark &quot;pending&quot;
// for L1 misses.
//
// Bypass:
//
// Register bypass is provided if one instruction's result is not written to the
// register file in time for the next instruction's read. An additional bypass is
// provided for each additional cycle between read and write.



// /============\
// | Parameters |
// \============/

// Adjust the parameters below to define the pipeline depth and staging.

// Pipeline stages for each piece of logic:









// Feedback latencies:

  // +1 or +0. +0 aligns PC_MUX with EXECUTE
  // +0 aligns PC_MUX with BRANCH_TARGET_CALC. Must be either equal to or one greater than JUMP_LATENCY.
   // From load to returning load


// Machine parameters:
  // (Must match program exactly.)



</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
/* verilator lint_on WIDTH */  // Let's be strict about bit widths.
   </span><span class="tlx_untouched">logic [39:0] instrs [0:13-1];


   </span><span class="tlx_comments">// /=============\
   // | The Program |
   // \=============/

   // Add 1,2,3,...,10 (in that order).
   // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
   //
   // Regs:
   // b: cnt
   // c: ten
   // d: out
   // e: tmp
   // f: offset
   // g: store addr

   </span><span class="tlx_untouched">assign instrs = '{
      &quot;g=0~0&quot;, </span><span class="tlx_comments">//     store_addr = 0
      </span><span class="tlx_untouched">&quot;b=0~1&quot;, </span><span class="tlx_comments">//     cnt = 1
      </span><span class="tlx_untouched">&quot;c=1~2&quot;, </span><span class="tlx_comments">//     ten = 10
      </span><span class="tlx_untouched">&quot;d=0~0&quot;, </span><span class="tlx_comments">//     out = 0
      </span><span class="tlx_untouched">&quot;f=0-6&quot;, </span><span class="tlx_comments">//     offset = -6
      </span><span class="tlx_untouched">&quot;d=d+b&quot;, </span><span class="tlx_comments">//  -&gt; out += cnt
      </span><span class="tlx_untouched">&quot;0=d}g&quot;, </span><span class="tlx_comments">//     store out at store_addr
      </span><span class="tlx_untouched">&quot;b=b+1&quot;, </span><span class="tlx_comments">//     cnt ++
      </span><span class="tlx_untouched">&quot;g=g+1&quot;, </span><span class="tlx_comments">//     store_addr++
      </span><span class="tlx_untouched">&quot;e=c-b&quot;, </span><span class="tlx_comments">//     tmp = 10 - cnt
      </span><span class="tlx_untouched">&quot;p=f?e&quot;, </span><span class="tlx_comments">//  ^- branch back if tmp &gt;= 0
      </span><span class="tlx_untouched">&quot;h=0{c&quot;, </span><span class="tlx_comments">//     load the final value
      </span><span class="tlx_untouched">&quot;P=0-1&quot;  </span><span class="tlx_comments">//     TERMINATE by jumping to -1
   </span><span class="tlx_untouched">};


</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   
   // /=========\
   // | The CPU |
   // \=========/
   
   </span><span class="tlx_logic">assign L0_reset_a0 = reset;

   </span><span class="tlx_comments">//_|fetch
      //_/instr
         //_@0
            </span><span class="tlx_logic">assign FETCH_Instr_reset_a0 = L0_reset_a0;

         </span><span class="tlx_comments">//_@0
            //?$fetch  // We'll need this once there are invalid cycles.

            // =====
            // Fetch
            // =====

            </span><span class="tlx_logic">assign FETCH_Instr_raw_a0[39:0] = instrs[FETCH_Instr_Pc_a0[3:0]];
            
         </span><span class="tlx_comments">// A returning load clobbers the instruction.
         //_@0
            </span><span class="tlx_logic">assign FETCH_Instr_returning_ld_a0 = FETCH_Instr_valid_ld_a4;
         </span><span class="tlx_comments">//_@1
            </span><span class="tlx_logic">assign FETCH_Instr_returning_ld_reg_a1[2:0] = FETCH_Instr_dest_reg_a5;
         
         </span><span class="tlx_comments">//_@0
            // =======
            // Next PC
            // =======
            
            //?$fetch_or_reset
            </span><span class="tlx_logic">assign FETCH_Instr_Pc_n1[11:0] =
               FETCH_Instr_reset_a0 ? 0 :
               FETCH_Instr_valid_mispred_branch_a3 ? FETCH_Instr_branch_target_a3 :
               FETCH_Instr_valid_jump_a2 ? FETCH_Instr_jump_target_a2 :
               FETCH_Instr_replay_a2 ? FETCH_Instr_Pc_a2 :
               FETCH_Instr_returning_ld_a0 ? FETCH_Instr_Pc_a0[11:0] :  </span><span class="tlx_comments">// Returning load, so next PC is the previous next PC (unless there was a branch that wasn't visible yet)
                        </span><span class="tlx_logic">FETCH_Instr_Pc_a0 + 12'b1;

         </span><span class="tlx_comments">//_@1

            // ======
            // DECODE
            // ======

            // Characters
            </span><span class="tlx_logic">assign FETCH_Instr_dest_char_a1[7:0] = FETCH_Instr_raw_a1[39:32];
            </span><span class="tlx_structure">for (src = 1; src &lt;= 2; src++) begin : L1_FETCH_Instr_Src </span><span class="tlx_declarations">logic [7:0] L1_char_a1; </span><span class="tlx_comments">//_/src
               </span><span class="tlx_logic">assign L1_char_a1[7:0] = (src == 1) ? FETCH_Instr_raw_a1[23:16] : FETCH_Instr_raw_a1[7:0]; </span><span class="tlx_structure">end
            </span><span class="tlx_logic">assign FETCH_Instr_op_char_a1[7:0] = FETCH_Instr_raw_a1[15:8];

            </span><span class="tlx_comments">// Dest
            </span><span class="tlx_logic">assign FETCH_Instr_dest_is_reg_a1 = (FETCH_Instr_dest_char_a1 &gt;= &quot;a&quot; &amp;&amp; FETCH_Instr_dest_char_a1 &lt;= &quot;h&quot;) || FETCH_Instr_returning_ld_a1;
            assign FETCH_Instr_dest_tmp_a1[7:0] = FETCH_Instr_dest_char_a1 - &quot;a&quot;;
            assign FETCH_Instr_dest_reg_a1[2:0] = FETCH_Instr_returning_ld_a1 ? FETCH_Instr_returning_ld_reg_a1 : FETCH_Instr_dest_tmp_a1[2:0];
            assign FETCH_Instr_jump_a1 = FETCH_Instr_dest_char_a1 == &quot;P&quot;;
            assign FETCH_Instr_branch_a1 = FETCH_Instr_dest_char_a1 == &quot;p&quot;;
            assign FETCH_Instr_no_dest_a1 = FETCH_Instr_dest_char_a1 == &quot;0&quot;;
            assign FETCH_Instr_write_pc_a1 = FETCH_Instr_jump_a1 || FETCH_Instr_branch_a1;
            assign FETCH_Instr_dest_valid_a1 = FETCH_Instr_write_pc_a1 || FETCH_Instr_dest_is_reg_a1;
            assign FETCH_Instr_illegal_dest_a1 = !(FETCH_Instr_dest_is_reg_a1 || 
                              ((FETCH_Instr_branch_a1 || FETCH_Instr_jump_a1 || FETCH_Instr_no_dest_a1) &amp;&amp; ! FETCH_Instr_ld_a1));  </span><span class="tlx_comments">// Load must have reg dest.

            </span><span class="tlx_structure">for (src = 1; src &lt;= 2; src++) begin : L1b_FETCH_Instr_Src </span><span class="tlx_declarations">logic [7:0] L1_imm_tmp_a1; logic [2:0] L1_imm_value_a1; logic L1_is_imm_a1; logic L1_is_reg_a1; logic [2:0] L1_reg_a1; logic [7:0] L1_reg_tmp_a1; </span><span class="tlx_comments">//_/src
               // Src1
               </span><span class="tlx_logic">assign L1_is_reg_a1 = L1_FETCH_Instr_Src[src].L1_char_a1 &gt;= &quot;a&quot; &amp;&amp; L1_FETCH_Instr_Src[src].L1_char_a1 &lt;= &quot;h&quot;;
               assign L1_reg_tmp_a1[7:0] = L1_FETCH_Instr_Src[src].L1_char_a1 - &quot;a&quot;;
               assign L1_reg_a1[2:0] = L1_reg_tmp_a1[2:0];
               assign L1_is_imm_a1 = L1_FETCH_Instr_Src[src].L1_char_a1 &gt;= &quot;0&quot; &amp;&amp; L1_FETCH_Instr_Src[src].L1_char_a1 &lt; &quot;8&quot;;
               assign L1_imm_tmp_a1[7:0] = L1_FETCH_Instr_Src[src].L1_char_a1 - &quot;0&quot;;
               assign L1_imm_value_a1[2:0] = L1_imm_tmp_a1[2:0];
               assign FETCH_Instr_Src_illegal_a1[src] = !(L1_is_reg_a1 || L1_is_imm_a1); </span><span class="tlx_structure">end

            </span><span class="tlx_comments">// Opcode:
            //_/op
               </span><span class="tlx_logic">assign FETCH_Instr_Op_char_a1[7:0] = FETCH_Instr_op_char_a1;
               </span><span class="tlx_comments">// Arithmetic
               </span><span class="tlx_logic">assign FETCH_Instr_Op_add_a1 = FETCH_Instr_Op_char_a1 == &quot;+&quot;;
               assign FETCH_Instr_Op_sub_a1 = FETCH_Instr_Op_char_a1 == &quot;-&quot;;
               assign FETCH_Instr_Op_mul_a1 = FETCH_Instr_Op_char_a1 == &quot;*&quot;;
               assign FETCH_Instr_Op_div_a1 = FETCH_Instr_Op_char_a1 == &quot;/&quot;;
               </span><span class="tlx_comments">// Compare and bool (w/ 1 bit rslt)
               </span><span class="tlx_logic">assign FETCH_Instr_Op_eq_a1 = FETCH_Instr_Op_char_a1 == &quot;=&quot;;
               assign FETCH_Instr_Op_ne_a1 = FETCH_Instr_Op_char_a1 == &quot;!&quot;;
               assign FETCH_Instr_Op_lt_a1 = FETCH_Instr_Op_char_a1 == &quot;&lt;&quot;;
               assign FETCH_Instr_Op_gt_a1 = FETCH_Instr_Op_char_a1 == &quot;&gt;&quot;;
               assign FETCH_Instr_Op_le_a1 = FETCH_Instr_Op_char_a1 == &quot;[&quot;;
               assign FETCH_Instr_Op_ge_a1 = FETCH_Instr_Op_char_a1 == &quot;]&quot;;
               assign FETCH_Instr_Op_and_a1 = FETCH_Instr_Op_char_a1 == &quot;&amp;&quot;;
               assign FETCH_Instr_Op_or_a1 = FETCH_Instr_Op_char_a1 == &quot;|&quot;;
               </span><span class="tlx_comments">// Wide Immediate
               </span><span class="tlx_logic">assign FETCH_Instr_Op_wide_imm_a1 = FETCH_Instr_Op_char_a1 == &quot;~&quot;;
               assign FETCH_Instr_Op_combine_a1 = FETCH_Instr_Op_char_a1 == &quot;,&quot;;
               </span><span class="tlx_comments">// Conditional
               </span><span class="tlx_logic">assign FETCH_Instr_Op_conditional_a1 = FETCH_Instr_Op_char_a1 == &quot;?&quot;;
               </span><span class="tlx_comments">// Memory
               </span><span class="tlx_logic">assign FETCH_Instr_Op_ld_a1 = FETCH_Instr_Op_char_a1 == &quot;{&quot;;
               assign FETCH_Instr_Op_st_a1 = FETCH_Instr_Op_char_a1 == &quot;}&quot;;
               </span><span class="tlx_comments">// Opcode classes:
               </span><span class="tlx_logic">assign FETCH_Instr_Op_arith_a1 = FETCH_Instr_Op_add_a1 || FETCH_Instr_Op_sub_a1 || FETCH_Instr_Op_mul_a1 || FETCH_Instr_Op_div_a1;
               assign FETCH_Instr_Op_compare_a1 = FETCH_Instr_Op_eq_a1 || FETCH_Instr_Op_ne_a1 || FETCH_Instr_Op_lt_a1 || FETCH_Instr_Op_gt_a1 || FETCH_Instr_Op_le_a1 || FETCH_Instr_Op_ge_a1;
               assign FETCH_Instr_Op_bitwise_a1 = FETCH_Instr_Op_and_a1 || FETCH_Instr_Op_or_a1;
               assign FETCH_Instr_Op_full_a1 = FETCH_Instr_Op_arith_a1 || FETCH_Instr_Op_bitwise_a1 || FETCH_Instr_Op_wide_imm_a1 || FETCH_Instr_Op_combine_a1 || FETCH_Instr_Op_conditional_a1;
               </span><span class="tlx_comments">//$op3 = $compare || $full;
               </span><span class="tlx_logic">assign FETCH_Instr_Op_mem_a1 = FETCH_Instr_Op_ld_a1 || FETCH_Instr_Op_st_a1;
               assign FETCH_Instr_Op_illegal_a1 = !(FETCH_Instr_Op_compare_a1 || FETCH_Instr_Op_full_a1 || FETCH_Instr_Op_mem_a1);
            assign FETCH_Instr_op_compare_a1 = FETCH_Instr_Op_compare_a1;
            assign FETCH_Instr_op_full_a1 = FETCH_Instr_Op_full_a1;
            assign FETCH_Instr_ld_a1 = FETCH_Instr_Op_ld_a1;
            assign FETCH_Instr_st_a1 = FETCH_Instr_Op_st_a1;
            assign FETCH_Instr_illegal_a1 = FETCH_Instr_illegal_dest_a1 || (| FETCH_Instr_Src_illegal_a1) || FETCH_Instr_Op_illegal_a1;
            
            </span><span class="tlx_comments">// Branch instructions with a condition (that might be worth predicting).
            </span><span class="tlx_logic">assign FETCH_Instr_conditional_branch_a1 = FETCH_Instr_branch_a1 &amp;&amp; FETCH_Instr_Op_conditional_a1;
            
         </span><span class="tlx_comments">//_@1
            // ======
            // Reg Rd
            // ======
            
            //_/regs
            </span><span class="tlx_structure">for (src = 1; src &lt;= 2; src++) begin : L1c_FETCH_Instr_Src </span><span class="tlx_declarations">logic L1_is_reg_condition_a1; logic [11:0] L1_reg_value_a1; logic L1_valid_a1, L1_valid_a2; logic [11:0] L1_value_a1, L1_value_a2, L1_value_a3; </span><span class="tlx_comments">//_/src
               </span><span class="tlx_logic">assign L1_is_reg_condition_a1 = L1b_FETCH_Instr_Src[src].L1_is_reg_a1;
               </span><span class="tlx_comments">//_?$is_reg_condition
                  </span><span class="tlx_logic">assign L1_reg_value_a1[11:0] =
                     </span><span class="tlx_comments">// Bypass stages:
                     </span><span class="tlx_logic">(FETCH_Instr_dest_is_reg_a2 &amp;&amp; (FETCH_Instr_dest_reg_a2 == L1b_FETCH_Instr_Src[src].L1_reg_a1)) ? FETCH_Instr_rslt_a2 :
                     (FETCH_Instr_dest_is_reg_a3 &amp;&amp; (FETCH_Instr_dest_reg_a3 == L1b_FETCH_Instr_Src[src].L1_reg_a1)) ? FETCH_Instr_rslt_a3 :
                     
                     FETCH_Instr_Regs_Value_a3[L1b_FETCH_Instr_Src[src].L1_reg_a1];
               assign L1_valid_a1 = !FETCH_Instr_Src_illegal_a1[src];
               </span><span class="tlx_comments">//_?$valid
                  </span><span class="tlx_logic">assign L1_value_a1[11:0] = L1b_FETCH_Instr_Src[src].L1_is_reg_a1 ? L1_reg_value_a1 :
                                           {9'b0, L1b_FETCH_Instr_Src[src].L1_imm_value_a1}; </span><span class="tlx_comments">// $is_imm
               </span><span class="tlx_logic">assign FETCH_Instr_Src_replay_a1[src] = L1b_FETCH_Instr_Src[src].L1_is_reg_a1 &amp;&amp; FETCH_Instr_Regs_next_pending_a2[L1b_FETCH_Instr_Src[src].L1_reg_a1]; </span><span class="tlx_structure">end
            </span><span class="tlx_logic">assign FETCH_Instr_replay_a1 = | FETCH_Instr_Src_replay_a1 || (FETCH_Instr_dest_is_reg_a1 &amp;&amp; FETCH_Instr_Regs_next_pending_a2[FETCH_Instr_dest_reg_a1]);
            
         </span><span class="tlx_comments">//_@2
            // =======
            // Execute
            // =======
            
            //_?$op_compare
               </span><span class="tlx_logic">assign FETCH_Instr_compare_rslt_a2 =
                  FETCH_Instr_Op_eq_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 == L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_ne_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 != L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_lt_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 &lt; L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_gt_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 &gt; L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_le_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 &lt;= L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_ge_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 &gt;= L1c_FETCH_Instr_Src[2].L1_value_a2 :
                           1'b0;
            </span><span class="tlx_comments">//_?$op_full
               </span><span class="tlx_logic">assign FETCH_Instr_op_full_rslt_a2[11:0] =
                  FETCH_Instr_Op_add_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 + L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_sub_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 - L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_mul_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 * L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_div_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 * L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_and_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 &amp; L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_or_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 | L1c_FETCH_Instr_Src[2].L1_value_a2 :
                  FETCH_Instr_Op_wide_imm_a2 ? {6'b0, L1c_FETCH_Instr_Src[1].L1_value_a2[2:0], L1c_FETCH_Instr_Src[2].L1_value_a2[2:0]} :
                  FETCH_Instr_Op_combine_a2 ? {L1c_FETCH_Instr_Src[1].L1_value_a2[5:0], L1c_FETCH_Instr_Src[2].L1_value_a2[5:0]} :
                  FETCH_Instr_Op_conditional_a2 ? (L1c_FETCH_Instr_Src[2].L1_value_a2[11] ? 12'b0 : L1c_FETCH_Instr_Src[1].L1_value_a2) :
                                    12'b0;
            </span><span class="tlx_comments">//_?$dest_valid
               </span><span class="tlx_logic">assign FETCH_Instr_rslt_a2[11:0] =
                  FETCH_Instr_returning_ld_a2 ? FETCH_Instr_ld_rslt_a6 :
                  FETCH_Instr_st_a2 ? L1c_FETCH_Instr_Src[1].L1_value_a2 :
                  FETCH_Instr_op_full_a2 ? FETCH_Instr_op_full_rslt_a2 :
                  FETCH_Instr_op_compare_a2 ? {12{FETCH_Instr_compare_rslt_a2}} :
                  </span><span class="tlx_comments">//$ld ? $ld_rslt :
                        </span><span class="tlx_logic">12'b0;
               
         </span><span class="tlx_comments">//_@2
            // =========
            // Target PC
            // =========
            
            // Jump (Dest = &quot;P&quot;) and Branch (Dest = &quot;p&quot;) Targets.
            //_?$jump
               </span><span class="tlx_logic">assign FETCH_Instr_jump_target_a2[11:0] = FETCH_Instr_rslt_a2;
            </span><span class="tlx_comments">// Always predict taken; mispredict if jump or unconditioned branch or
            //   conditioned branch with positive condition.
            </span><span class="tlx_logic">assign FETCH_Instr_mispred_branch_a2 = FETCH_Instr_branch_a2 &amp;&amp; ! (FETCH_Instr_conditional_branch_a2 &amp;&amp; L1c_FETCH_Instr_Src[2].L1_value_a2[11]);
            assign FETCH_Instr_valid_jump_a2 = FETCH_Instr_jump_a2 &amp;&amp; ! FETCH_Instr_squash_a2;
            assign FETCH_Instr_valid_mispred_branch_a2 = FETCH_Instr_mispred_branch_a2 &amp;&amp; ~FETCH_Instr_squash_a2;
            assign FETCH_Instr_valid_ld_a2 = FETCH_Instr_ld_a2 &amp;&amp; ! FETCH_Instr_squash_a2;
            assign FETCH_Instr_valid_st_a2 = FETCH_Instr_st_a2 &amp;&amp; ! FETCH_Instr_squash_a2;
            assign FETCH_Instr_valid_illegal_a2 = FETCH_Instr_illegal_a2 &amp;&amp; ! FETCH_Instr_squash_a2;
            </span><span class="tlx_comments">// Squash. Keep a count of the number of cycles remaining in the shadow of a mispredict.
            </span><span class="tlx_logic">assign FETCH_Instr_squash_a2 = | FETCH_Instr_SquashCnt_a2 || FETCH_Instr_returning_ld_a2 || FETCH_Instr_replay_a2;
            assign FETCH_Instr_SquashCnt_a1[2:0] =
               FETCH_Instr_reset_a2                ? 3'b0 :
               FETCH_Instr_valid_mispred_branch_a2 ? 3 :
               FETCH_Instr_valid_jump_a2           ? 2 :
               FETCH_Instr_replay_a2               ? 3 - 3'b1:
               FETCH_Instr_SquashCnt_a2 == 3'b0    ? 3'b0 :
                                       FETCH_Instr_SquashCnt_a2 - 3'b1;
         </span><span class="tlx_comments">//_@3
            //_?$branch
               </span><span class="tlx_logic">assign FETCH_Instr_branch_target_a3[11:0] = FETCH_Instr_Pc_a3 + 12'b1 + FETCH_Instr_rslt_a3;
            
            
            </span><span class="tlx_comments">// ====
            // Load
            // ====
            
            //_/mem
         //_?$ld
            //_@2
               </span><span class="tlx_logic">assign FETCH_Instr_addr_a2[11:0] = L1c_FETCH_Instr_Src[1].L1_value_a2 + L1c_FETCH_Instr_Src[2].L1_value_a2;
            </span><span class="tlx_comments">//_@3
               </span><span class="tlx_logic">assign FETCH_Instr_ld_rslt_a3[11:0] = FETCH_Instr_Mem_Word_a3[FETCH_Instr_addr_a3[4:0]];
         
         </span><span class="tlx_comments">// Array writes are not currently permitted to use assignment
         // syntax, so \always_comb is used, and this must be outside of
         // when conditions, so we need to use if. &lt;&lt;1 because no &lt;= support
         // in this context. (This limitation will be lifted.)

         //_@3
            // =====
            // Store
            // =====

            </span><span class="tlx_logic">always_comb begin
               if (FETCH_Instr_valid_st_a3)
                  FETCH_Instr_Mem_Word_a2[L1c_FETCH_Instr_Src[2].L1_value_a3[4:0]][11:0] = L1c_FETCH_Instr_Src[1].L1_value_a3; </span><span class="tlx_structure">end

         </span><span class="tlx_comments">//_@3
            // =========
            // Reg Write
            // =========

            </span><span class="tlx_logic">assign FETCH_Instr_reg_write_a3 = (FETCH_Instr_dest_is_reg_a3 &amp;&amp; ! FETCH_Instr_squash_a3) || FETCH_Instr_returning_ld_a3;
            always_comb begin
               if (FETCH_Instr_reg_write_a3)
                  FETCH_Instr_Regs_Value_a2[FETCH_Instr_dest_reg_a3][11:0] = FETCH_Instr_reset_a3 ? 12'h0 : FETCH_Instr_rslt_a3; </span><span class="tlx_structure">end
         
         </span><span class="tlx_comments">// There's no bypass on pending, so we must write the same cycle we read.
         //_@2
            </span><span class="tlx_structure">for (regs = 0; regs &lt;= 7; regs++) begin : L1b_FETCH_Instr_Regs </span><span class="tlx_declarations">logic L1_reg_match_a2; </span><span class="tlx_comments">//_/regs
               </span><span class="tlx_logic">assign L1_reg_match_a2 = FETCH_Instr_dest_reg_a2 == regs;
               assign FETCH_Instr_Regs_next_pending_a2[regs] =  </span><span class="tlx_comments">// Should be state, but need to consume prior to flop, which SandPiper doesn't support, yet.
                  </span><span class="tlx_logic">FETCH_Instr_reset_a2 ? 1'b0 :
                  </span><span class="tlx_comments">// set for loads
                  </span><span class="tlx_logic">FETCH_Instr_valid_ld_a2 &amp;&amp; L1_reg_match_a2   ? 1'b1 :
                  </span><span class="tlx_comments">// clear when load returns
                  </span><span class="tlx_logic">FETCH_Instr_returning_ld_a2 &amp;&amp; L1_reg_match_a2 ? 1'b0 :
                               FETCH_Instr_Regs_next_pending_a3[regs]; </span><span class="tlx_structure">end

         
   </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">assign passed = ! reset &amp;&amp; FETCH_Instr_Pc_a5 == 12'hfff;
   assign failed = ! reset &amp;&amp; (cyc_cnt &gt; 1000 || (! FETCH_Instr_reset_a3 &amp;&amp; FETCH_Instr_valid_illegal_a6)); </span><span class="tlx_structure">endgenerate
</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

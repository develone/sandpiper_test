<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 286, 389, 0, 6, 269, 21, 0, 0, 'opacity: 0.1', 1251, 'opacity: 0.1', 648, 'opacity: 0.1'],
      ['top.sv', 0, 286, 690, 0, 0, 293, 0, 0, 0, 'opacity: 0.1', 1497, 'opacity: 0.1', 700, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 324, 178, 114, 0, 0, 723, 'opacity: 0.1', 840, 'opacity: 0.1', 839, 'opacity: 0.1'],
      ['SV Total', 0, 286, 690, 324, 178, 407, 0, 0, 723, 'opacity: 0.1', 2337, 'opacity: 0.1', 1539, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar entry;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For /entry/trans$data1.
</span><span class="tlx_declarations">logic [7:0] Entry_Trans_data1_a0 [3:0],
            Entry_Trans_data1_a1 [3:0];

</span><span class="tlx_comments">// For /entry/trans$data2.
</span><span class="tlx_declarations">logic [3:0] Entry_Trans_data2_a0 [3:0],
            Entry_Trans_data2_a1 [3:0];

</span><span class="tlx_comments">// For |rd$entry.
</span><span class="tlx_declarations">logic [1:0] RD_entry_a1;

</span><span class="tlx_comments">// For |rd$rd_en.
</span><span class="tlx_declarations">logic [0:0] RD_rd_en_a1;

</span><span class="tlx_comments">// For |rd/trans$data1.
</span><span class="tlx_declarations">logic [7:0] RD_Trans_data1_a1;

</span><span class="tlx_comments">// For |rd/trans$data2.
</span><span class="tlx_declarations">logic [3:0] RD_Trans_data2_a1;

</span><span class="tlx_comments">// For |wr$entry.
</span><span class="tlx_declarations">logic [1:0] WR_entry_a0;

</span><span class="tlx_comments">// For |wr$wr_en.
</span><span class="tlx_declarations">logic [0:0] WR_wr_en_a0;

</span><span class="tlx_comments">// For |wr/trans$data1.
</span><span class="tlx_declarations">logic [7:0] WR_Trans_data1_a0;

</span><span class="tlx_comments">// For |wr/trans$data2.
</span><span class="tlx_declarations">logic [3:0] WR_Trans_data2_a0;


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">

   //
   // Scope: /entry[3:0]
   //
   </span><span class="tlx_structure">for (entry = 0; entry &lt;= 3; entry++) begin : L1gen_Entry
</span><span class="tlx_comments">
      //
      // Scope: /trans
      //

         // For $data1.
         </span><span class="tlx_staging">always_ff @(posedge clk) Entry_Trans_data1_a1[entry][7:0] &lt;= Entry_Trans_data1_a0[entry][7:0];

         </span><span class="tlx_comments">// For $data2.
         </span><span class="tlx_staging">always_ff @(posedge clk) Entry_Trans_data2_a1[entry][3:0] &lt;= Entry_Trans_data2_a0[entry][3:0];


   </span><span class="tlx_structure">end


endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS
</span><span class="tlx_comments">

      //
      // Scope: /entry[3:0]
      //
      </span><span class="tlx_instrumentation">for (entry = 0; entry &lt;= 3; entry++) begin : \/entry 
</span><span class="tlx_comments">
         //
         // Scope: /trans
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/trans 
            logic [7:0] \@0$data1 ;
            assign \@0$data1 = Entry_Trans_data1_a0[entry];
            logic [3:0] \@0$data2 ;
            assign \@0$data2 = Entry_Trans_data2_a0[entry];
         end
      end

      </span><span class="tlx_comments">//
      // Scope: |rd
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|rd 
         logic [1:0] \@1$entry ;
         assign \@1$entry = RD_entry_a1;
         logic [0:0] \@1$rd_en ;
         assign \@1$rd_en = RD_rd_en_a1;

         </span><span class="tlx_comments">//
         // Scope: /trans
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/trans 
            logic [7:0] \@1$data1 ;
            assign \@1$data1 = RD_Trans_data1_a1;
            logic [3:0] \@1$data2 ;
            assign \@1$data2 = RD_Trans_data2_a1;
         end
      end

      </span><span class="tlx_comments">//
      // Scope: |wr
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|wr 
         logic [1:0] \@0$entry ;
         assign \@0$entry = WR_entry_a0;
         logic [0:0] \@0$wr_en ;
         assign \@0$wr_en = WR_wr_en_a0;

         </span><span class="tlx_comments">//
         // Scope: /trans
         //
         </span><span class="tlx_instrumentation">if (1) begin : \/trans 
            logic [7:0] \@0$data1 ;
            assign \@0$data1 = WR_Trans_data1_a0;
            logic [3:0] \@0$data2 ;
            assign \@0$data2 = WR_Trans_data2_a0;
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV

</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/221c93b3603bb4c72d3b024b3ec410e48f60e199/arrays.tlv&quot;

</span><span class="tlx_structure">\TLV
   </span><span class="tlx_comments">//$reset = *reset;

   //--------------------------------------------------
   // Stimulus
   //
   
   // Explicit random inputs.
   
   
   </span><span class="tlx_structure">|wr
      </span><span class="tlx_staging">@0
         </span><span class="tlx_comments">// The array hierarchy (to declare ranges)
         </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
            </span><span class="tlx_comments">// Must be declared before reference (currently).
            </span><span class="tlx_structure">/trans
         
         </span><span class="tlx_logic">$wr_en[0:0] = *RW_rand_vect[(0 + (0)) % 257 +: 1];
         </span><span class="tlx_validity">?$wr_en
            </span><span class="tlx_logic">$entry[1:0] = *RW_rand_vect[(124 + (0)) % 257 +: 2];  </span><span class="tlx_comments">// entry to write into
            </span><span class="tlx_structure">/trans  </span><span class="tlx_comments">// data to write (anything in this scope is available to pass through array, if used)
               </span><span class="tlx_logic">$data1[7:0] = *RW_rand_vect[(248 + (0)) % 257 +: 8];
               $data2[3:0] = *RW_rand_vect[(115 + (0)) % 257 +: 4];
   </span><span class="tlx_structure">|rd
      </span><span class="tlx_staging">@1
         </span><span class="tlx_logic">$rd_en[0:0] = *RW_rand_vect[(239 + (0)) % 257 +: 1];
         </span><span class="tlx_validity">?$rd_en
            </span><span class="tlx_logic">$entry[1:0] = *RW_rand_vect[(106 + (0)) % 257 +: 2];  </span><span class="tlx_comments">// entry to read from
            
            // Pull signals through array, simply by using them in this scope.
            </span><span class="tlx_structure">/trans
               </span><span class="tlx_logic">`BOGUS_USE($data1 $data2)
         
   
   </span><span class="tlx_comments">//----------------------------------------------------
   // The array

   </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/tlvflowlib/221c93b3603bb4c72d3b024b3ec410e48f60e199/arrays.tlv 36   </span><span class="tlx_comments">// Instantiated from top.tlv, 44 as: m4+array1r1w(/top, /entry, |wr, @0, $wr_en, $entry, |rd, @1, $rd_en, $entry, $ANY, /trans)
      // Write Pipeline
      // The array entries hierarchy (needs a definition to define range, and currently, /trans declaration required before reference).
      </span><span class="tlx_structure">/entry[</span><span class="tlx_logic">3</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         /trans
            
      </span><span class="tlx_comments">// Write transaction to cache
      // (TLV assignment syntax prohibits assignment outside of it's own scope, but \SV_plus does not.)
      </span><span class="tlx_structure">\SV_plus
         </span><span class="tlx_logic">always_comb
            if (</span><span class="tlx_structure">|wr</span><span class="tlx_logic">&gt;&gt;0$wr_en)
               </span><span class="tlx_structure">/entry[|wr</span><span class="tlx_logic">&gt;&gt;0$entry</span><span class="tlx_structure">]/trans</span><span class="tlx_logic">$$ANY = </span><span class="tlx_structure">|wr/trans</span><span class="tlx_logic">&gt;&gt;0$ANY;
      
      </span><span class="tlx_comments">// Read Pipeline
      </span><span class="tlx_structure">|rd
         </span><span class="tlx_staging">@1
            </span><span class="tlx_comments">// Read transaction from cache.
            </span><span class="tlx_validity">?$rd_en
               </span><span class="tlx_structure">/trans
                  </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top/entry[|rd</span><span class="tlx_logic">$entry</span><span class="tlx_structure">]/trans</span><span class="tlx_logic">&gt;&gt;0$ANY;
   </span><span class="tlx_structure">\end_source


   </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">*passed = *cyc_cnt &gt; 50;
   *failed = 1'b0;

</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV

</span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */
// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/221c93b3603bb4c72d3b024b3ec410e48f60e199/arrays.tlv&quot;

</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV
   //$reset = *reset;

   //--------------------------------------------------
   // Stimulus
   //
   
   // Explicit random inputs.
   
   
   //_|wr
      //_@0
         // The array hierarchy (to declare ranges)
         </span><span class="tlx_structure">for (entry = 0; entry &lt;= 3; entry++) begin : L1_WR_Entry </span><span class="tlx_comments">//_/entry
            // Must be declared before reference (currently).
            </span><span class="tlx_structure">end </span><span class="tlx_comments">//_/trans
         
         </span><span class="tlx_logic">assign WR_wr_en_a0[0:0] = RW_rand_vect[(0 + (0)) % 257 +: 1];
         </span><span class="tlx_comments">//_?$wr_en
            </span><span class="tlx_logic">assign WR_entry_a0[1:0] = RW_rand_vect[(124 + (0)) % 257 +: 2];  </span><span class="tlx_comments">// entry to write into
            //_/trans  // data to write (anything in this scope is available to pass through array, if used)
               </span><span class="tlx_logic">assign WR_Trans_data1_a0[7:0] = RW_rand_vect[(248 + (0)) % 257 +: 8];
               assign WR_Trans_data2_a0[3:0] = RW_rand_vect[(115 + (0)) % 257 +: 4];
   </span><span class="tlx_comments">//_|rd
      //_@1
         </span><span class="tlx_logic">assign RD_rd_en_a1[0:0] = RW_rand_vect[(239 + (0)) % 257 +: 1];
         </span><span class="tlx_comments">//_?$rd_en
            </span><span class="tlx_logic">assign RD_entry_a1[1:0] = RW_rand_vect[(106 + (0)) % 257 +: 2];  </span><span class="tlx_comments">// entry to read from
            
            // Pull signals through array, simply by using them in this scope.
            //_/trans
               </span><span class="tlx_logic">`BOGUS_USE(RD_Trans_data1_a1 RD_Trans_data2_a1)
         
   
   </span><span class="tlx_comments">//----------------------------------------------------
   // The array

   </span><span class="tlx_structure">`line 37 &quot;/raw.githubusercontent.com/stevehoover/tlvflowlib/221c93b3603bb4c72d3b024b3ec410e48f60e199/arrays.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 44 as: m4+array1r1w(/top, /entry, |wr, @0, $wr_en, $entry, |rd, @1, $rd_en, $entry, $ANY, /trans)
      // Write Pipeline
      // The array entries hierarchy (needs a definition to define range, and currently, /trans declaration required before reference).
      </span><span class="tlx_structure">for (entry = 0; entry &lt;= 3; entry++) begin : L1_Entry </span><span class="tlx_comments">//_/entry
         </span><span class="tlx_structure">end </span><span class="tlx_comments">//_/trans
            
      // Write transaction to cache
      // (TLV assignment syntax prohibits assignment outside of it's own scope, but \SV_plus does not.)
      /*SV_plus*/
         </span><span class="tlx_logic">always_comb
            if (WR_wr_en_a0)
               {Entry_Trans_data1_a0[WR_entry_a0][7:0], Entry_Trans_data2_a0[WR_entry_a0][3:0]} = {WR_Trans_data1_a0, WR_Trans_data2_a0};
      
      </span><span class="tlx_comments">// Read Pipeline
      //_|rd
         //_@1
            // Read transaction from cache.
            //_?$rd_en
               //_/trans
                  </span><span class="tlx_logic">assign {RD_Trans_data1_a1[7:0], RD_Trans_data2_a1[3:0]} = {Entry_Trans_data1_a1[RD_entry_a1], Entry_Trans_data2_a1[RD_entry_a1]};
   </span><span class="tlx_comments">//_\end_source
   </span><span class="tlx_structure">`line 45 &quot;top.tlv&quot; 2


   </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
   </span><span class="tlx_logic">assign passed = cyc_cnt &gt; 50;
   assign failed = 1'b0; </span><span class="tlx_structure">endgenerate

</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

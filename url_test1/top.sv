`line 2 "top.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
`include "sp_default.vh" //_\SV
/*
Copyright (c) 2018, Steve Hoover
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Included URL: "https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/5a8c0387be80b2deccfcd1506299b36049e0663e/fundamentals_lib.tlv"
// Included URL: "https://raw.githubusercontent.com/stevehoover/tlv_flow_lib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflow_lib.tlv"
module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */

`include "top_gen.sv" //_\TLV
   
   assign L0_reset_a0 = reset;
   
      // Defines constants for /port[3:0].
   
   
   //-------------
   // DUT
   // ------------
   
   // DUT Flow (FIFO and ring)
   for (port = 0; port <= 3; port++) begin : L1_Port logic L1_FIFO_IN_accepted_a1; logic L1_FIFO_IN_blocked_a1; logic L1_FIFO_IN_out_blocked_a1; logic L1_FIFO_IN_reset_in_a1; logic [$clog2(4)-1:0] L1_FIFO_IN_Fifo_cnt_a1; logic L1_RING_IN_avail_a1; logic L1_RING_IN_reset_a1; logic L1_RING_IN_Trans_cyc_cnt_a1; logic [7:0] L1_RING_IN_Trans_data_a1; logic [1:0] L1_RING_IN_Trans_dest_a1; logic [1:0] L1_RING_IN_Trans_sender_a1; //_/port   // (becomes /port[3:0])
      `line 775 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 50 as: m4+simple_bypass_fifo_v2(/port, |fifo_in, @1, |ring_in, @1, 4, 100, /trans)
         `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 775 as: m4+flow_interface(/port, [' |fifo_in, @1'], [' |ring_in, @1'], )
            `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |fifo_in, @1'], )
               // Avail/Blocked Input:
               //_|fifo_in
                  //_@1
                     assign L1_FIFO_IN_accepted_a1 = L1e_Port[port].L1_FIFO_IN_avail_a1 && ! L1_FIFO_IN_blocked_a1;  // provided for optional upstream use.
                     assign L1_FIFO_IN_reset_in_a1 = L1e_Port[port].L1_FIFO_IN_reset_a1;
                     `BOGUS_USE(L1_FIFO_IN_accepted_a1 L1_FIFO_IN_reset_in_a1)
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 50 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |fifo_in, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |ring_in, @1'])
               // Avail/Blocked Output:
               //_|ring_in
                  //_@1
                     `BOGUS_USE(L1_RING_IN_reset_a1) // Output pipes must provide $reset.
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 50 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |ring_in, @1))))
                  
               //_\end_source
               `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_\end_source
         `line 776 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_|fifo_in
            //_/trans
            //_@1
               assign L1_FIFO_IN_out_blocked_a1 = L1b_Port[port].L1_RING_IN_blocked_a1;
               assign L1_FIFO_IN_blocked_a1 = (L1_FIFO_IN_Fifo_cnt_a1 >= 4) && L1_FIFO_IN_out_blocked_a1;
               //_/fifo
                  simple_bypass_fifo #(.WIDTH(100), .DEPTH(4))
                     fifo(.clk(clk), .reset(L1_FIFO_IN_reset_in_a1),
                          .push(L1_FIFO_IN_accepted_a1),
                          .data_in({L1e_Port[port].L1_FIFO_IN_Trans_cyc_cnt_a1, L1c_Port[port].L1_FIFO_IN_Trans_data_a1, L1e_Port[port].L1_FIFO_IN_Trans_dest_a1, L1e_Port[port].L1_FIFO_IN_Trans_sender_a1}),
                          .pop(L1_FIFO_IN_accepted_a1),
                          .data_out({L1_RING_IN_Trans_cyc_cnt_a1, L1_RING_IN_Trans_data_a1[7:0], L1_RING_IN_Trans_dest_a1[1:0], L1_RING_IN_Trans_sender_a1[1:0]}),
                          .cnt(L1_FIFO_IN_Fifo_cnt_a1[$clog2(4)-1:0]));
         //_|ring_in
            //_/trans
            //_@1
               assign L1_RING_IN_avail_a1 = L1_FIFO_IN_Fifo_cnt_a1 != '0 || L1e_Port[port].L1_FIFO_IN_avail_a1;
               assign L1_RING_IN_reset_a1 = L1_FIFO_IN_reset_in_a1;
      end //_\end_source
      `line 51 "top.tlv" 2
   `line 1018 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 51 as: m4+simple_ring(/port, |ring_in, @1, |ring_out, @1, /top<>0$reset, |rg, /trans)
      
      
      
      
      
      
      // Logic
      for (port = 0; port <= 3; port++) begin : L1b_Port logic L1_RG_passed_on_a1; logic L1_RG_valid_a1; logic L1_RING_IN_accepted_a1; logic L1_RING_IN_blocked_a1; logic L1_RING_IN_reset_in_a1; logic L1_RING_OUT_avail_a1; logic L1_RING_OUT_reset_a1; logic L1_RING_OUT_trans_valid_a1, L1_RING_OUT_trans_valid_a2; logic L1_RING_OUT_Trans_cyc_cnt_a1; logic [7:0] L1_RING_OUT_Trans_data_a1, L1_RING_OUT_Trans_data_a2; logic [1:0] L1_RING_OUT_Trans_sender_a1; //_/port
         `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 1026 as: m4+flow_interface(/port, [' |ring_in, @1'], [' |ring_out, @1'], /top<>0$reset)
            `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |ring_in, @1'], /top<>0$reset)
               // Avail/Blocked Input:
               //_|ring_in
                  //_@1
                     assign L1_RING_IN_accepted_a1 = L1_Port[port].L1_RING_IN_avail_a1 && ! L1_RING_IN_blocked_a1;  // provided for optional upstream use.
                     assign L1_RING_IN_reset_in_a1 =  L0_reset_a1;
                     `BOGUS_USE(L1_RING_IN_accepted_a1 L1_RING_IN_reset_in_a1)
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 51 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |ring_in, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |ring_out, @1'])
               // Avail/Blocked Output:
               //_|ring_out
                  //_@1
                     `BOGUS_USE(L1_RING_OUT_reset_a1) // Output pipes must provide $reset.
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 51 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |ring_out, @1))))
                  
               //_\end_source
               `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_\end_source
         `line 1027 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         //_|default
            //_@0
               /*SV_plus*/
                  int prev_hop = (port + 4 - 1) % 4;
         //_|ring_in
            //_@1
               assign L1_RING_IN_blocked_a1 = L1_RG_passed_on_a1;
         //_|rg
            //_@1
               assign L1_RG_passed_on_a1 = Port_RG_pass_on_a2[prev_hop];
               assign L1_RG_valid_a1 = ! L1_RING_IN_reset_in_a1 &&
                        (L1_RG_passed_on_a1 || L1_Port[port].L1_RING_IN_avail_a1);
               assign Port_RG_pass_on_a1[port] = L1_RG_valid_a1 && ! L1_RING_OUT_trans_valid_a1;
               assign Port_RG_dest_a1[port][1:0] =
                  L1_RG_passed_on_a1
                     ? Port_RG_dest_a2[prev_hop]
                     : L1_Port[port].L1_RING_IN_Trans_dest_a1;
            //_@1
               //_?$valid
                  //_/trans
                     assign {Port_RG_Trans_cyc_cnt_a1[port], Port_RG_Trans_data_a1[port][7:0], Port_RG_Trans_sender_a1[port][1:0]} =
                       L1_RG_passed_on_a1
                           ? {Port_RG_Trans_cyc_cnt_a2[prev_hop], Port_RG_Trans_data_a2[prev_hop], Port_RG_Trans_sender_a2[prev_hop]}
                           : {L1_Port[port].L1_RING_IN_Trans_cyc_cnt_a1, L1_Port[port].L1_RING_IN_Trans_data_a1, L1_Port[port].L1_RING_IN_Trans_sender_a1};
         //_|ring_out
            // Ring out
            //_@1
               assign L1_RING_OUT_avail_a1 = L1_RG_valid_a1 && (Port_RG_dest_a1[port] == port);
               //$blocked = 1'b0;
               assign L1_RING_OUT_trans_valid_a1 = L1_RING_OUT_avail_a1; // && ! $blocked;
               assign L1_RING_OUT_reset_a1 = L1_RING_IN_reset_in_a1;
            //_?$trans_valid
               //_@1
                  //_/trans
                     assign {L1_RING_OUT_Trans_cyc_cnt_a1, L1_RING_OUT_Trans_data_a1[7:0], L1_RING_OUT_Trans_sender_a1[1:0]} = {Port_RG_Trans_cyc_cnt_a1[port], Port_RG_Trans_data_a1[port], Port_RG_Trans_sender_a1[port]}; end
      
      
      
      
      
   //_\end_source
   `line 52 "top.tlv" 2
   
   // Transaction logic.
   for (port = 0; port <= 3; port++) begin : L1c_Port logic [7:0] L1_FIFO_IN_Trans_data_a1; //_/port
      //_|fifo_in
         //_@1
            //_?$accepted
               //_/trans
                  assign L1_FIFO_IN_Trans_data_a1[7:0] = cyc_cnt[7:0];
                  // Compute parity
                  // [+] $parity = ^ {$data, $dest};
      
      //_|ring_out
         //_@2
            //_?$trans_valid
               //_/trans
                  `BOGUS_USE(L1b_Port[port].L1_RING_OUT_Trans_data_a2) end
               
                  // Check parity.
                  // [+] $parity_error = $parity != ^ {$data, $dest};

   //--------------
   // Testbench
   `line 1306 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 74 as: m4+router_testbench(/top, /port, |fifo_in, @1, |ring_out, @1, /trans, /top<>0$reset)
        // Otherwise we can have a cyclic reset loop through flow.
      for (port = 0; port <= 3; port++) begin : L1d_Port logic L1_RING_OUT_accepted_a1; logic L1_RING_OUT_reset_in_a1; //_/port
         // Define flow interface. Note that router ins are tb outs and outs are ins.
         `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 1309 as: m4+flow_interface(/port, [' |ring_out, @1'], [' |fifo_in, @1'], /top<>0$reset)
            `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |ring_out, @1'], /top<>0$reset)
               // Avail/Blocked Input:
               //_|ring_out
                  //_@1
                     assign L1_RING_OUT_accepted_a1 = L1b_Port[port].L1_RING_OUT_avail_a1 && ! L1e_Port[port].L1_RING_OUT_blocked_a1;  // provided for optional upstream use.
                     assign L1_RING_OUT_reset_in_a1 =  L0_reset_a1;
                     `BOGUS_USE(L1_RING_OUT_accepted_a1 L1_RING_OUT_reset_in_a1)
               `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 74 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |ring_out, @1))), m4_quote(m4_shift(_resets)))
                  
               //_\end_source
               `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |fifo_in, @1'])
               // Avail/Blocked Output:
               //_|fifo_in
                  //_@1
                     `BOGUS_USE(L1e_Port[port].L1_FIFO_IN_reset_a1) // Output pipes must provide $reset.
               `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 74 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |fifo_in, @1))))
                  
               //_\end_source
               `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               
            //_\end_source
            `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
         end //_\end_source
         `line 1310 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
      
      
      
   
      //_/tb
         //_|count
            //_@1
               assign Tb_COUNT_CycCount_a0[15:0] = L1e_Port[0].L1_FIFO_IN_reset_a2
                                     ? 16'b0 :
                                       Tb_COUNT_CycCount_a1 + 1;
               /*SV_plus*/
                  always_ff @(posedge clk) begin
                     $display("Cycle: %0d", Tb_COUNT_CycCount_a1);
                  end
         for (port = 0; port <= 3; port++) begin : L1_Tb_Port logic L1_RECEIVE1_accepted_a1; logic L1_RECEIVE1_avail_a1; logic L1_RECEIVE1_blocked_a1; logic L1_RECEIVE1_reset_a1; logic L1_RECEIVE1_reset_in_a1; logic L1_RECEIVE1_Trans_cyc_cnt_a1; logic [1:0] L1_RECEIVE1_Trans_dest_a1; logic L1_RECEIVE1_Trans_request_a1; logic L1_RECEIVE1_Trans_response_a1; logic L1_RECEIVE1_Trans_response_debug_a1; logic [1:0] L1_RECEIVE1_Trans_sender_a1; logic [16-1:0] L1_RECEIVE2_OutstandingPackets_a0, L1_RECEIVE2_OutstandingPackets_a1; logic L1_RECEIVE2_accepted_a1; logic L1_RECEIVE2_avail_a0, L1_RECEIVE2_avail_a1; logic L1_RECEIVE2_blocked_a1; logic L1_RECEIVE2_generated_request_a1; logic L1_RECEIVE2_recirc_a1; logic L1_RECEIVE2_reset_a0, L1_RECEIVE2_reset_a1; logic L1_RECEIVE2_valid_request_a1; logic L1_RECEIVE2_valid_response_a1; logic L1_RECEIVE2_Trans_cyc_cnt_a0, L1_RECEIVE2_Trans_cyc_cnt_a1; logic [1:0] L1_RECEIVE2_Trans_dest_a0, L1_RECEIVE2_Trans_dest_a1; logic L1_RECEIVE2_Trans_request_a0, L1_RECEIVE2_Trans_request_a1; logic L1_RECEIVE2_Trans_response_a0, L1_RECEIVE2_Trans_response_a1; logic L1_RECEIVE2_Trans_response_debug_a0, L1_RECEIVE2_Trans_response_debug_a1; logic L1_RECEIVE2_Trans_sender_a0, L1_RECEIVE2_Trans_sender_a1; logic L1_SEND_avail_a1; logic L1_SEND_reset_a1; logic L1_SEND_valid_in_a1; logic [15:0] L1_SEND_GenTrans_cyc_cnt_a1; logic [1:0] L1_SEND_GenTrans_dest_a1; logic [1:0] L1_SEND_GenTrans_dest_tmp_a1; logic L1_SEND_GenTrans_response_debug_a1; logic [1:0] L1_SEND_GenTrans_sender_a1; logic [15:0] L1_SEND_TransOut_cyc_cnt_a1; logic [1:0] L1_SEND_TransOut_dest_a1; logic L1_SEND_TransOut_response_debug_a1; logic [1:0] L1_SEND_TransOut_sender_a1; //_/port
            // STIMULUS
            //_|send
               //_@1
                  // Generate a transaction to inject sometimes (if needed)
                  assign L1_SEND_reset_a1 = L1_RECEIVE2_reset_a1;
                  assign L1_SEND_valid_in_a1 = Tb_COUNT_CycCount_a1 == 3;
                  //_?$valid_in
                     //_/gen_trans
                        assign L1_SEND_GenTrans_cyc_cnt_a1[15:0] = Tb_COUNT_CycCount_a1;
                        assign L1_SEND_GenTrans_response_debug_a1 = 1'b0;  // Not a response (for debug)
                        assign L1_SEND_GenTrans_sender_a1[1:0] = port;
                        //m4_rand($size, M4_PACKET_SIZE-1, 0, #m4_port) // unused
                        assign L1_SEND_GenTrans_dest_tmp_a1[1:0] = RW_rand_vect[(0 + (port)) % 257 +: 2];
                        assign L1_SEND_GenTrans_dest_a1[1:0] = L1_SEND_GenTrans_dest_tmp_a1 % 4;
                        //$dest[M4_['']M4_PORT['']_INDEX_RANGE] = #m4_port;
                        //$packet_valid = #m4_port == 0 ? 1'b1 : 1'b0; // valid for only first port - unused
                  assign L1_SEND_avail_a1 = L1_SEND_valid_in_a1 || L1_RECEIVE2_valid_request_a1;
                  //_?$avail
                     //_/trans_out
                        // Loopback requests as responses or use gen_trans.
                        assign {L1_SEND_TransOut_cyc_cnt_a1[15:0], L1_SEND_TransOut_dest_a1[1:0], L1_SEND_TransOut_response_debug_a1, L1_SEND_TransOut_sender_a1[1:0]} = L1_RECEIVE2_valid_request_a1
                                    ? {L1_RECEIVE2_Trans_cyc_cnt_a1, L1_RECEIVE2_Trans_dest_a1, L1_RECEIVE2_Trans_response_debug_a1, L1_RECEIVE2_Trans_sender_a1} :
                                      {L1_SEND_GenTrans_cyc_cnt_a1, L1_SEND_GenTrans_dest_a1[1:0], L1_SEND_GenTrans_response_debug_a1, L1_SEND_GenTrans_sender_a1};
                        
                        /*SV_plus*/
                           always_ff @(posedge clk) begin
                              if (! L1_SEND_reset_a1 && ! reset && L1_Port[port].L1_FIFO_IN_accepted_a1) begin
                                 $display("|send[%0d]", port);
                                 $display("Sender: %0d, Orig. Cyc: %0d, Dest: %0d, Resp: %0d", L1_SEND_TransOut_sender_a1, L1_SEND_TransOut_cyc_cnt_a1, L1_SEND_TransOut_dest_a1, L1_SEND_TransOut_response_debug_a1);
                              end
                           end
            // Hook router out to |receive1 and determine transaction response routing (within the transaction).
            //_|receive1
               //_@1
                  assign L1_RECEIVE1_avail_a1 = L1b_Port[port].L1_RING_OUT_avail_a1;
                  assign L1_RECEIVE1_reset_a1 = L1d_Port[port].L1_RING_OUT_reset_in_a1;
                  //_?$accepted
                     //_/trans
                        assign L1_RECEIVE1_Trans_response_debug_a1 = 1'b1; // Turn this around as a response.
                        assign L1_RECEIVE1_Trans_request_a1 = L1_RECEIVE1_Trans_sender_a1 != port;  // Arrived as request?
                        assign L1_RECEIVE1_Trans_response_a1 = L1_RECEIVE1_Trans_sender_a1 == port; // Arrived as response?
                        assign {L1_RECEIVE1_Trans_cyc_cnt_a1, L1_RECEIVE1_Trans_sender_a1[1:0]} = {L1b_Port[port].L1_RING_OUT_Trans_cyc_cnt_a1, L1b_Port[port].L1_RING_OUT_Trans_sender_a1};
                        assign L1_RECEIVE1_Trans_dest_a1[1:0] = L1_RECEIVE1_Trans_request_a1 ? L1_RECEIVE1_Trans_sender_a1 : L1_RECEIVE1_Trans_dest_a1;
            `line 343 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 1368 as: m4+bp_stage(/port, |receive1, @1, |receive2, @1, /trans)
               
               
               
               
               
               
               `line 115 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 349 as: m4+flow_interface(/port, [' |receive1, @1'], [' |receive2, @1'], )
                  `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 115 as: m4+flow_inputs(/port, [' |receive1, @1'], )
                     // Avail/Blocked Input:
                     //_|receive1
                        //_@1
                           assign L1_RECEIVE1_accepted_a1 = L1_RECEIVE1_avail_a1 && ! L1_RECEIVE1_blocked_a1;  // provided for optional upstream use.
                           assign L1_RECEIVE1_reset_in_a1 = L1_RECEIVE1_reset_a1;
                           `BOGUS_USE(L1_RECEIVE1_accepted_a1 L1_RECEIVE1_reset_in_a1)
                     `line 120 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 74 as: m4+flow_inputs(/port, m4_quote(m4_shift(m4_shift( |receive1, @1))), m4_quote(m4_shift(_resets)))
                        
                     //_\end_source
                     `line 127 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                     
                  //_\end_source
                  `line 116 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                  `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 116 as: m4+flow_outputs(/port, [' |receive2, @1'])
                     // Avail/Blocked Output:
                     //_|receive2
                        //_@1
                           `BOGUS_USE(L1_RECEIVE2_reset_a1) // Output pipes must provide $reset.
                     `line 130 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 1   // Instantiated from top.tlv, 74 as: m4+flow_outputs(/port, m4_quote(m4_shift(m4_shift( |receive2, @1))))
                        
                     //_\end_source
                     `line 135 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
                     
                  //_\end_source
                  `line 117 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               //_\end_source
               `line 350 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
               //_|receive2
                  //_@0
                     assign L1_RECEIVE2_reset_a0 = L1_RECEIVE1_reset_in_a1;
                     
                     assign L1_RECEIVE2_avail_a0 = L1_RECEIVE2_reset_a0 ? 1'b0 :
                                       (L1_RECEIVE2_avail_a1 && L1_RECEIVE2_blocked_a1) ||  // Recirc'ed or
                                       // Above is recomputation of $recirc to avoid a flop.
                                       // For SELF, its in the same stage, and is redundant computation.
                                       L1_RECEIVE1_avail_a1; // Incoming available
                     //$first_avail = $avail && ! >>1$blocked;  // Transaction is newly available.
                  //_@0
                     //_?$avail  // Physically, $first_avail && *reset_b for functional gating in
                              // place of recirculation.
                        //_/trans
                           assign {L1_RECEIVE2_Trans_cyc_cnt_a0, L1_RECEIVE2_Trans_dest_a0[1:0], L1_RECEIVE2_Trans_request_a0, L1_RECEIVE2_Trans_response_a0, L1_RECEIVE2_Trans_response_debug_a0, L1_RECEIVE2_Trans_sender_a0} =
                              L1_RECEIVE2_recirc_a1 ? {L1_RECEIVE2_Trans_cyc_cnt_a1, L1_RECEIVE2_Trans_dest_a1, L1_RECEIVE2_Trans_request_a1, L1_RECEIVE2_Trans_response_a1, L1_RECEIVE2_Trans_response_debug_a1, L1_RECEIVE2_Trans_sender_a1}
                                                   : {L1_RECEIVE1_Trans_cyc_cnt_a1, L1_RECEIVE1_Trans_dest_a1, L1_RECEIVE1_Trans_request_a1, L1_RECEIVE1_Trans_response_a1, L1_RECEIVE1_Trans_response_debug_a1, L1_RECEIVE1_Trans_sender_a1};
                  //_@1
                     assign L1_RECEIVE2_recirc_a1 = L1_RECEIVE2_avail_a1 && L1_RECEIVE2_blocked_a1;  // Available transaction that is blocked; must recirc.
               //_|receive1
                  //_@1
                     assign L1_RECEIVE1_blocked_a1 = L1_RECEIVE2_recirc_a1;
                     // This trans is blocked (whether valid or not) if the next stage is recirculating.
               
               
               
               
               
               
            //_\end_source
            `line 1369 "/raw.githubusercontent.com/stevehoover/tlvflowlib/5a8c0387be80b2deccfcd1506299b36049e0663e/pipeflowlib.tlv" 2
            // A one-cycle backpressured stage to avoid 0-cycle loopback.
            //_|receive2
               //_@1
                  assign L1_RECEIVE2_valid_request_a1 = L1_RECEIVE2_accepted_a1 && L1_RECEIVE2_Trans_request_a1;
                  assign L1_RECEIVE2_valid_response_a1 = L1_RECEIVE2_accepted_a1 && L1_RECEIVE2_Trans_response_a1;
                  // Block requests that cannot loopback a response .
                  assign L1_RECEIVE2_blocked_a1 = L1_RECEIVE2_valid_request_a1 && L1_Port[port].L1_FIFO_IN_blocked_a1;
                  assign L1_RECEIVE2_accepted_a1 = L1_RECEIVE2_avail_a1 && ! L1_RECEIVE2_blocked_a1;
                  assign L1_RECEIVE2_generated_request_a1 =   L1_Port[port].L1_FIFO_IN_accepted_a1 &&
                                       ! L1e_Port[port].L1_FIFO_IN_Trans_response_debug_a1;
                  assign L1_RECEIVE2_OutstandingPackets_a0[16-1:0] =
                       L1_RECEIVE2_reset_a1 ? '0 :
                         (L1_RECEIVE2_OutstandingPackets_a1 +
                          (L1_RECEIVE2_generated_request_a1 ? 16'b1 : '0) -
                          (L1_RECEIVE2_valid_response_a1 ? 16'b1 : '0)
                         );
            //_|passed  // Aligned to |receive2, but given a new pipeline name to provide a cleaner interface for this $passed output.
               //_@1
                  assign Tb_Port_PASSED_passed_a1[port] = ! L1_RECEIVE2_reset_a1 && L1_RECEIVE2_OutstandingPackets_a1 == '0 && Tb_COUNT_CycCount_a1 > 12; end
      // Connect with DUT.
      for (port = 0; port <= 3; port++) begin : L1e_Port logic L1_FIFO_IN_avail_a1; logic L1_FIFO_IN_reset_a1, L1_FIFO_IN_reset_a2; logic L1_FIFO_IN_Trans_cyc_cnt_a1; logic [1:0] L1_FIFO_IN_Trans_dest_a1; logic L1_FIFO_IN_Trans_response_debug_a1; logic [1:0] L1_FIFO_IN_Trans_sender_a1; logic L1_RING_OUT_blocked_a1; //_/port
         //_|fifo_in
            //_@1
               assign L1_FIFO_IN_avail_a1 = ! L1_FIFO_IN_reset_a1 && L1_Tb_Port[port].L1_SEND_avail_a1;
               //_?$avail
                  //_/trans
                     assign {L1_FIFO_IN_Trans_cyc_cnt_a1, L1_FIFO_IN_Trans_dest_a1[1:0], L1_FIFO_IN_Trans_response_debug_a1, L1_FIFO_IN_Trans_sender_a1[1:0]} = {L1_Tb_Port[port].L1_SEND_TransOut_cyc_cnt_a1, L1_Tb_Port[port].L1_SEND_TransOut_dest_a1, L1_Tb_Port[port].L1_SEND_TransOut_response_debug_a1, L1_Tb_Port[port].L1_SEND_TransOut_sender_a1};
               assign L1_FIFO_IN_reset_a1 = L1_Tb_Port[port].L1_RECEIVE2_reset_a1;
         //_|ring_out
            //_@1
               assign L1_RING_OUT_blocked_a1 = L1_Tb_Port[port].L1_RECEIVE1_blocked_a1;
            end //_/trans
      
      
   //_\end_source
   `line 75 "top.tlv" 2
   
   
   assign passed = | Tb_Port_PASSED_passed_a1;
   assign failed = cyc_cnt > 20; endgenerate
   
//_\SV
endmodule 

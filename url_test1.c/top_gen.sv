// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"


genvar port;


//
// Signals declared top-level.
//

// For $reset.
logic L0_reset_a0,
      L0_reset_a1;

// For /port|rg$dest.
logic [4:0] Port_RG_dest_a1 [7:0],
            Port_RG_dest_a2 [7:0];

// For /port|rg$pass_on.
logic Port_RG_pass_on_a1 [7:0],
      Port_RG_pass_on_a2 [7:0];

// For /port|rg/trans$cyc_cnt.
logic Port_RG_Trans_cyc_cnt_a1 [7:0] /* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */,
      Port_RG_Trans_cyc_cnt_a2 [7:0] /* verilator lint_restore */;

// For /port|rg/trans$data.
logic [7:0] Port_RG_Trans_data_a1 [7:0] /* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */,
            Port_RG_Trans_data_a2 [7:0] /* verilator lint_restore */;

// For /port|rg/trans$sender.
logic [4:0] Port_RG_Trans_sender_a1 [7:0] /* verilator lint_save */ /* verilator lint_off MULTIDRIVEN */,
            Port_RG_Trans_sender_a2 [7:0] /* verilator lint_restore */;

// For /tb/port|passed$passed.
logic [7:0] Tb_Port_PASSED_passed_a1;

// For /tb|count$CycCount.
logic [15:0] Tb_COUNT_CycCount_a0,
             Tb_COUNT_CycCount_a1;


//
// Scope: /port[7:0]
//

//
// Scope: /port|rg
//

// Clock signals.
logic clkP_Port_RG_valid_a2 [7:0];

//
// Scope: /port|ring_out
//

// Clock signals.
logic clkP_Port_RING_OUT_trans_valid_a2 [7:0];

//
// Scope: /tb
//

//
// Scope: /tb/port[7:0]
//

//
// Scope: /tb/port|receive2
//

// Clock signals.
logic clkP_Tb_Port_RECEIVE2_avail_a1 [7:0];


generate

   // For $reset.
   always_ff @(posedge clk) L0_reset_a1 <= L0_reset_a0;


   //
   // Scope: /port[7:0]
   //
   for (port = 0; port <= 7; port++) begin : L1gen_Port

      //
      // Scope: |fifo_in
      //

         // For $reset.
         always_ff @(posedge clk) L1e_Port[port].L1_FIFO_IN_reset_a2 <= L1e_Port[port].L1_FIFO_IN_reset_a1;



      //
      // Scope: |rg
      //

         // For $dest.
         always_ff @(posedge clk) Port_RG_dest_a2[port][4:0] <= Port_RG_dest_a1[port][4:0];

         // For $pass_on.
         always_ff @(posedge clk) Port_RG_pass_on_a2[port] <= Port_RG_pass_on_a1[port];


         //
         // Scope: /trans
         //

            // For $cyc_cnt.
            always_ff @(posedge clkP_Port_RG_valid_a2[port]) Port_RG_Trans_cyc_cnt_a2[port] <= Port_RG_Trans_cyc_cnt_a1[port];

            // For $data.
            always_ff @(posedge clkP_Port_RG_valid_a2[port]) Port_RG_Trans_data_a2[port][7:0] <= Port_RG_Trans_data_a1[port][7:0];

            // For $sender.
            always_ff @(posedge clkP_Port_RG_valid_a2[port]) Port_RG_Trans_sender_a2[port][4:0] <= Port_RG_Trans_sender_a1[port][4:0];




      //
      // Scope: |ring_out
      //

         // For $trans_valid.
         always_ff @(posedge clk) L1b_Port[port].L1_RING_OUT_trans_valid_a2 <= L1b_Port[port].L1_RING_OUT_trans_valid_a1;


         //
         // Scope: /trans
         //

            // For $data.
            always_ff @(posedge clkP_Port_RING_OUT_trans_valid_a2[port]) L1b_Port[port].L1_RING_OUT_Trans_data_a2[7:0] <= L1b_Port[port].L1_RING_OUT_Trans_data_a1[7:0];



   end

   //
   // Scope: /tb
   //


      //
      // Scope: /port[7:0]
      //
      for (port = 0; port <= 7; port++) begin : L1gen_Tb_Port

         //
         // Scope: |receive2
         //

            // For $OutstandingPackets.
            always_ff @(posedge clk) L1_Tb_Port[port].L1_RECEIVE2_OutstandingPackets_a1[16-1:0] <= L1_Tb_Port[port].L1_RECEIVE2_OutstandingPackets_a0[16-1:0];

            // For $avail.
            always_ff @(posedge clk) L1_Tb_Port[port].L1_RECEIVE2_avail_a1 <= L1_Tb_Port[port].L1_RECEIVE2_avail_a0;

            // For $reset.
            always_ff @(posedge clk) L1_Tb_Port[port].L1_RECEIVE2_reset_a1 <= L1_Tb_Port[port].L1_RECEIVE2_reset_a0;


            //
            // Scope: /trans
            //

               // For $cyc_cnt.
               always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_cyc_cnt_a1 <= L1_Tb_Port[port].L1_RECEIVE2_Trans_cyc_cnt_a0;

               // For $dest.
               always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_dest_a1[1:0] <= L1_Tb_Port[port].L1_RECEIVE2_Trans_dest_a0[1:0];

               // For $request.
               always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_request_a1 <= L1_Tb_Port[port].L1_RECEIVE2_Trans_request_a0;

               // For $response.
               always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_response_a1 <= L1_Tb_Port[port].L1_RECEIVE2_Trans_response_a0;

               // For $response_debug.
               always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_response_debug_a1 <= L1_Tb_Port[port].L1_RECEIVE2_Trans_response_debug_a0;

               // For $sender.
               always_ff @(posedge clkP_Tb_Port_RECEIVE2_avail_a1[port]) L1_Tb_Port[port].L1_RECEIVE2_Trans_sender_a1 <= L1_Tb_Port[port].L1_RECEIVE2_Trans_sender_a0;



      end

      //
      // Scope: |count
      //

         // For $CycCount.
         always_ff @(posedge clk) Tb_COUNT_CycCount_a1[15:0] <= Tb_COUNT_CycCount_a0[15:0];





endgenerate



//
// Gated clocks.
//

generate



   //
   // Scope: /port[7:0]
   //
   for (port = 0; port <= 7; port++) begin : L1clk_Port

      //
      // Scope: |rg
      //

         clk_gate gen_clkP_Port_RG_valid_a2(clkP_Port_RG_valid_a2[port], clk, 1'b1, L1b_Port[port].L1_RG_valid_a1, 1'b0);


      //
      // Scope: |ring_out
      //

         clk_gate gen_clkP_Port_RING_OUT_trans_valid_a2(clkP_Port_RING_OUT_trans_valid_a2[port], clk, 1'b1, L1b_Port[port].L1_RING_OUT_trans_valid_a1, 1'b0);

   end

   //
   // Scope: /tb
   //


      //
      // Scope: /port[7:0]
      //
      for (port = 0; port <= 7; port++) begin : L1clk_Tb_Port

         //
         // Scope: |receive2
         //

            clk_gate gen_clkP_Tb_Port_RECEIVE2_avail_a1(clkP_Tb_Port_RECEIVE2_avail_a1[port], clk, 1'b1, L1_Tb_Port[port].L1_RECEIVE2_avail_a0, 1'b0);

      end



endgenerate



//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS

      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      //
      // Scope: /port[7:0]
      //
      for (port = 0; port <= 7; port++) begin : \/port 

         //
         // Scope: |fifo_in
         //
         if (1) begin : \|fifo_in 
            logic  \@1$accepted ;
            assign \@1$accepted = L1_Port[port].L1_FIFO_IN_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1e_Port[port].L1_FIFO_IN_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1_Port[port].L1_FIFO_IN_blocked_a1;
            logic  \@1$out_blocked ;
            assign \@1$out_blocked = L1_Port[port].L1_FIFO_IN_out_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1e_Port[port].L1_FIFO_IN_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1_Port[port].L1_FIFO_IN_reset_in_a1;

            //
            // Scope: /fifo
            //
            if (1) begin : \/fifo 
               logic [$clog2(8)-1:0] \@1$cnt ;
               assign \@1$cnt = L1_Port[port].L1_FIFO_IN_Fifo_cnt_a1;
            end

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1e_Port[port].L1_FIFO_IN_Trans_cyc_cnt_a1;
               logic [7:0] \@1$data ;
               assign \@1$data = L1c_Port[port].L1_FIFO_IN_Trans_data_a1;
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1e_Port[port].L1_FIFO_IN_Trans_dest_a1;
               logic  \@1$response_debug ;
               assign \@1$response_debug = L1e_Port[port].L1_FIFO_IN_Trans_response_debug_a1;
               logic [4:0] \@1$sender ;
               assign \@1$sender = L1e_Port[port].L1_FIFO_IN_Trans_sender_a1;
            end
         end

         //
         // Scope: |rg
         //
         if (1) begin : \|rg 
            logic [4:0] \@1$dest ;
            assign \@1$dest = Port_RG_dest_a1[port];
            logic  \@1$pass_on ;
            assign \@1$pass_on = Port_RG_pass_on_a1[port];
            logic  \@1$passed_on ;
            assign \@1$passed_on = L1b_Port[port].L1_RG_passed_on_a1;
            logic  \@1$valid ;
            assign \@1$valid = L1b_Port[port].L1_RG_valid_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = Port_RG_Trans_cyc_cnt_a1[port];
               logic [7:0] \@1$data ;
               assign \@1$data = Port_RG_Trans_data_a1[port];
               logic [4:0] \@1$sender ;
               assign \@1$sender = Port_RG_Trans_sender_a1[port];
            end
         end

         //
         // Scope: |ring_in
         //
         if (1) begin : \|ring_in 
            logic  \@1$accepted ;
            assign \@1$accepted = L1b_Port[port].L1_RING_IN_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1_Port[port].L1_RING_IN_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1b_Port[port].L1_RING_IN_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1_Port[port].L1_RING_IN_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1b_Port[port].L1_RING_IN_reset_in_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1_Port[port].L1_RING_IN_Trans_cyc_cnt_a1;
               logic [7:0] \@1$data ;
               assign \@1$data = L1_Port[port].L1_RING_IN_Trans_data_a1;
               logic [1:0] \@1$dest ;
               assign \@1$dest = L1_Port[port].L1_RING_IN_Trans_dest_a1;
               logic [4:0] \@1$sender ;
               assign \@1$sender = L1_Port[port].L1_RING_IN_Trans_sender_a1;
            end
         end

         //
         // Scope: |ring_out
         //
         if (1) begin : \|ring_out 
            logic  \@1$accepted ;
            assign \@1$accepted = L1d_Port[port].L1_RING_OUT_accepted_a1;
            logic  \@1$avail ;
            assign \@1$avail = L1b_Port[port].L1_RING_OUT_avail_a1;
            logic  \@1$blocked ;
            assign \@1$blocked = L1e_Port[port].L1_RING_OUT_blocked_a1;
            logic  \@1$reset ;
            assign \@1$reset = L1b_Port[port].L1_RING_OUT_reset_a1;
            logic  \@1$reset_in ;
            assign \@1$reset_in = L1d_Port[port].L1_RING_OUT_reset_in_a1;
            logic  \@1$trans_valid ;
            assign \@1$trans_valid = L1b_Port[port].L1_RING_OUT_trans_valid_a1;

            //
            // Scope: /trans
            //
            if (1) begin : \/trans 
               logic  \@1$cyc_cnt ;
               assign \@1$cyc_cnt = L1b_Port[port].L1_RING_OUT_Trans_cyc_cnt_a1;
               logic [7:0] \@1$data ;
               assign \@1$data = L1b_Port[port].L1_RING_OUT_Trans_data_a1;
               logic [4:0] \@1$sender ;
               assign \@1$sender = L1b_Port[port].L1_RING_OUT_Trans_sender_a1;
            end
         end
      end

      //
      // Scope: /tb
      //
      if (1) begin : \/tb 

         //
         // Scope: /port[7:0]
         //
         for (port = 0; port <= 7; port++) begin : \/port 

            //
            // Scope: |passed
            //
            if (1) begin : \|passed 
               logic  \@1$passed ;
               assign \@1$passed = Tb_Port_PASSED_passed_a1[port];
            end

            //
            // Scope: |receive1
            //
            if (1) begin : \|receive1 
               logic  \@1$accepted ;
               assign \@1$accepted = L1_Tb_Port[port].L1_RECEIVE1_accepted_a1;
               logic  \@1$avail ;
               assign \@1$avail = L1_Tb_Port[port].L1_RECEIVE1_avail_a1;
               logic  \@1$blocked ;
               assign \@1$blocked = L1_Tb_Port[port].L1_RECEIVE1_blocked_a1;
               logic  \@1$reset ;
               assign \@1$reset = L1_Tb_Port[port].L1_RECEIVE1_reset_a1;
               logic  \@1$reset_in ;
               assign \@1$reset_in = L1_Tb_Port[port].L1_RECEIVE1_reset_in_a1;

               //
               // Scope: /trans
               //
               if (1) begin : \/trans 
                  logic  \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_Port[port].L1_RECEIVE1_Trans_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_Port[port].L1_RECEIVE1_Trans_dest_a1;
                  logic  \@1$request ;
                  assign \@1$request = L1_Tb_Port[port].L1_RECEIVE1_Trans_request_a1;
                  logic  \@1$response ;
                  assign \@1$response = L1_Tb_Port[port].L1_RECEIVE1_Trans_response_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_Port[port].L1_RECEIVE1_Trans_response_debug_a1;
                  logic [4:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_Port[port].L1_RECEIVE1_Trans_sender_a1;
               end
            end

            //
            // Scope: |receive2
            //
            if (1) begin : \|receive2 
               logic [16-1:0] \@0$OutstandingPackets ;
               assign \@0$OutstandingPackets = L1_Tb_Port[port].L1_RECEIVE2_OutstandingPackets_a0;
               logic  \@1$accepted ;
               assign \@1$accepted = L1_Tb_Port[port].L1_RECEIVE2_accepted_a1;
               logic  \@0$avail ;
               assign \@0$avail = L1_Tb_Port[port].L1_RECEIVE2_avail_a0;
               logic  \@1$blocked ;
               assign \@1$blocked = L1_Tb_Port[port].L1_RECEIVE2_blocked_a1;
               logic  \@1$generated_request ;
               assign \@1$generated_request = L1_Tb_Port[port].L1_RECEIVE2_generated_request_a1;
               logic  \@1$recirc ;
               assign \@1$recirc = L1_Tb_Port[port].L1_RECEIVE2_recirc_a1;
               logic  \@0$reset ;
               assign \@0$reset = L1_Tb_Port[port].L1_RECEIVE2_reset_a0;
               logic  \@1$valid_request ;
               assign \@1$valid_request = L1_Tb_Port[port].L1_RECEIVE2_valid_request_a1;
               logic  \@1$valid_response ;
               assign \@1$valid_response = L1_Tb_Port[port].L1_RECEIVE2_valid_response_a1;

               //
               // Scope: /trans
               //
               if (1) begin : \/trans 
                  logic  \@0$cyc_cnt ;
                  assign \@0$cyc_cnt = L1_Tb_Port[port].L1_RECEIVE2_Trans_cyc_cnt_a0;
                  logic [1:0] \@0$dest ;
                  assign \@0$dest = L1_Tb_Port[port].L1_RECEIVE2_Trans_dest_a0;
                  logic  \@0$request ;
                  assign \@0$request = L1_Tb_Port[port].L1_RECEIVE2_Trans_request_a0;
                  logic  \@0$response ;
                  assign \@0$response = L1_Tb_Port[port].L1_RECEIVE2_Trans_response_a0;
                  logic  \@0$response_debug ;
                  assign \@0$response_debug = L1_Tb_Port[port].L1_RECEIVE2_Trans_response_debug_a0;
                  logic  \@0$sender ;
                  assign \@0$sender = L1_Tb_Port[port].L1_RECEIVE2_Trans_sender_a0;
               end
            end

            //
            // Scope: |send
            //
            if (1) begin : \|send 
               logic  \@1$avail ;
               assign \@1$avail = L1_Tb_Port[port].L1_SEND_avail_a1;
               logic  \@1$reset ;
               assign \@1$reset = L1_Tb_Port[port].L1_SEND_reset_a1;
               logic  \@1$valid_in ;
               assign \@1$valid_in = L1_Tb_Port[port].L1_SEND_valid_in_a1;

               //
               // Scope: /gen_trans
               //
               if (1) begin : \/gen_trans 
                  logic [15:0] \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_Port[port].L1_SEND_GenTrans_cyc_cnt_a1;
                  logic [4:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_Port[port].L1_SEND_GenTrans_dest_a1;
                  logic [1:0] \@1$dest_tmp ;
                  assign \@1$dest_tmp = L1_Tb_Port[port].L1_SEND_GenTrans_dest_tmp_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_Port[port].L1_SEND_GenTrans_response_debug_a1;
                  logic [4:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_Port[port].L1_SEND_GenTrans_sender_a1;
               end

               //
               // Scope: /trans_out
               //
               if (1) begin : \/trans_out 
                  logic [15:0] \@1$cyc_cnt ;
                  assign \@1$cyc_cnt = L1_Tb_Port[port].L1_SEND_TransOut_cyc_cnt_a1;
                  logic [1:0] \@1$dest ;
                  assign \@1$dest = L1_Tb_Port[port].L1_SEND_TransOut_dest_a1;
                  logic  \@1$response_debug ;
                  assign \@1$response_debug = L1_Tb_Port[port].L1_SEND_TransOut_response_debug_a1;
                  logic [4:0] \@1$sender ;
                  assign \@1$sender = L1_Tb_Port[port].L1_SEND_TransOut_sender_a1;
               end
            end
         end

         //
         // Scope: |count
         //
         if (1) begin : \|count 
            logic [15:0] \@0$CycCount ;
            assign \@0$CycCount = Tb_COUNT_CycCount_a0;
         end
      end


   end

endgenerate




generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.

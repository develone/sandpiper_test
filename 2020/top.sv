`line 2 "top.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
`include "sp_default.vh" //_\SV
   // This code can be found in: https://github.com/stevehoover/VSDOpen2020_TLV_RISC-V_Tutorial
   
   // Included URL: "https://raw.githubusercontent.com/stevehoover/VSDOpen2020_TLV_RISC-V_Tutorial/da942f09ddf780e5da5ee0466c72a610f07aa73f/lib/shell.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/2d6d36baa4d2bc62321f982f78c8fe1456641a43/risc-v_defs.tlv"

//_\SV
   module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
   /* verilator lint_on WIDTH */

`include "top_gen.sv" //_\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   // Inst #0: ADD,r10,r0,r0             // Initialize x10 to 0.
   // Function:
   // Inst #1: ADD,r14,r10,r0            // Initialize sum register x14 with 0x0
   // Inst #2: ADDI,r12,r10,1010         // Store count of 10 in register x12.
   // Inst #3: ADD,r13,r10,r0            // Initialize intermediate sum register x13 with 0
   // Loop:
   // Inst #4: ADD,r14,r13,r14           // Incremental addition
   // Inst #5: ADDI,r13,r13,1            // Increment intermediate register by 1
   // Inst #6: BLT,r13,r12,1111111111000 // If x13 is less than x12, branch to <loop>
   // Inst #7: ADD,r10,r14,r0            // Store final result to register x10 so that it can be read by main program
   
   
   //m4_define(['TBD'], [''0'])
   //m4_define(['TBDX'], [''])
   
   
   
   //_|view
      //_@0
         `BOGUS_USE(VIEW_pc_a0[4:0])
   // Lab: PC
   assign L0_pc_a0[31:0] = L0_reset_a1        ? 32'0 :
               L0_taken_branch_a1 ? L0_br_target_pc_a1 :    // (initially $taken_branch == 0)
                                  L0_pc_a1 + 32'b100;
   
   
   // Lab: Fetch
   assign L0_imem_rd_addr_a0[2:0] = L0_pc_a0[4:2];
   assign L0_instr_a0[31:0] = L0_imem_rd_data_a0;
   
   
   // Lab: Instruction Types Decode
   assign L0_is_i_instr_a0 = L0_instr_a0[6:5] == 2'b00;
   assign L0_is_r_instr_a0 = L0_instr_a0[6:5] == 2'b01 || L0_instr_a0[6:5] == 2'b10;
   assign L0_is_b_instr_a0 = L0_instr_a0[6:5] == 2'b11;
   
   
   // Lab: Instruction Immediate Decode
   assign L0_imm_a0[31:0]  = L0_is_i_instr_a0 ? { {21{L0_instr_a0[31]}}, L0_instr_a0[30:20] } :   // I-type
                 L0_is_b_instr_a0 ? { {20{L0_instr_a0[31]}},L0_instr_a0[7],L0_instr_a0[30:25],L0_instr_a0[11:8],1'b0 } :    // B-type
                 32'b0;   // Default (unused)
   
   
   // Lab: Instruction Field Decode
   assign L0_rs2_a0[4:0]    = L0_instr_a0[24:20];
   assign L0_rs1_a0[4:0]    = L0_instr_a0[19:15];
   assign L0_funct3_a0[2:0] = L0_instr_a0[14:12];
   assign L0_rd_a0[4:0]     = L0_instr_a0[11:7];
   assign L0_opcode_a0[6:0] = L0_instr_a0[6:0];
   
   
   // Lab: Register Validity Decode
   assign L0_rs1_valid_a0 = L0_is_r_instr_a0 || L0_is_i_instr_a0 || L0_is_b_instr_a0;
   assign L0_rs2_valid_a0 = L0_is_r_instr_a0 || L0_is_b_instr_a0;
   assign L0_rd_valid_a0  = L0_is_r_instr_a0 || L0_is_i_instr_a0;
   
   
   // Lab: Instruction Decode
   assign L0_dec_bits_a0[9:0] = {L0_funct3_a0, L0_opcode_a0};
   assign L0_is_blt_a0  = L0_dec_bits_a0 == 10'b100_1100011;
   assign L0_is_addi_a0 = L0_dec_bits_a0 == 10'b000_0010011;
   assign L0_is_add_a0  = L0_dec_bits_a0 == 10'b000_0110011;
   
   
   // Lab: Register File Read
   assign L0_rf_rd_en1_a0         = L0_rs1_valid_a0;
   assign L0_rf_rd_en2_a0         = L0_rs2_valid_a0;
   assign L0_rf_rd_index1_a0[4:0] = L0_rs1_a0;
   assign L0_rf_rd_index2_a0[4:0] = L0_rs2_a0;
   
   assign L0_src1_value_a0[31:0] = L0_rf_rd_data1_a0;
   assign L0_src2_value_a0[31:0] = L0_rf_rd_data2_a0;
   
   
   // Lab: ALU
   assign L0_result_a0[31:0] = L0_is_addi_a0 ? L0_src1_value_a0 + L0_imm_a0 :    // ADDI: src1 + imm
                   L0_is_add_a0  ? L0_src1_value_a0 + L0_src2_value_a0 :   // ADD: src1 + src2
                              32'b0;   // Default (unused)
   
   
   // Lab: Register File Write
   assign L0_rf_wr_en_a0         = L0_rd_valid_a0 /* && $rd != 5'b0 */;
   assign L0_rf_wr_index_a0[4:0] = L0_rd_a0;
   assign L0_rf_wr_data_a0[31:0] = L0_result_a0;
   
   
   // Lab: Branch Condition
   assign L0_taken_branch_a0 = L0_is_blt_a0 ?  (L0_src1_value_a0 < L0_src2_value_a0) /* ^ ($src1_value[31] != $src2_value[31]) */  : 1'b0;
   
   
   // Lab: Branch Target
   assign L0_br_target_pc_a0[31:0] = L0_pc_a0 + L0_imm_a0;
   // $taken_branch and $br_target_pc control the PC mux.
   
   
   
   `line 17 "/raw.githubusercontent.com/stevehoover/VSDOpen2020TLVRISCVTutorial/da942f09ddf780e5da5ee0466c72a610f07aa73f/lib/shell.tlv" 1   // Instantiated from top.tlv, 123 as: m4+shell()
      // =======================================================================================================
      // THIS CODE IS PROVIDED. NO NEED TO LOOK BEHIND THE CURTAIN. LEARN MORE USING THE MAKERCHIP TUTORIALS.
      
      
      
      
      assign L0_reset_a0 = reset;
      
      // Instruction Memory containing program defined by m4_asm(...) instantiations.
      /*SV_plus*/
         // The program in an instruction memory.
         logic [31:0] instrs [0:8-1];
         assign instrs = '{
            {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd10, 7'b0110011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd14, 7'b0110011}, {12'b1010, 5'd10, 3'b000, 5'd12, 7'b0010011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd13, 7'b0110011}, {7'b0000000, 5'd14, 5'd13, 3'b000, 5'd14, 7'b0110011}, {12'b1, 5'd13, 3'b000, 5'd13, 7'b0010011}, {1'b1, 6'b111111, 5'd12, 5'd13, 3'b100, 4'b1100, 1'b1, 7'b1100011}, {7'b0000000, 5'd0, 5'd14, 3'b000, 5'd10, 7'b0110011}
         };
      for (imem = 0; imem <= 7; imem++) begin : L1_Imem //_/imem
         assign Imem_instr_a0[imem][31:0] = instrs[imem]; end
      assign L0_imem_rd_data_a0[31:0] = Imem_instr_a0[L0_imem_rd_addr_a0];
      `BOGUS_USE(L0_imem_rd_data_a0)
      
      // Reg File
      for (xreg = 0; xreg <= 31; xreg++) begin : L1_Xreg logic L1_wr_a0; //_/xreg
         assign L1_wr_a0 = L0_rf_wr_en_a0 && (L0_rf_wr_index_a0 != 5'b0) && (L0_rf_wr_index_a0 == xreg);
         assign Xreg_value_a0[xreg][31:0] = L0_reset_a0 ? 32'b0           :
                        L1_wr_a0        ? L0_rf_wr_data_a0 :
                                     Xreg_value_a1[xreg][31:0]; end
      assign L0_rf_rd_data1_a0[31:0] = Xreg_value_a1[L0_rf_rd_index1_a0];
      assign L0_rf_rd_data2_a0[31:0] = Xreg_value_a1[L0_rf_rd_index2_a0];
      `BOGUS_USE(L0_rf_rd_data1_a0 L0_rf_rd_data2_a0)
      
      // Assert these to end simulation (before Makerchip cycle limit).
      assign passed = Xreg_value_a1[10] == (1+2+3+4+5+6+7+8+9);
      assign failed = cyc_cnt > 50;
      
      
      //_|view
         //_@0
            // String representations of the instructions for debug.
            /*SV_plus*/
               logic [40*8-1:0] instr_strs [0:8];
               assign instr_strs = '{ "(R) ADD r10,r0,r0                       ",  "(R) ADD r14,r10,r0                      ",  "(I) ADDI r12,r10,1010                   ",  "(R) ADD r13,r10,r0                      ",  "(R) ADD r14,r13,r14                     ",  "(I) ADDI r13,r13,1                      ",  "(B) BLT r13,r12,1111111111000           ",  "(R) ADD r10,r14,r0                      ",  "END                                     "};
            assign {VIEW_is_add_a0, VIEW_is_addi_a0, VIEW_is_blt_a0, VIEW_pc_a0[31:0], VIEW_reset_a0} = {L0_is_add_a0, L0_is_addi_a0, L0_is_blt_a0, L0_pc_a0[31:0], L0_reset_a0};
            for (imem = 0; imem <= 7; imem++) begin : L1_VIEW_Imem logic [40*8-1:0] L1_instr_str_a0; //_/imem
               assign {EMPTY} = {EMPTY};
               assign L1_instr_str_a0[40*8-1:0] = instr_strs[imem]; end
   
            assign VIEW_mnemonic_a0[10*8-1:0] = VIEW_is_blt_a0  ? "BLT       " :
                                  VIEW_is_addi_a0 ? "ADDI      " :
                                  VIEW_is_add_a0  ? "ADD       " :  "UNKNOWN   ";
            assign VIEW_valid_a0 = ! VIEW_reset_a0;
            `BOGUS_USE(VIEW_pc_a0[4:0])  // Bug workaround to pull lower bits.
            assign VIEW_fetch_instr_str_a0[40*8-1:0] = instr_strs[VIEW_pc_a0[$clog2(8+1)+1:2]];
   endgenerate //_\end_source
   `line 124 "top.tlv" 2


//_\SV
   endmodule

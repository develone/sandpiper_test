<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>top.m4 -> top.sv & top_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.9-2018_02_11-beta/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "top.m4 -> top.sv & top_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', 'Gating', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['top.m4', 0, 286, 2447, 0, 4, 288, 0, 0, 0, 'opacity: 0.1', 2658, 'opacity: 0.1', 1834, 'opacity: 0.1'],
      ['top.sv', 0, 286, 3489, 45, 0, 351, 0, 0, 0, 'opacity: 0.1', 2845, 'opacity: 0.1', 1943, 'opacity: 0.1'],
      ['top_gen.sv', 0, 0, 0, 1153, 309, 115, 0, 0, 2812, 'opacity: 0.1', 1438, 'opacity: 0.1', 1647, 'opacity: 0.1'],
      ['SV Total', 0, 286, 3489, 1198, 309, 466, 0, 0, 2812, 'opacity: 0.1', 4283, 'opacity: 0.1', 3590, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['DarkGray', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', 'orange', '#C0C0F0', '#C04040', 'gray'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">
<h2>top_gen.sv</h2>

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


</span><span class="tlx_structure">`include &quot;sandpiper_gen.vh&quot;


genvar imem, xreg;


</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For $br_target_pc.
</span><span class="tlx_declarations">logic [31:0] L0_br_target_pc_a0,
             L0_br_target_pc_a1;

</span><span class="tlx_comments">// For $dec_bits.
</span><span class="tlx_declarations">logic [9:0] L0_dec_bits_a0;

</span><span class="tlx_comments">// For $funct3.
</span><span class="tlx_declarations">logic [2:0] L0_funct3_a0;

</span><span class="tlx_comments">// For $imem_rd_addr.
</span><span class="tlx_declarations">logic [2:0] L0_imem_rd_addr_a0;

</span><span class="tlx_comments">// For $imem_rd_data.
</span><span class="tlx_declarations">logic [31:0] L0_imem_rd_data_a0;

</span><span class="tlx_comments">// For $imm.
</span><span class="tlx_declarations">logic [31:0] L0_imm_a0;

</span><span class="tlx_comments">// For $instr.
</span><span class="tlx_declarations">logic [31:0] L0_instr_a0;

</span><span class="tlx_comments">// For $is_add.
</span><span class="tlx_declarations">logic L0_is_add_a0;

</span><span class="tlx_comments">// For $is_addi.
</span><span class="tlx_declarations">logic L0_is_addi_a0;

</span><span class="tlx_comments">// For $is_b_instr.
</span><span class="tlx_declarations">logic L0_is_b_instr_a0;

</span><span class="tlx_comments">// For $is_blt.
</span><span class="tlx_declarations">logic L0_is_blt_a0;

</span><span class="tlx_comments">// For $is_i_instr.
</span><span class="tlx_declarations">logic L0_is_i_instr_a0;

</span><span class="tlx_comments">// For $is_r_instr.
</span><span class="tlx_declarations">logic L0_is_r_instr_a0;

</span><span class="tlx_comments">// For $opcode.
</span><span class="tlx_declarations">logic [6:0] L0_opcode_a0;

</span><span class="tlx_comments">// For $pc.
</span><span class="tlx_declarations">logic [31:0] L0_pc_a0,
             L0_pc_a1;

</span><span class="tlx_comments">// For $rd.
</span><span class="tlx_declarations">logic [4:0] L0_rd_a0;

</span><span class="tlx_comments">// For $rd_valid.
</span><span class="tlx_declarations">logic L0_rd_valid_a0;

</span><span class="tlx_comments">// For $reset.
</span><span class="tlx_declarations">logic L0_reset_a0,
      L0_reset_a1;

</span><span class="tlx_comments">// For $result.
</span><span class="tlx_declarations">logic [31:0] L0_result_a0;

</span><span class="tlx_comments">// For $rf_rd_data1.
</span><span class="tlx_declarations">logic [31:0] L0_rf_rd_data1_a0;

</span><span class="tlx_comments">// For $rf_rd_data2.
</span><span class="tlx_declarations">logic [31:0] L0_rf_rd_data2_a0;

</span><span class="tlx_comments">// For $rf_rd_en1.
</span><span class="tlx_declarations">logic L0_rf_rd_en1_a0;

</span><span class="tlx_comments">// For $rf_rd_en2.
</span><span class="tlx_declarations">logic L0_rf_rd_en2_a0;

</span><span class="tlx_comments">// For $rf_rd_index1.
</span><span class="tlx_declarations">logic [4:0] L0_rf_rd_index1_a0;

</span><span class="tlx_comments">// For $rf_rd_index2.
</span><span class="tlx_declarations">logic [4:0] L0_rf_rd_index2_a0;

</span><span class="tlx_comments">// For $rf_wr_data.
</span><span class="tlx_declarations">logic [31:0] L0_rf_wr_data_a0;

</span><span class="tlx_comments">// For $rf_wr_en.
</span><span class="tlx_declarations">logic L0_rf_wr_en_a0;

</span><span class="tlx_comments">// For $rf_wr_index.
</span><span class="tlx_declarations">logic [4:0] L0_rf_wr_index_a0;

</span><span class="tlx_comments">// For $rs1.
</span><span class="tlx_declarations">logic [4:0] L0_rs1_a0;

</span><span class="tlx_comments">// For $rs1_valid.
</span><span class="tlx_declarations">logic L0_rs1_valid_a0;

</span><span class="tlx_comments">// For $rs2.
</span><span class="tlx_declarations">logic [4:0] L0_rs2_a0;

</span><span class="tlx_comments">// For $rs2_valid.
</span><span class="tlx_declarations">logic L0_rs2_valid_a0;

</span><span class="tlx_comments">// For $src1_value.
</span><span class="tlx_declarations">logic [31:0] L0_src1_value_a0;

</span><span class="tlx_comments">// For $src2_value.
</span><span class="tlx_declarations">logic [31:0] L0_src2_value_a0;

</span><span class="tlx_comments">// For $taken_branch.
</span><span class="tlx_declarations">logic L0_taken_branch_a0,
      L0_taken_branch_a1;

</span><span class="tlx_comments">// For /imem$instr.
</span><span class="tlx_declarations">logic [31:0] Imem_instr_a0 [7:0];

</span><span class="tlx_comments">// For /xreg$value.
</span><span class="tlx_declarations">logic [31:0] Xreg_value_a0 [31:0],
             Xreg_value_a1 [31:0];

</span><span class="tlx_comments">// For |view$fetch_instr_str.
</span><span class="tlx_declarations">logic [40*8-1:0] VIEW_fetch_instr_str_a0;

</span><span class="tlx_comments">// For |view$is_add.
</span><span class="tlx_declarations">logic VIEW_is_add_a0;

</span><span class="tlx_comments">// For |view$is_addi.
</span><span class="tlx_declarations">logic VIEW_is_addi_a0;

</span><span class="tlx_comments">// For |view$is_blt.
</span><span class="tlx_declarations">logic VIEW_is_blt_a0;

</span><span class="tlx_comments">// For |view$mnemonic.
</span><span class="tlx_declarations">logic [10*8-1:0] VIEW_mnemonic_a0;

</span><span class="tlx_comments">// For |view$pc.
</span><span class="tlx_declarations">logic [31:0] VIEW_pc_a0;

</span><span class="tlx_comments">// For |view$reset.
</span><span class="tlx_declarations">logic VIEW_reset_a0;

</span><span class="tlx_comments">// For |view$valid.
</span><span class="tlx_declarations">logic VIEW_valid_a0;


</span><span class="tlx_structure">
generate
</span><span class="tlx_comments">
   // For $br_target_pc.
   </span><span class="tlx_staging">always_ff @(posedge clk) L0_br_target_pc_a1[31:0] &lt;= L0_br_target_pc_a0[31:0];

   </span><span class="tlx_comments">// For $pc.
   </span><span class="tlx_staging">always_ff @(posedge clk) L0_pc_a1[31:0] &lt;= L0_pc_a0[31:0];

   </span><span class="tlx_comments">// For $reset.
   </span><span class="tlx_staging">always_ff @(posedge clk) L0_reset_a1 &lt;= L0_reset_a0;

   </span><span class="tlx_comments">// For $taken_branch.
   </span><span class="tlx_staging">always_ff @(posedge clk) L0_taken_branch_a1 &lt;= L0_taken_branch_a0;


   </span><span class="tlx_comments">//
   // Scope: /xreg[31:0]
   //
   </span><span class="tlx_structure">for (xreg = 0; xreg &lt;= 31; xreg++) begin : L1gen_Xreg
</span><span class="tlx_comments">      // For $value.
      </span><span class="tlx_staging">always_ff @(posedge clk) Xreg_value_a1[xreg][31:0] &lt;= Xreg_value_a0[xreg][31:0];

   </span><span class="tlx_structure">end


endgenerate




</span><span class="tlx_comments">//
// Debug Signals
//

</span><span class="tlx_instrumentation">generate

   if (1) begin : DEBUG_SIGS

      logic [31:0] \@0$br_target_pc ;
      assign \@0$br_target_pc = L0_br_target_pc_a0;
      logic [9:0] \@0$dec_bits ;
      assign \@0$dec_bits = L0_dec_bits_a0;
      logic [2:0] \@0$funct3 ;
      assign \@0$funct3 = L0_funct3_a0;
      logic [2:0] \@0$imem_rd_addr ;
      assign \@0$imem_rd_addr = L0_imem_rd_addr_a0;
      logic [31:0] \@0$imem_rd_data ;
      assign \@0$imem_rd_data = L0_imem_rd_data_a0;
      logic [31:0] \@0$imm ;
      assign \@0$imm = L0_imm_a0;
      logic [31:0] \@0$instr ;
      assign \@0$instr = L0_instr_a0;
      logic  \@0$is_add ;
      assign \@0$is_add = L0_is_add_a0;
      logic  \@0$is_addi ;
      assign \@0$is_addi = L0_is_addi_a0;
      logic  \@0$is_b_instr ;
      assign \@0$is_b_instr = L0_is_b_instr_a0;
      logic  \@0$is_blt ;
      assign \@0$is_blt = L0_is_blt_a0;
      logic  \@0$is_i_instr ;
      assign \@0$is_i_instr = L0_is_i_instr_a0;
      logic  \@0$is_r_instr ;
      assign \@0$is_r_instr = L0_is_r_instr_a0;
      logic [6:0] \@0$opcode ;
      assign \@0$opcode = L0_opcode_a0;
      logic [31:0] \@0$pc ;
      assign \@0$pc = L0_pc_a0;
      logic [4:0] \@0$rd ;
      assign \@0$rd = L0_rd_a0;
      logic  \@0$rd_valid ;
      assign \@0$rd_valid = L0_rd_valid_a0;
      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;
      logic [31:0] \@0$result ;
      assign \@0$result = L0_result_a0;
      logic [31:0] \@0$rf_rd_data1 ;
      assign \@0$rf_rd_data1 = L0_rf_rd_data1_a0;
      logic [31:0] \@0$rf_rd_data2 ;
      assign \@0$rf_rd_data2 = L0_rf_rd_data2_a0;
      logic  \@0$rf_rd_en1 ;
      assign \@0$rf_rd_en1 = L0_rf_rd_en1_a0;
      logic  \@0$rf_rd_en2 ;
      assign \@0$rf_rd_en2 = L0_rf_rd_en2_a0;
      logic [4:0] \@0$rf_rd_index1 ;
      assign \@0$rf_rd_index1 = L0_rf_rd_index1_a0;
      logic [4:0] \@0$rf_rd_index2 ;
      assign \@0$rf_rd_index2 = L0_rf_rd_index2_a0;
      logic [31:0] \@0$rf_wr_data ;
      assign \@0$rf_wr_data = L0_rf_wr_data_a0;
      logic  \@0$rf_wr_en ;
      assign \@0$rf_wr_en = L0_rf_wr_en_a0;
      logic [4:0] \@0$rf_wr_index ;
      assign \@0$rf_wr_index = L0_rf_wr_index_a0;
      logic [4:0] \@0$rs1 ;
      assign \@0$rs1 = L0_rs1_a0;
      logic  \@0$rs1_valid ;
      assign \@0$rs1_valid = L0_rs1_valid_a0;
      logic [4:0] \@0$rs2 ;
      assign \@0$rs2 = L0_rs2_a0;
      logic  \@0$rs2_valid ;
      assign \@0$rs2_valid = L0_rs2_valid_a0;
      logic [31:0] \@0$src1_value ;
      assign \@0$src1_value = L0_src1_value_a0;
      logic [31:0] \@0$src2_value ;
      assign \@0$src2_value = L0_src2_value_a0;
      logic  \@0$taken_branch ;
      assign \@0$taken_branch = L0_taken_branch_a0;

      </span><span class="tlx_comments">//
      // Scope: /imem[7:0]
      //
      </span><span class="tlx_instrumentation">for (imem = 0; imem &lt;= 7; imem++) begin : \/imem 
         logic [31:0] \@0$instr ;
         assign \@0$instr = Imem_instr_a0[imem];
      end

      </span><span class="tlx_comments">//
      // Scope: /xreg[31:0]
      //
      </span><span class="tlx_instrumentation">for (xreg = 0; xreg &lt;= 31; xreg++) begin : \/xreg 
         logic [31:0] \@0$value ;
         assign \@0$value = Xreg_value_a0[xreg];
         logic  \@0$wr ;
         assign \@0$wr = L1_Xreg[xreg].L1_wr_a0;
      end

      </span><span class="tlx_comments">//
      // Scope: |view
      //
      </span><span class="tlx_instrumentation">if (1) begin : \|view 
         logic [40*8-1:0] \@0$fetch_instr_str ;
         assign \@0$fetch_instr_str = VIEW_fetch_instr_str_a0;
         logic  \@0$is_add ;
         assign \@0$is_add = VIEW_is_add_a0;
         logic  \@0$is_addi ;
         assign \@0$is_addi = VIEW_is_addi_a0;
         logic  \@0$is_blt ;
         assign \@0$is_blt = VIEW_is_blt_a0;
         logic [10*8-1:0] \@0$mnemonic ;
         assign \@0$mnemonic = VIEW_mnemonic_a0;
         logic [31:0] \@0$pc ;
         assign \@0$pc = VIEW_pc_a0;
         logic  \@0$reset ;
         assign \@0$reset = VIEW_reset_a0;
         logic  \@0$valid ;
         assign \@0$valid = VIEW_valid_a0;

         </span><span class="tlx_comments">//
         // Scope: /imem[7:0]
         //
         </span><span class="tlx_instrumentation">for (imem = 0; imem &lt;= 7; imem++) begin : \/imem 
            logic [40*8-1:0] \@0$instr_str ;
            assign \@0$instr_str = L1_VIEW_Imem[imem].L1_instr_str_a0;
         end
      end


   end

endgenerate




</span><span class="tlx_structure">generate   </span><span class="tlx_comments">// This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">
<h2>top.m4</h2>

<pre>
<span class="tlx_structure">\TLV_version 1d: tl-x.org
\SV
   </span><span class="tlx_comments">// This code can be found in: https://github.com/stevehoover/VSDOpen2020_TLV_RISC-V_Tutorial
   
   // Included URL: &quot;https://raw.githubusercontent.com/stevehoover/VSDOpen2020_TLV_RISC-V_Tutorial/da942f09ddf780e5da5ee0466c72a610f07aa73f/lib/shell.tlv&quot;// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/warp-v_includes/2d6d36baa4d2bc62321f982f78c8fe1456641a43/risc-v_defs.tlv&quot;

</span><span class="tlx_structure">\SV
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
   /* verilator lint_on WIDTH */

</span><span class="tlx_structure">\TLV

   </span><span class="tlx_comments">// /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   // Inst #0: ADD,r10,r0,r0             // Initialize x10 to 0.
   // Function:
   // Inst #1: ADD,r14,r10,r0            // Initialize sum register x14 with 0x0
   // Inst #2: ADDI,r12,r10,1010         // Store count of 10 in register x12.
   // Inst #3: ADD,r13,r10,r0            // Initialize intermediate sum register x13 with 0
   // Loop:
   // Inst #4: ADD,r14,r13,r14           // Incremental addition
   // Inst #5: ADDI,r13,r13,1            // Increment intermediate register by 1
   // Inst #6: BLT,r13,r12,1111111111000 // If x13 is less than x12, branch to &lt;loop&gt;
   // Inst #7: ADD,r10,r14,r0            // Store final result to register x10 so that it can be read by main program
   
   
   //m4_define(['TBD'], [''0'])
   //m4_define(['TBDX'], [''])
   
   
   
   </span><span class="tlx_structure">|view
      </span><span class="tlx_staging">@0
         </span><span class="tlx_logic">`BOGUS_USE($pc[4:0])
   </span><span class="tlx_comments">// Lab: PC
   </span><span class="tlx_logic">$pc[31:0] = &gt;&gt;1$reset        ? 32'0 :
               &gt;&gt;1$taken_branch ? &gt;&gt;1$br_target_pc :    </span><span class="tlx_comments">// (initially $taken_branch == 0)
                                  </span><span class="tlx_logic">&gt;&gt;1$pc + 32'b100;
   
   
   </span><span class="tlx_comments">// Lab: Fetch
   </span><span class="tlx_logic">$imem_rd_addr[2:0] = $pc[4:2];
   $instr[31:0] = $imem_rd_data;
   
   
   </span><span class="tlx_comments">// Lab: Instruction Types Decode
   </span><span class="tlx_logic">$is_i_instr = $instr[6:5] == 2'b00;
   $is_r_instr = $instr[6:5] == 2'b01 || $instr[6:5] == 2'b10;
   $is_b_instr = $instr[6:5] == 2'b11;
   
   
   </span><span class="tlx_comments">// Lab: Instruction Immediate Decode
   </span><span class="tlx_logic">$imm[31:0]  = $is_i_instr ? { {21{$instr[31]}}, $instr[30:20] } :   </span><span class="tlx_comments">// I-type
                 </span><span class="tlx_logic">$is_b_instr ? { {20{$instr[31]}},$instr[7],$instr[30:25],$instr[11:8],1'b0 } :    </span><span class="tlx_comments">// B-type
                 </span><span class="tlx_logic">32'b0;   </span><span class="tlx_comments">// Default (unused)
   
   
   // Lab: Instruction Field Decode
   </span><span class="tlx_logic">$rs2[4:0]    = $instr[24:20];
   $rs1[4:0]    = $instr[19:15];
   $funct3[2:0] = $instr[14:12];
   $rd[4:0]     = $instr[11:7];
   $opcode[6:0] = $instr[6:0];
   
   
   </span><span class="tlx_comments">// Lab: Register Validity Decode
   </span><span class="tlx_logic">$rs1_valid = $is_r_instr || $is_i_instr || $is_b_instr;
   $rs2_valid = $is_r_instr || $is_b_instr;
   $rd_valid  = $is_r_instr || $is_i_instr;
   
   
   </span><span class="tlx_comments">// Lab: Instruction Decode
   </span><span class="tlx_logic">$dec_bits[9:0] = {$funct3, $opcode};
   $is_blt  = $dec_bits == 10'b100_1100011;
   $is_addi = $dec_bits == 10'b000_0010011;
   $is_add  = $dec_bits == 10'b000_0110011;
   
   
   </span><span class="tlx_comments">// Lab: Register File Read
   </span><span class="tlx_logic">$rf_rd_en1         = $rs1_valid;
   $rf_rd_en2         = $rs2_valid;
   $rf_rd_index1[4:0] = $rs1;
   $rf_rd_index2[4:0] = $rs2;
   
   $src1_value[31:0] = $rf_rd_data1;
   $src2_value[31:0] = $rf_rd_data2;
   
   
   </span><span class="tlx_comments">// Lab: ALU
   </span><span class="tlx_logic">$result[31:0] = $is_addi ? $src1_value + $imm :    </span><span class="tlx_comments">// ADDI: src1 + imm
                   </span><span class="tlx_logic">$is_add  ? $src1_value + $src2_value :   </span><span class="tlx_comments">// ADD: src1 + src2
                              </span><span class="tlx_logic">32'b0;   </span><span class="tlx_comments">// Default (unused)
   
   
   // Lab: Register File Write
   </span><span class="tlx_logic">$rf_wr_en         = $rd_valid </span><span class="tlx_comments">/* &amp;&amp; $rd != 5'b0 */</span><span class="tlx_logic">;
   $rf_wr_index[4:0] = $rd;
   $rf_wr_data[31:0] = $result;
   
   
   </span><span class="tlx_comments">// Lab: Branch Condition
   </span><span class="tlx_logic">$taken_branch = $is_blt ?  ($src1_value &lt; $src2_value) </span><span class="tlx_comments">/* ^ ($src1_value[31] != $src2_value[31]) */  </span><span class="tlx_logic">: 1'b0;
   
   
   </span><span class="tlx_comments">// Lab: Branch Target
   </span><span class="tlx_logic">$br_target_pc[31:0] = $pc + $imm;
   </span><span class="tlx_comments">// $taken_branch and $br_target_pc control the PC mux.
   
   
   
   </span><span class="tlx_structure">\source /raw.githubusercontent.com/stevehoover/VSDOpen2020TLVRISCVTutorial/da942f09ddf780e5da5ee0466c72a610f07aa73f/lib/shell.tlv 16   </span><span class="tlx_comments">// Instantiated from top.tlv, 123 as: m4+shell()
      // =======================================================================================================
      // THIS CODE IS PROVIDED. NO NEED TO LOOK BEHIND THE CURTAIN. LEARN MORE USING THE MAKERCHIP TUTORIALS.
      
      
      
      
      </span><span class="tlx_logic">$reset = *reset;
      
      </span><span class="tlx_comments">// Instruction Memory containing program defined by m4_asm(...) instantiations.
      </span><span class="tlx_structure">\SV_plus
         </span><span class="tlx_comments">// The program in an instruction memory.
         </span><span class="tlx_logic">logic [31:0] instrs [0:8-1];
         assign instrs = '{
            {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd10, 7'b0110011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd14, 7'b0110011}, {12'b1010, 5'd10, 3'b000, 5'd12, 7'b0010011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd13, 7'b0110011}, {7'b0000000, 5'd14, 5'd13, 3'b000, 5'd14, 7'b0110011}, {12'b1, 5'd13, 3'b000, 5'd13, 7'b0010011}, {1'b1, 6'b111111, 5'd12, 5'd13, 3'b100, 4'b1100, 1'b1, 7'b1100011}, {7'b0000000, 5'd0, 5'd14, 3'b000, 5'd10, 7'b0110011}
         };
      </span><span class="tlx_structure">/imem[</span><span class="tlx_logic">7</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         </span><span class="tlx_logic">$instr[31:0] = *instrs\[#imem\];
      $imem_rd_data[31:0] = </span><span class="tlx_structure">/imem[</span><span class="tlx_logic">$imem_rd_addr</span><span class="tlx_structure">]</span><span class="tlx_logic">$instr;
      `BOGUS_USE($imem_rd_data)
      
      </span><span class="tlx_comments">// Reg File
      </span><span class="tlx_structure">/xreg[</span><span class="tlx_logic">31</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
         </span><span class="tlx_logic">$wr = </span><span class="tlx_structure">/top</span><span class="tlx_logic">$rf_wr_en &amp;&amp; (</span><span class="tlx_structure">/top</span><span class="tlx_logic">$rf_wr_index != 5'b0) &amp;&amp; (</span><span class="tlx_structure">/top</span><span class="tlx_logic">$rf_wr_index == #xreg);
         $value[31:0] = </span><span class="tlx_structure">/top</span><span class="tlx_logic">$reset ? 32'b0           :
                        $wr        ? </span><span class="tlx_structure">/top</span><span class="tlx_logic">$rf_wr_data :
                                     $RETAIN;
      $rf_rd_data1[31:0] = </span><span class="tlx_structure">/xreg[</span><span class="tlx_logic">$rf_rd_index1</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$value;
      $rf_rd_data2[31:0] = </span><span class="tlx_structure">/xreg[</span><span class="tlx_logic">$rf_rd_index2</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$value;
      `BOGUS_USE($rf_rd_data1 $rf_rd_data2)
      
      </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
      </span><span class="tlx_logic">*passed = </span><span class="tlx_structure">/xreg[</span><span class="tlx_logic">10</span><span class="tlx_structure">]</span><span class="tlx_logic">&gt;&gt;1$value == (1+2+3+4+5+6+7+8+9);
      *failed = *cyc_cnt &gt; 50;
      
      
      </span><span class="tlx_structure">|view
         </span><span class="tlx_staging">@0
            </span><span class="tlx_comments">// String representations of the instructions for debug.
            </span><span class="tlx_structure">\SV_plus
               </span><span class="tlx_logic">logic [40*8-1:0] instr_strs [0:8];
               assign instr_strs = '{ &quot;(R) ADD r10,r0,r0                       &quot;,  &quot;(R) ADD r14,r10,r0                      &quot;,  &quot;(I) ADDI r12,r10,1010                   &quot;,  &quot;(R) ADD r13,r10,r0                      &quot;,  &quot;(R) ADD r14,r13,r14                     &quot;,  &quot;(I) ADDI r13,r13,1                      &quot;,  &quot;(B) BLT r13,r12,1111111111000           &quot;,  &quot;(R) ADD r10,r14,r0                      &quot;,  &quot;END                                     &quot;};
            $ANY = </span><span class="tlx_structure">/top</span><span class="tlx_logic">&lt;&gt;0$ANY;
            </span><span class="tlx_structure">/imem[</span><span class="tlx_logic">7</span><span class="tlx_structure">:</span><span class="tlx_logic">0</span><span class="tlx_structure">]
               </span><span class="tlx_logic">$ANY = </span><span class="tlx_structure">/top/imem</span><span class="tlx_logic">&lt;&gt;0$ANY;
               $instr_str[40*8-1:0] = *instr_strs[imem];
   
            $mnemonic[10*8-1:0] = $is_blt  ? &quot;BLT       &quot; :
                                  $is_addi ? &quot;ADDI      &quot; :
                                  $is_add  ? &quot;ADD       &quot; :  &quot;UNKNOWN   &quot;;
            $valid = ! $reset;
            `BOGUS_USE($pc[4:0])  </span><span class="tlx_comments">// Bug workaround to pull lower bits.
            </span><span class="tlx_logic">$fetch_instr_str[40*8-1:0] = *instr_strs\[$pc[\$clog2(8+1)+1:2]\];
    </span><span class="tlx_structure">\end_source


\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">
<h2>top.sv</h2>

<pre>
<span class="tlx_structure">`line 2 &quot;top.tlv&quot; 0 </span><span class="tlx_comments">//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
</span><span class="tlx_structure">`include &quot;sp_default.vh&quot; </span><span class="tlx_comments">//_\SV
   // This code can be found in: https://github.com/stevehoover/VSDOpen2020_TLV_RISC-V_Tutorial
   
   // Included URL: &quot;https://raw.githubusercontent.com/stevehoover/VSDOpen2020_TLV_RISC-V_Tutorial/da942f09ddf780e5da5ee0466c72a610f07aa73f/lib/shell.tlv&quot;// Included URL: &quot;https://raw.githubusercontent.com/stevehoover/warp-v_includes/2d6d36baa4d2bc62321f982f78c8fe1456641a43/risc-v_defs.tlv&quot;

//_\SV
   </span><span class="tlx_untouched">module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    </span><span class="tlx_comments">/* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  </span><span class="tlx_untouched">bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  </span><span class="tlx_comments">/* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)
   /* verilator lint_on WIDTH */

</span><span class="tlx_structure">`include &quot;top_gen.sv&quot; </span><span class="tlx_comments">//_\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   // Inst #0: ADD,r10,r0,r0             // Initialize x10 to 0.
   // Function:
   // Inst #1: ADD,r14,r10,r0            // Initialize sum register x14 with 0x0
   // Inst #2: ADDI,r12,r10,1010         // Store count of 10 in register x12.
   // Inst #3: ADD,r13,r10,r0            // Initialize intermediate sum register x13 with 0
   // Loop:
   // Inst #4: ADD,r14,r13,r14           // Incremental addition
   // Inst #5: ADDI,r13,r13,1            // Increment intermediate register by 1
   // Inst #6: BLT,r13,r12,1111111111000 // If x13 is less than x12, branch to &lt;loop&gt;
   // Inst #7: ADD,r10,r14,r0            // Store final result to register x10 so that it can be read by main program
   
   
   //m4_define(['TBD'], [''0'])
   //m4_define(['TBDX'], [''])
   
   
   
   //_|view
      //_@0
         </span><span class="tlx_logic">`BOGUS_USE(VIEW_pc_a0[4:0])
   </span><span class="tlx_comments">// Lab: PC
   </span><span class="tlx_logic">assign L0_pc_a0[31:0] = L0_reset_a1        ? 32'0 :
               L0_taken_branch_a1 ? L0_br_target_pc_a1 :    </span><span class="tlx_comments">// (initially $taken_branch == 0)
                                  </span><span class="tlx_logic">L0_pc_a1 + 32'b100;
   
   
   </span><span class="tlx_comments">// Lab: Fetch
   </span><span class="tlx_logic">assign L0_imem_rd_addr_a0[2:0] = L0_pc_a0[4:2];
   assign L0_instr_a0[31:0] = L0_imem_rd_data_a0;
   
   
   </span><span class="tlx_comments">// Lab: Instruction Types Decode
   </span><span class="tlx_logic">assign L0_is_i_instr_a0 = L0_instr_a0[6:5] == 2'b00;
   assign L0_is_r_instr_a0 = L0_instr_a0[6:5] == 2'b01 || L0_instr_a0[6:5] == 2'b10;
   assign L0_is_b_instr_a0 = L0_instr_a0[6:5] == 2'b11;
   
   
   </span><span class="tlx_comments">// Lab: Instruction Immediate Decode
   </span><span class="tlx_logic">assign L0_imm_a0[31:0]  = L0_is_i_instr_a0 ? { {21{L0_instr_a0[31]}}, L0_instr_a0[30:20] } :   </span><span class="tlx_comments">// I-type
                 </span><span class="tlx_logic">L0_is_b_instr_a0 ? { {20{L0_instr_a0[31]}},L0_instr_a0[7],L0_instr_a0[30:25],L0_instr_a0[11:8],1'b0 } :    </span><span class="tlx_comments">// B-type
                 </span><span class="tlx_logic">32'b0;   </span><span class="tlx_comments">// Default (unused)
   
   
   // Lab: Instruction Field Decode
   </span><span class="tlx_logic">assign L0_rs2_a0[4:0]    = L0_instr_a0[24:20];
   assign L0_rs1_a0[4:0]    = L0_instr_a0[19:15];
   assign L0_funct3_a0[2:0] = L0_instr_a0[14:12];
   assign L0_rd_a0[4:0]     = L0_instr_a0[11:7];
   assign L0_opcode_a0[6:0] = L0_instr_a0[6:0];
   
   
   </span><span class="tlx_comments">// Lab: Register Validity Decode
   </span><span class="tlx_logic">assign L0_rs1_valid_a0 = L0_is_r_instr_a0 || L0_is_i_instr_a0 || L0_is_b_instr_a0;
   assign L0_rs2_valid_a0 = L0_is_r_instr_a0 || L0_is_b_instr_a0;
   assign L0_rd_valid_a0  = L0_is_r_instr_a0 || L0_is_i_instr_a0;
   
   
   </span><span class="tlx_comments">// Lab: Instruction Decode
   </span><span class="tlx_logic">assign L0_dec_bits_a0[9:0] = {L0_funct3_a0, L0_opcode_a0};
   assign L0_is_blt_a0  = L0_dec_bits_a0 == 10'b100_1100011;
   assign L0_is_addi_a0 = L0_dec_bits_a0 == 10'b000_0010011;
   assign L0_is_add_a0  = L0_dec_bits_a0 == 10'b000_0110011;
   
   
   </span><span class="tlx_comments">// Lab: Register File Read
   </span><span class="tlx_logic">assign L0_rf_rd_en1_a0         = L0_rs1_valid_a0;
   assign L0_rf_rd_en2_a0         = L0_rs2_valid_a0;
   assign L0_rf_rd_index1_a0[4:0] = L0_rs1_a0;
   assign L0_rf_rd_index2_a0[4:0] = L0_rs2_a0;
   
   assign L0_src1_value_a0[31:0] = L0_rf_rd_data1_a0;
   assign L0_src2_value_a0[31:0] = L0_rf_rd_data2_a0;
   
   
   </span><span class="tlx_comments">// Lab: ALU
   </span><span class="tlx_logic">assign L0_result_a0[31:0] = L0_is_addi_a0 ? L0_src1_value_a0 + L0_imm_a0 :    </span><span class="tlx_comments">// ADDI: src1 + imm
                   </span><span class="tlx_logic">L0_is_add_a0  ? L0_src1_value_a0 + L0_src2_value_a0 :   </span><span class="tlx_comments">// ADD: src1 + src2
                              </span><span class="tlx_logic">32'b0;   </span><span class="tlx_comments">// Default (unused)
   
   
   // Lab: Register File Write
   </span><span class="tlx_logic">assign L0_rf_wr_en_a0         = L0_rd_valid_a0 </span><span class="tlx_comments">/* &amp;&amp; $rd != 5'b0 */</span><span class="tlx_logic">;
   assign L0_rf_wr_index_a0[4:0] = L0_rd_a0;
   assign L0_rf_wr_data_a0[31:0] = L0_result_a0;
   
   
   </span><span class="tlx_comments">// Lab: Branch Condition
   </span><span class="tlx_logic">assign L0_taken_branch_a0 = L0_is_blt_a0 ?  (L0_src1_value_a0 &lt; L0_src2_value_a0) </span><span class="tlx_comments">/* ^ ($src1_value[31] != $src2_value[31]) */  </span><span class="tlx_logic">: 1'b0;
   
   
   </span><span class="tlx_comments">// Lab: Branch Target
   </span><span class="tlx_logic">assign L0_br_target_pc_a0[31:0] = L0_pc_a0 + L0_imm_a0;
   </span><span class="tlx_comments">// $taken_branch and $br_target_pc control the PC mux.
   
   
   
   </span><span class="tlx_structure">`line 17 &quot;/raw.githubusercontent.com/stevehoover/VSDOpen2020TLVRISCVTutorial/da942f09ddf780e5da5ee0466c72a610f07aa73f/lib/shell.tlv&quot; 1   </span><span class="tlx_comments">// Instantiated from top.tlv, 123 as: m4+shell()
      // =======================================================================================================
      // THIS CODE IS PROVIDED. NO NEED TO LOOK BEHIND THE CURTAIN. LEARN MORE USING THE MAKERCHIP TUTORIALS.
      
      
      
      
      </span><span class="tlx_logic">assign L0_reset_a0 = reset;
      
      </span><span class="tlx_comments">// Instruction Memory containing program defined by m4_asm(...) instantiations.
      /*SV_plus*/
         // The program in an instruction memory.
         </span><span class="tlx_logic">logic [31:0] instrs [0:8-1];
         assign instrs = '{
            {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd10, 7'b0110011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd14, 7'b0110011}, {12'b1010, 5'd10, 3'b000, 5'd12, 7'b0010011}, {7'b0000000, 5'd0, 5'd10, 3'b000, 5'd13, 7'b0110011}, {7'b0000000, 5'd14, 5'd13, 3'b000, 5'd14, 7'b0110011}, {12'b1, 5'd13, 3'b000, 5'd13, 7'b0010011}, {1'b1, 6'b111111, 5'd12, 5'd13, 3'b100, 4'b1100, 1'b1, 7'b1100011}, {7'b0000000, 5'd0, 5'd14, 3'b000, 5'd10, 7'b0110011}
         };
      </span><span class="tlx_structure">for (imem = 0; imem &lt;= 7; imem++) begin : L1_Imem </span><span class="tlx_comments">//_/imem
         </span><span class="tlx_logic">assign Imem_instr_a0[imem][31:0] = instrs[imem]; </span><span class="tlx_structure">end
      </span><span class="tlx_logic">assign L0_imem_rd_data_a0[31:0] = Imem_instr_a0[L0_imem_rd_addr_a0];
      `BOGUS_USE(L0_imem_rd_data_a0)
      
      </span><span class="tlx_comments">// Reg File
      </span><span class="tlx_structure">for (xreg = 0; xreg &lt;= 31; xreg++) begin : L1_Xreg </span><span class="tlx_declarations">logic L1_wr_a0; </span><span class="tlx_comments">//_/xreg
         </span><span class="tlx_logic">assign L1_wr_a0 = L0_rf_wr_en_a0 &amp;&amp; (L0_rf_wr_index_a0 != 5'b0) &amp;&amp; (L0_rf_wr_index_a0 == xreg);
         assign Xreg_value_a0[xreg][31:0] = L0_reset_a0 ? 32'b0           :
                        L1_wr_a0        ? L0_rf_wr_data_a0 :
                                     Xreg_value_a1[xreg][31:0]; </span><span class="tlx_structure">end
      </span><span class="tlx_logic">assign L0_rf_rd_data1_a0[31:0] = Xreg_value_a1[L0_rf_rd_index1_a0];
      assign L0_rf_rd_data2_a0[31:0] = Xreg_value_a1[L0_rf_rd_index2_a0];
      `BOGUS_USE(L0_rf_rd_data1_a0 L0_rf_rd_data2_a0)
      
      </span><span class="tlx_comments">// Assert these to end simulation (before Makerchip cycle limit).
      </span><span class="tlx_logic">assign passed = Xreg_value_a1[10] == (1+2+3+4+5+6+7+8+9);
      assign failed = cyc_cnt &gt; 50;
      
      
      </span><span class="tlx_comments">//_|view
         //_@0
            // String representations of the instructions for debug.
            /*SV_plus*/
               </span><span class="tlx_logic">logic [40*8-1:0] instr_strs [0:8];
               assign instr_strs = '{ &quot;(R) ADD r10,r0,r0                       &quot;,  &quot;(R) ADD r14,r10,r0                      &quot;,  &quot;(I) ADDI r12,r10,1010                   &quot;,  &quot;(R) ADD r13,r10,r0                      &quot;,  &quot;(R) ADD r14,r13,r14                     &quot;,  &quot;(I) ADDI r13,r13,1                      &quot;,  &quot;(B) BLT r13,r12,1111111111000           &quot;,  &quot;(R) ADD r10,r14,r0                      &quot;,  &quot;END                                     &quot;};
            assign {VIEW_is_add_a0, VIEW_is_addi_a0, VIEW_is_blt_a0, VIEW_pc_a0[31:0], VIEW_reset_a0} = {L0_is_add_a0, L0_is_addi_a0, L0_is_blt_a0, L0_pc_a0[31:0], L0_reset_a0};
            </span><span class="tlx_structure">for (imem = 0; imem &lt;= 7; imem++) begin : L1_VIEW_Imem </span><span class="tlx_declarations">logic [40*8-1:0] L1_instr_str_a0; </span><span class="tlx_comments">//_/imem
               </span><span class="tlx_logic">assign {EMPTY} = {EMPTY};
               assign L1_instr_str_a0[40*8-1:0] = instr_strs[imem]; </span><span class="tlx_structure">end
   
            </span><span class="tlx_logic">assign VIEW_mnemonic_a0[10*8-1:0] = VIEW_is_blt_a0  ? &quot;BLT       &quot; :
                                  VIEW_is_addi_a0 ? &quot;ADDI      &quot; :
                                  VIEW_is_add_a0  ? &quot;ADD       &quot; :  &quot;UNKNOWN   &quot;;
            assign VIEW_valid_a0 = ! VIEW_reset_a0;
            `BOGUS_USE(VIEW_pc_a0[4:0])  </span><span class="tlx_comments">// Bug workaround to pull lower bits.
            </span><span class="tlx_logic">assign VIEW_fetch_instr_str_a0[40*8-1:0] = instr_strs[VIEW_pc_a0[$clog2(8+1)+1:2]];
   </span><span class="tlx_structure">endgenerate </span><span class="tlx_comments">//_\end_source
   </span><span class="tlx_structure">`line 124 &quot;top.tlv&quot; 2


</span><span class="tlx_comments">//_\SV
   </span><span class="tlx_untouched">endmodule
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

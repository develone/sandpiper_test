// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// (Installed here: /home/devel/SandPiper_1.9-2018_02_11-beta_distro.)
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"


genvar imem, xreg;


//
// Signals declared top-level.
//

// For $br_target_pc.
logic [31:0] L0_br_target_pc_a0,
             L0_br_target_pc_a1;

// For $dec_bits.
logic [9:0] L0_dec_bits_a0;

// For $funct3.
logic [2:0] L0_funct3_a0;

// For $imem_rd_addr.
logic [2:0] L0_imem_rd_addr_a0;

// For $imem_rd_data.
logic [31:0] L0_imem_rd_data_a0;

// For $imm.
logic [31:0] L0_imm_a0;

// For $instr.
logic [31:0] L0_instr_a0;

// For $is_add.
logic L0_is_add_a0;

// For $is_addi.
logic L0_is_addi_a0;

// For $is_b_instr.
logic L0_is_b_instr_a0;

// For $is_blt.
logic L0_is_blt_a0;

// For $is_i_instr.
logic L0_is_i_instr_a0;

// For $is_r_instr.
logic L0_is_r_instr_a0;

// For $opcode.
logic [6:0] L0_opcode_a0;

// For $pc.
logic [31:0] L0_pc_a0,
             L0_pc_a1;

// For $rd.
logic [4:0] L0_rd_a0;

// For $rd_valid.
logic L0_rd_valid_a0;

// For $reset.
logic L0_reset_a0,
      L0_reset_a1;

// For $result.
logic [31:0] L0_result_a0;

// For $rf_rd_data1.
logic [31:0] L0_rf_rd_data1_a0;

// For $rf_rd_data2.
logic [31:0] L0_rf_rd_data2_a0;

// For $rf_rd_en1.
logic L0_rf_rd_en1_a0;

// For $rf_rd_en2.
logic L0_rf_rd_en2_a0;

// For $rf_rd_index1.
logic [4:0] L0_rf_rd_index1_a0;

// For $rf_rd_index2.
logic [4:0] L0_rf_rd_index2_a0;

// For $rf_wr_data.
logic [31:0] L0_rf_wr_data_a0;

// For $rf_wr_en.
logic L0_rf_wr_en_a0;

// For $rf_wr_index.
logic [4:0] L0_rf_wr_index_a0;

// For $rs1.
logic [4:0] L0_rs1_a0;

// For $rs1_valid.
logic L0_rs1_valid_a0;

// For $rs2.
logic [4:0] L0_rs2_a0;

// For $rs2_valid.
logic L0_rs2_valid_a0;

// For $src1_value.
logic [31:0] L0_src1_value_a0;

// For $src2_value.
logic [31:0] L0_src2_value_a0;

// For $taken_branch.
logic L0_taken_branch_a0,
      L0_taken_branch_a1;

// For /imem$instr.
logic [31:0] Imem_instr_a0 [7:0];

// For /xreg$value.
logic [31:0] Xreg_value_a0 [31:0],
             Xreg_value_a1 [31:0];

// For |view$fetch_instr_str.
logic [40*8-1:0] VIEW_fetch_instr_str_a0;

// For |view$is_add.
logic VIEW_is_add_a0;

// For |view$is_addi.
logic VIEW_is_addi_a0;

// For |view$is_blt.
logic VIEW_is_blt_a0;

// For |view$mnemonic.
logic [10*8-1:0] VIEW_mnemonic_a0;

// For |view$pc.
logic [31:0] VIEW_pc_a0;

// For |view$reset.
logic VIEW_reset_a0;

// For |view$valid.
logic VIEW_valid_a0;



generate

   // For $br_target_pc.
   always_ff @(posedge clk) L0_br_target_pc_a1[31:0] <= L0_br_target_pc_a0[31:0];

   // For $pc.
   always_ff @(posedge clk) L0_pc_a1[31:0] <= L0_pc_a0[31:0];

   // For $reset.
   always_ff @(posedge clk) L0_reset_a1 <= L0_reset_a0;

   // For $taken_branch.
   always_ff @(posedge clk) L0_taken_branch_a1 <= L0_taken_branch_a0;


   //
   // Scope: /xreg[31:0]
   //
   for (xreg = 0; xreg <= 31; xreg++) begin : L1gen_Xreg
      // For $value.
      always_ff @(posedge clk) Xreg_value_a1[xreg][31:0] <= Xreg_value_a0[xreg][31:0];

   end


endgenerate




//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS

      logic [31:0] \@0$br_target_pc ;
      assign \@0$br_target_pc = L0_br_target_pc_a0;
      logic [9:0] \@0$dec_bits ;
      assign \@0$dec_bits = L0_dec_bits_a0;
      logic [2:0] \@0$funct3 ;
      assign \@0$funct3 = L0_funct3_a0;
      logic [2:0] \@0$imem_rd_addr ;
      assign \@0$imem_rd_addr = L0_imem_rd_addr_a0;
      logic [31:0] \@0$imem_rd_data ;
      assign \@0$imem_rd_data = L0_imem_rd_data_a0;
      logic [31:0] \@0$imm ;
      assign \@0$imm = L0_imm_a0;
      logic [31:0] \@0$instr ;
      assign \@0$instr = L0_instr_a0;
      logic  \@0$is_add ;
      assign \@0$is_add = L0_is_add_a0;
      logic  \@0$is_addi ;
      assign \@0$is_addi = L0_is_addi_a0;
      logic  \@0$is_b_instr ;
      assign \@0$is_b_instr = L0_is_b_instr_a0;
      logic  \@0$is_blt ;
      assign \@0$is_blt = L0_is_blt_a0;
      logic  \@0$is_i_instr ;
      assign \@0$is_i_instr = L0_is_i_instr_a0;
      logic  \@0$is_r_instr ;
      assign \@0$is_r_instr = L0_is_r_instr_a0;
      logic [6:0] \@0$opcode ;
      assign \@0$opcode = L0_opcode_a0;
      logic [31:0] \@0$pc ;
      assign \@0$pc = L0_pc_a0;
      logic [4:0] \@0$rd ;
      assign \@0$rd = L0_rd_a0;
      logic  \@0$rd_valid ;
      assign \@0$rd_valid = L0_rd_valid_a0;
      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;
      logic [31:0] \@0$result ;
      assign \@0$result = L0_result_a0;
      logic [31:0] \@0$rf_rd_data1 ;
      assign \@0$rf_rd_data1 = L0_rf_rd_data1_a0;
      logic [31:0] \@0$rf_rd_data2 ;
      assign \@0$rf_rd_data2 = L0_rf_rd_data2_a0;
      logic  \@0$rf_rd_en1 ;
      assign \@0$rf_rd_en1 = L0_rf_rd_en1_a0;
      logic  \@0$rf_rd_en2 ;
      assign \@0$rf_rd_en2 = L0_rf_rd_en2_a0;
      logic [4:0] \@0$rf_rd_index1 ;
      assign \@0$rf_rd_index1 = L0_rf_rd_index1_a0;
      logic [4:0] \@0$rf_rd_index2 ;
      assign \@0$rf_rd_index2 = L0_rf_rd_index2_a0;
      logic [31:0] \@0$rf_wr_data ;
      assign \@0$rf_wr_data = L0_rf_wr_data_a0;
      logic  \@0$rf_wr_en ;
      assign \@0$rf_wr_en = L0_rf_wr_en_a0;
      logic [4:0] \@0$rf_wr_index ;
      assign \@0$rf_wr_index = L0_rf_wr_index_a0;
      logic [4:0] \@0$rs1 ;
      assign \@0$rs1 = L0_rs1_a0;
      logic  \@0$rs1_valid ;
      assign \@0$rs1_valid = L0_rs1_valid_a0;
      logic [4:0] \@0$rs2 ;
      assign \@0$rs2 = L0_rs2_a0;
      logic  \@0$rs2_valid ;
      assign \@0$rs2_valid = L0_rs2_valid_a0;
      logic [31:0] \@0$src1_value ;
      assign \@0$src1_value = L0_src1_value_a0;
      logic [31:0] \@0$src2_value ;
      assign \@0$src2_value = L0_src2_value_a0;
      logic  \@0$taken_branch ;
      assign \@0$taken_branch = L0_taken_branch_a0;

      //
      // Scope: /imem[7:0]
      //
      for (imem = 0; imem <= 7; imem++) begin : \/imem 
         logic [31:0] \@0$instr ;
         assign \@0$instr = Imem_instr_a0[imem];
      end

      //
      // Scope: /xreg[31:0]
      //
      for (xreg = 0; xreg <= 31; xreg++) begin : \/xreg 
         logic [31:0] \@0$value ;
         assign \@0$value = Xreg_value_a0[xreg];
         logic  \@0$wr ;
         assign \@0$wr = L1_Xreg[xreg].L1_wr_a0;
      end

      //
      // Scope: |view
      //
      if (1) begin : \|view 
         logic [40*8-1:0] \@0$fetch_instr_str ;
         assign \@0$fetch_instr_str = VIEW_fetch_instr_str_a0;
         logic  \@0$is_add ;
         assign \@0$is_add = VIEW_is_add_a0;
         logic  \@0$is_addi ;
         assign \@0$is_addi = VIEW_is_addi_a0;
         logic  \@0$is_blt ;
         assign \@0$is_blt = VIEW_is_blt_a0;
         logic [10*8-1:0] \@0$mnemonic ;
         assign \@0$mnemonic = VIEW_mnemonic_a0;
         logic [31:0] \@0$pc ;
         assign \@0$pc = VIEW_pc_a0;
         logic  \@0$reset ;
         assign \@0$reset = VIEW_reset_a0;
         logic  \@0$valid ;
         assign \@0$valid = VIEW_valid_a0;

         //
         // Scope: /imem[7:0]
         //
         for (imem = 0; imem <= 7; imem++) begin : \/imem 
            logic [40*8-1:0] \@0$instr_str ;
            assign \@0$instr_str = L1_VIEW_Imem[imem].L1_instr_str_a0;
         end
      end


   end

endgenerate




generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
